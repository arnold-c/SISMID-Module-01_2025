{
  "hash": "4c199052c0d216198ab193f2d033a0f1",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat:\n    html:\n        code-fold: false\n        code-line-numbers: false\n---\n\n\n\n\n# Just Enough R {.unnumbered}\n\nThe purpose of this section is to get you up-to-speed with `R`.\nIf you're completely unfamiliar with `R` and RStudio, this should provide you with enough to get started and understand what's going on in the code (and you can always refer back to this page if you understandably get a little lost), and if you have some experience, then it should provide a sufficient description of the packages and functions that we use in this workshop.\n\nNow you have `R` set installed and you can access it and are familiar with RStudio, it's time to learn some of the core features of the language.\n\n<a id=\"suggested-reading\"/>\n\n::: {.callout-tip}\nWe'd strongly recommend you read [Hands-On Programming With R](https://rstudio-education.github.io/hopr) by Garett Grolemund and [R for DataScience](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Ã‡etinkaya-Rundel, and Garrett Grolemund for a deeper understanding of the following concepts (and many more).\n:::\n\n## Objects & types introduction\n\nAn object is anything you can create in R using code, whether that is a table you import from a **csv** file (that will get converted to a **dataframe**), or a **vector** you create within a script.\nEach object you create has a **type**.\nWe've already mentioned two (**dataframes** and **vectors**), but there are plenty more.\nBut before we get into object types, let's take a step back and look at types in general, thinking about individual elements and the fundamentals.\n\n## Element types\n\nGenerally in programming, we have two broad types of numbers: **floating point** and **integer** numbers, i.e., numbers with decimals, and whole numbers, respectively.\nIn `R`, we have these number types, but a **floating point** number is called a **double**.\nThe **floating point** number is the default type `R` assigns to number: look at the types assigned when we leave off a decimal place vs. specify type integer by ending a number with an `L`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(1L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note collapse=true}\nTechnically type **double** is a subset of type **numeric**, so you will often see people convert numbers to floating points using `as.numeric()`, rather than `as.double()`, but the different is semantics.\nYou can confirm this using the command `typeof(as.numeric(10)) == typeof(as.double(10))semantics.\nYou can confirm this using the command `typeof(as.numeric(10)) == typeof(as.double(10))`.\n:::\n\nInteger types are not commonly used in `R`, but there are occasions when you will want to use them e.g., when you need whole numbers of people in a simulation you may want to use integers to enforce this.\nIntegers are also slightly more precise (unless very big or small), so when exactness in whole number is required, you may want to use integers.\n\n::: {.callout-note collapse=true}\n`R` has some idiosyncrasies when it comes to numbers.\nFor the most part, **doubles** are produced, but occasionally an **integer** will be produced when you are expecting a **double**.\n\nFor example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(seq(1, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(seq(1, 10, by = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n\n:::\n\nOutside of numbers, we have **characters** (**strings**) and **boolean** types.\n\nA **boolean** (also known as a **logical** in `R`) is a `TRUE/FALSE` statement.\nIn `R`, as in many programming languages, `TRUE` is equal to a value of 1, and `FALSE` equals `0`.\nThere are times when this comes in handy e.g. you need to calculate the number of people that responded to a question, and their responses is coded as `TRUE/FALSE`, you can just sum the **vector** of responses (more on **vectors** shortly).\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE == 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nFALSE == 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-tip title=\"Question\" appearance=\"minimal\"}\nCan you figure out what value will be returned for the command `(TRUE == 0) == FALSE`?\n:::\n\nA **character** is anything in quotation marks.\nThis would typically by letter, but is occasionally a number, or other symbol.\nOther languages make a distinction between **characters** and **strings**, but not `R`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(\"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(\"1\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\nIt is important to note that characters are not **parsed** i.e., they are not interpreted by `R` as anything other than a **character**.\nThis means that despite `\"1\"` looking like the number `1`, it behaves like a **character** in `R`, not a **double**, so we can't do addition etc. with it.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"1\" + 1\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in \"1\" + 1: non-numeric argument to binary operator\n```\n\n\n:::\n:::\n\n\n\n\n## Object types\n### Vectors\n\nAs mentioned, anything you can create in `R` is an object.\nFor example, we can create an character object with the assignment operator (`<-`).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_char_obj <- \"a\"\n```\n:::\n\n\n\n\n::: {.callout-note collapse=true}\nIn other languages, `=` is used for assignment.\nIn `R`, this is generally avoided to distinguish between creating objects (assignment), and specifying argument values (see the [section on functions](#functions)).\nHowever, despite what some purists may say, it really doesn't matter which one you use, from a practical standpoint.\n:::\n\nYou will note that when we created our object, it did not return a value (unlike the previous examples, a value was not printed).\nTo retrieve the value of the object (in this case, just print it), we just type out the object name.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_char_obj\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\"\n```\n\n\n:::\n:::\n\n\n\n\nIn this case, we just create an object with only one element.\nWe can check this using the `length()` function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(my_char_obj)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n\nWe could also create an **atomic vector** (commonly just called a **vector**, which we'll use from here-on in).\nIn fact, `my_char_obj` is actually an **vector**, i.e., it is a vector of length 1, as we've just seen.\nGenerally, a **vector** is an object that contains multiple elements that each have the same type.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_char_vec <- c(\"a\", \"b\", \"c\")\n```\n:::\n\n\n\n\nAs we'll see in the example below, we can give each element in a **vector** a name, and to highlight that vectors must contain elements of the same type, watch what happens here.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_named_char_vec <- c(a = \"a\", b = \"b\", c = \"c\", d = 1)\nnames(my_named_char_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\" \"b\" \"c\" \"d\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_named_char_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  a   b   c   d \n\"a\" \"b\" \"c\" \"1\" \n```\n\n\n:::\n:::\n\n\n\n\nBecause `R` saw the majority of the first elements in the **vector** were of type **character** it **coerced** the number to a **character**.\nThis is super important to be aware of, as it can cause errors, particularly when coercion goes in the other direction i.e. trying to create a **numeric vector**.\n\n#### Factors\n\nAll the **vector** types we've mentioned so far map nicely to their corresponding **element** types.\nBut there is an extension of the **character** vector used frequently: the **factor** (and, correspondingly, the **ordered** vector).\n\nA **factor** is a **vector** where there are distinct groups that exist within a **vector** i.e., they are *nominal categorical data*.\nFor example, we often include gender as a covariate in epidemiological analysis.\nThere is no intrinsic order, but we would want to account for the groups in the analysis.\n\nAn **ordered vector** is when there *is* an intrinsic order to the grouping i.e., we have *ordinal categorical data*.\nIf, for example, we were interested in how the frequency of cigarette smoking is related to an outcome, and we wanted to use *binned* groups, rather than treating it as a continuous value, we would want to create an **ordered vector** as the ordering of the different groupings is important.\n\nLet's use the `mtcars` dataset (that comes installed with `R`), and turn the number of cylinders (`cyl`) into an **ordered vector**, as there are discrete numbers of cylinders a car engine can have, *and* the ordering matters.\nDon't worry about what `$` is doing; we'll come to that [later](#indexing-objects)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_mtcars <- mtcars\nmy_mtcars$cyl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_mtcars$cyl <- ordered(my_mtcars$cyl)\nmy_mtcars$cyl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\nLevels: 4 < 6 < 8\n```\n\n\n:::\n:::\n\n\n\n\nIf we wanted to directly specify the ordering of the groups, we can do this using the `levels` argument i.e.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_mtcars$cyl <- ordered(my_mtcars$cyl, levels = c(8, 6, 4))\nmy_mtcars$cyl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\nLevels: 8 < 6 < 4\n```\n\n\n:::\n:::\n\n\n\n\nTo create a **factor**, just replace the `ordered()` call with `factor()`\n\n\n### Lists\n\nThere is another type of **vector**: the **list**.\nMost people do not refer to **lists** as type of **vectors**, so we will only refer to them as **lists**, and **atomic vectors** will just be referred to as **vectors**.\n\nUnlike **vectors** there are no requirements about the form of **lists** i.e., each element of the **list** can be completely different.\nOne element could store a **vector** of numbers, another a model object, another a **dataframe**, and another a **list** (i.e. a nested **list**).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list <- list(\n    c(1, 2, 3, 4, 5),\n    glm(mpg ~ ordered(cyl) + disp + hp, data = mtcars),\n    data.frame(column_1 = 1:5, column_2 = 6:10)\n)\nmy_named_list <- list(\n    my_vec = c(1, 2, 3, 4, 5),\n    my_model = glm(mpg ~ ordered(cyl) + disp + hp, data = my_mtcars),\n    my_dataframe = data.frame(column_1 = 1:5, column_2 = 6:10)\n)\nmy_list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n\nCall:  glm(formula = mpg ~ ordered(cyl) + disp + hp, data = mtcars)\n\nCoefficients:\n   (Intercept)  ordered(cyl).L  ordered(cyl).Q            disp              hp  \n      28.98802        -1.71963         2.31169        -0.02604        -0.02114  \n\nDegrees of Freedom: 31 Total (i.e. Null);  27 Residual\nNull Deviance:\t    1126 \nResidual Deviance: 225.1 \tAIC: 165.2\n\n[[3]]\n  column_1 column_2\n1        1        6\n2        2        7\n3        3        8\n4        4        9\n5        5       10\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_named_list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$my_vec\n[1] 1 2 3 4 5\n\n$my_model\n\nCall:  glm(formula = mpg ~ ordered(cyl) + disp + hp, data = my_mtcars)\n\nCoefficients:\n   (Intercept)  ordered(cyl).L  ordered(cyl).Q            disp              hp  \n      28.98802         1.71963         2.31169        -0.02604        -0.02114  \n\nDegrees of Freedom: 31 Total (i.e. Null);  27 Residual\nNull Deviance:\t    1126 \nResidual Deviance: 225.1 \tAIC: 165.2\n\n$my_dataframe\n  column_1 column_2\n1        1        6\n2        2        7\n3        3        8\n4        4        9\n5        5       10\n```\n\n\n:::\n:::\n\n\n\n\nSimilar to **vectors**, **lists** can be named, or unnamed, and also that we they display in slightly different ways: when unnamed, we get the notation `[[1]] ... [[3]]` to denote the different **list** elements, and with the **named list** we get `$my_vec ... $my_dataframe`.\nIt is often useful to name them, though, as it gives you some useful options when it comes to indexing and extracting values later.\n\n::: {.callout-note collapse=true}\nIf you're wondering why we are creating our list elements with the `=` operator, that's because we can think of this as an argument in the `list()` function, where the argument name is the name we want the element to have, and the argument value is the element itself.\n:::\n\n### Dataframes\n\n**Dataframes** are the last key object type to learn about.\nA **dataframe** is technically a special type of list.\nEffectively, it is a 2-D table where every column has to have elements of the same type (i.e., is a **vector**), but the columns can be different types to each other.\nThe other important restriction is that all columns must be the same length, i.e. we have a rectangular **dataframe**.\n\nAs we've seen before, we can create a dataframe using this code, where `1:5` is shorthand for a vector that contains the sequence of numbers from 1 to 5, inclusive (i.e., `c(1, 2, 3, 4, 5)`).\nWe could also write this sequence as `seq(1, 5, by = 1)`, allowing us more control over the steps in the sequence.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_dataframe <- data.frame(\n    column_int = 1:5,\n    column_dbl = seq(6, 10, 1),\n    column_3 = letters[1:5]\n)\n```\n:::\n\n\n\n\nLike with every other object type, we can just type in the **dataframe's** name to return it's value, but this tim, let' explore the *structure* of the **dataframe** using the `str()` function.\nThis function can be used on any of the objects we've seen so far, and is particularly helpful when exploring **lists**.\nOne nice feature of **dataframes** is that it will explicitly print the columns types.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(my_dataframe)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t5 obs. of  3 variables:\n $ column_int: int  1 2 3 4 5\n $ column_dbl: num  6 7 8 9 10\n $ column_3  : chr  \"a\" \"b\" \"c\" \"d\" ...\n```\n\n\n:::\n:::\n\n\n\n\n### Matrices\n\n**Matrices** are crucial to many scientific fields, including epidemiology, as they are the basis of linear algebra.\nThis course will use **matrix** multiplication extensively (notably [R Session 2](r-session-02.qmd)), so it is worth knowing how to create matrices.\n\nMuch like vectors, all elements in a **matrix** should be the same type (or they will be coerced if possible, resulting in `NA` if not).\nIt is unusual to have a **non-numeric matrix** e.g., a **character matrix**, but it is possible.\nWhen we create our **matrix**, notice that it fills column-first, much like how we think of **matrices** in math (i.e., `i` then `j`).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix <- matrix(1:8, nrow = 2)\nmy_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n```\n\n\n:::\n:::\n\n\n\n\n## Indexing objects\n### Indexing operators\n\nWe've got our objects, but now we want to do stuff with them.\nWithout getting into too much detail about *Object-Oriented Programming* (e.g., the `S3` class system in `R`), there are three mains ways of indexing in `R`:\n\n- The single bracket `[]`\n- The double bracket `[[]]`\n- The dollar sign `$`\n\nWhich method we use depends on the type of object we have.\nHandily, `[]` will work for pretty much everything, and we typically only use use `[[]]` for **lists**.\n\n### Indexing vectors\n\nWith both `[]` and `[[]]`, we can use the *indices* i.e., the numbered position of the specific values/elements we want to extract, but if we have named objects, we can pass the names to the `[]` in a **vector**.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract elements 1 through 3 inclusively\nmy_char_vec[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\" \"b\" \"c\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract the same elements but using their names in a vector\nmy_named_char_vec[c(\"a\", \"b\", \"c\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  a   b   c \n\"a\" \"b\" \"c\" \n```\n\n\n:::\n:::\n\n\n\n\nNotice that when we index the named **vector** we get *both* the name *and* the value returned.\nMany times this is OK, but if we only wanted the value, then you'd index with `[[]]`, but it is important to note that you can only pass *one* value to the brackets.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_named_char_vec[[c(\"a\", \"b\")]]\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in my_named_char_vec[[c(\"a\", \"b\")]]: attempt to select more than one element in vectorIndex\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_named_char_vec[[\"a\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\"\n```\n\n\n:::\n:::\n\n\n\n\nIf you're wondering why go through the hassle, it's because values can change position in the list when we update inputs, such as **csv** datafiles, or needing to restructure code to make something else work.\nIf we only index with the numeric indices, we run the risk of a silent error being returned i.e., a value is provided to us, but we don't know that it's referring to the wrong thing.\nIndexing with names mean that the element's position in the **vector** doesn't matter, and if it's accidentally been removed when we updated code, and error will be explicitly thrown as it won't be able to find the index.\n\n### Lists and Dataframes\n\nWhen it comes to indexing **lists** and **dataframes** (remember, **dataframes** are just special **lists**, so the same methods are available to us), it is more common to use `[[]]` and `$`, though there are obviously occasions when `[]` is useful.\nLet's look at `my_named_list` first.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_named_list[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$my_vec\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_named_list[\"my_vec\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$my_vec\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_named_list[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_named_list[[\"my_vec\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_named_list$my_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note}\nIn the examples above, notice how both `[]` methods returned the name of the element as well as the values (as it did before with the named **vector**).\nThis is important as it means we need to extract the values from what is returned before we can do any further indexing i.e., to get the value `3` from the **list** element `my_vec`.\n:::\n\nWe can do the same with the unnamed **list**, except the last two methods are not available as we do not have a name to use.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_list[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n:::\n\n\n\n\nBecause a **dataframe** is a type of list where the column headers are the element names, we can use `[[]]` and `$` as with the named list.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_dataframe[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  column_int\n1          1\n2          2\n3          3\n4          4\n5          5\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_dataframe[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_dataframe[\"column_int\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  column_int\n1          1\n2          2\n3          3\n4          4\n5          5\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_dataframe$column_int\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n:::\n\n\n\n\nIf we wanted to extract a particular value from a column, we can use the following methods.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# indexes i then j, just like in math\nmy_dataframe[2, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract the second element from the first column\nmy_dataframe[[1]][2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract the second element from column_int, using the i, j procedure as before\nmy_dataframe[2, \"column_int\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract the second element from column_int\nmy_dataframe$column_int[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n\n## Packages\n\nUp until now, we've been getting to grips with the core concepts of objects, and indexing them.\nBut when you're writing code, you'll want to do things that are relatively complicated to implement, such as solve a set of differential equations.\nFortunately, for many areas of computing (and, indeed, epidemiology and statistics), many others have also struggled with the same issues and some have gone one to document their solutions in a way others can re-use them.\nThis is the basis for **packages**.\nSomeone has *packaged up* a set of functions for others to re-use.\n\nWe've mentioned the word **function** a number of time so far, and we haven't defined it, but that's [coming soon](#functions).\nFor the moment, let's just look at how we can find, install, and load **packages**.\n\n### Finding packages\n\nAs [mentioned previously](install-r.qmd#r) CRAN is a place where many pieces of `R` code is documents and stored for others to download and use.\nNot only are the `R` programming language executables stored in CRAN, but so are user-defined **functions** that have been turned into **packages**.\n\nTo find packages, you can go to the CRAN website and search by name, but there are far too many for that to be worthwhile - just Google what you want to do and add \"r\" to the end of your search query, and you'll likely find what you're looking for.\nOnce you've found a package you want to download, next you need to install it.\n\n### Installing packages\n\nBarring any super-niche packages, you should be able to use the following command(s):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"package to download\")\n# Download multiple by passing a vector of package names\ninstall.packages(c(\"package 1\", \"package 2\"))\n```\n:::\n\n\n\n\nIf for some reason you get an error message saying the package isn't available on CRAN, first, check for typos, and if you still get an error, you may need to download it directly from GitHub.\nRead [here](https://pak.r-lib.org/dev/reference/get-started.html#install-a-package-from-github) for more information about using the `{pak}` package to download packages from other sources.\n\n### Loading packages\n\nNow you have your packages installed, you just need to load them to get any of their functionality.\nThe easiest way is to place this code at the top of your script.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Quotations are not required, but can be used\nlibrary(package to download)\n```\n:::\n\n\n\n\n<a id=\"namespace-conflict\"/>\n\nMost of the time, this is fine, but occasionally you will run in to an issue where a function doesn't work as expected.\nSometimes this is because of what's called a *namespace conflict* i.e., you have two functions with the same name loaded, and potentially you're using the wrong verion.\n\nFor example, in base `R` (i.e, these functions come pre-installed when you set up `R`), there is a `filter()` function from the `{stats}` package (as mentioned, we'll denote this as `stats::filter()`).\nThroughout this workshop, you will see `library(tidyverse)` at the top of the pages to indicate the `{tidyverse}` set of packages are being loaded (this is actually a package that installs a bunch of related and useful packages for us).\nIn `{dplyr}` (one of the packages loaded by `{tidyverse}`) there is also a function called `filter()`.\nBecause `{dplyr}` was loaded after `{stats}` was loaded (because `{stats}` is automatically loaded when `R` is started), the `dplyr::filter()` function will take precedence.\nIf we wanted to specifically use the `{stats}` version, we could write this:\n\n\n\n\n::: {.cell .column-body}\n\n```{.r .cell-code}\n# Set the seed for the document so we get the same random numbers sampled\n# each time we run the script (assuming it's run in its entirety from start\n# to finish)\nset.seed(1234)\n\n# Create a cosine wave with random noise\nraw_timeseries <- cos(pi * seq(-2, 2, length.out = 1000)) + rnorm(1000, sd = 0.5)\n\n# Calculate 20 day moving average using stats::filter()\nsmooth_timeseries <- stats::filter(raw_timeseries, filter = rep(1/20, 20), sides = 1)\n\n# Plot raw data\nplot(raw_timeseries, col = \"grey80\")\n\n# Overlay smoothed data\nlines(smooth_timeseries, col = \"red\", lwd = 2)\n```\n\n::: {.cell-output-display}\n![](just-enough-r_files/figure-html/unnamed-chunk-25-1.png){width=100%}\n:::\n:::\n\n\n\n\n## Functions\n\nAs we've alluded to, **functions** are core to gaining *functionality* in `R`.\nWe can always hand-write the code to complete a task, but if we have to repeat a task more than once, it can be tiresome to repeat the same code, particularly if it is a particularly complex task that requires many lines of code.\nThis is where **functions** come in: they provide us with a mechanism to wrap up code into something that can be re-used.\nNot only does this reduce the amount of code we need to write, but by minimize code duplication, debugging becomes a lot easier as we only need to remember to make changes and correct one section of our codebase.\nSay, for example, you want to take a vector of numbers and calculate the cumulative sum e.g.; \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_dbl_vec <- 1:10\n\ncumulative_sum <- 0\n\nfor(i in seq_along(my_dbl_vec)) {\n    cumulative_sum <- cumulative_sum + i\n}\n\ncumulative_sum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55\n```\n\n\n:::\n:::\n\n\n\n\nThis is OK if we only do this calculation once, but it's easy to imagine us wanting to repeat this calculation; for example, we might use calculate the cumulative sum of daily cases to get a weekly incidence over every week of a year.\nIn this situation, we would want to create a function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_cumsum <- function(vector) {\n    cumulative_sum <- 0\n\n    for(i in seq_along(my_dbl_vec)) {\n        cumulative_sum <- cumulative_sum + i\n    }\n\n    cumulative_sum\n}\n\nmy_cumsum(my_dbl_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note collapse=true}\nThis is obviously a contrived example because, as with many basic operations in `R`, there is already a function written to perform this calculation that does it in a much more performant and safer manner: `cumsum()`\n:::\n\nFor many of the manipulations we will want to perform, a **function** has already been written by someone else and put into a **package** that we can download, as we've [already seen](#packages).\n\n### Anonymous functions\n\nThere is a special class of functions called anonymous functions that are worth being aware of, as we will use them quite extensively throughout this workshop.\nAs the name might suggest, **anonymous functions** are functions that are not named, and therefore, not saved for re-use.\nYou may, understandably, be wondering why we would want to use them, given we just make the case for functions replacing repeatable blocks of code.\nIn some instances, we want to be able to perform multiple computations that require creating intermediate objects, but because we only need to use them once, we don't save them save to our environment, potentially causing issues with conflicts (e.g., accidentally using an object we didn't mean to, or overwriting existing ones by re-using the same object name).\nThis gets into the broader concept of local vs global scopes, but that is too far beyond the scope of this workshop: see [Hands-On Programming with R](https://rstudio-education.github.io/hopr/environments.html#scoping-rules) and [Advanced R](https://adv-r.hadley.nz/functions.html?q=lexical#lexical-scoping) for more information.\nLet's look at an example to see when we might want to use an anonymous function.\n\nThroughout this workshop, we will make use of the `map_*()` series of functions from the `{purrr}` package.\nWe'll go into more detail about `purr::map()` [shortly](#sec-map-functions), but for now, imagine we have a **vector** of numbers, and we want to add `5` to each value before and multiplying by `10`.\nThe `map_dbl()` function takes a **vector** and a function, and outputs a **double vector**.\nWe could write a function to perform this multiplication, but if we're only going to do this operation once, it seems unnecessary.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map_dbl(\n    .x = my_dbl_vec,\n    .f = function(.x) {\n        add_five_val <- .x + 5\n\n        add_five_val * 10\n    }\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  60  70  80  90 100 110 120 130 140 150\n```\n\n\n:::\n\n```{.r .cell-code}\n# only exists within the function\nadd_five_val\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in eval(expr, envir, enclos): object 'add_five_val' not found\n```\n\n\n:::\n:::\n\n\n\n\nHere, we've specified the anonymous function to take the input `.x` and multiple each value by 10, and we did it without saving the function.\nThis would be equivalent to writing this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_five_multiply_ten <- function(x) {\n    add_five_val <- x + 5\n    add_five_val * 10\n}\n\npurrr::map_dbl(\n    .x = my_dbl_vec,\n    .f = ~add_five_multiply_ten(.x)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  60  70  80  90 100 110 120 130 140 150\n```\n\n\n:::\n\n```{.r .cell-code}\n# only exists within the function\nadd_five_val\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in eval(expr, envir, enclos): object 'add_five_val' not found\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-warning}\nNotice the `~` used: this specifies that we want to pass arguments into our named function.\nWithout it, we will get an error about `.x` not being found.\n:::\n\n::: {.callout-note collapse=true}\nIn this example, because we are doing standard arithmetic, `R` will **vectorize** our function so that it can automatically be applied to each element of the object, so this example was merely to illustrate the point.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_five_multiply_ten(my_dbl_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  60  70  80  90 100 110 120 130 140 150\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n## Tidy data\n\nBefore we look at the common packages and functions we use throughout this workshop, let's take a second to talk about how our data is structured.\nFor much of what we do, it is convenient to work with **dataframes**, and many functions we will use are designed to work with *long* **dataframes**.\nWhat this means is that each *column* represents a variable, and each row is a unique observation.\n\nLet's first look at a **wide dataframe** to see how data may be represented.\nHere, we have one column representing a number for each of the states in the US, and then we have two columns representing some random incidence: one for July and one for August.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwide_df <- data.frame(\n    state_id = 1:52,\n    july_inc = rbinom(52, 1000, 0.4),\n    aug_inc = rbinom(52, 1000, 0.6)\n)\n\nwide_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   state_id july_inc aug_inc\n1         1      399     613\n2         2      409     578\n3         3      381     604\n4         4      381     607\n5         5      387     603\n6         6      372     614\n7         7      403     597\n8         8      407     605\n9         9      388     604\n10       10      422     595\n11       11      343     597\n12       12      377     590\n13       13      406     618\n14       14      421     598\n15       15      407     603\n16       16      400     614\n17       17      387     585\n18       18      407     598\n19       19      387     604\n20       20      405     618\n21       21      378     599\n22       22      390     601\n23       23      399     587\n24       24      398     609\n25       25      398     591\n26       26      401     607\n27       27      387     591\n28       28      410     603\n29       29      396     585\n30       30      375     601\n31       31      398     596\n32       32      406     579\n33       33      405     633\n34       34      422     607\n35       35      395     578\n36       36      391     597\n37       37      384     568\n38       38      426     590\n39       39      390     587\n40       40      399     586\n41       41      373     589\n42       42      441     602\n43       43      365     600\n44       44      397     591\n45       45      417     615\n46       46      374     606\n47       47      398     617\n48       48      390     594\n49       49      404     579\n50       50      403     603\n51       51      414     609\n52       52      417     606\n```\n\n\n:::\n:::\n\n\n\n\nInstead, we reshape this into a **long dataframe** so that there is a column for the state ID, a column for the month, and a column for the incidence (that is associated with *both* the state *and* the month).\nUsing the `{tidyr}` package, we could reshape this **wide dataframe** to be a **long dataframe** (see [this section](#sec-pivot-functions) for more information about the `pivot_*()` functions)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong_df <- tidyr::pivot_longer(\n    wide_df,\n    cols = c(july_inc, aug_inc),\n    names_to = \"month\",\n    values_to = \"incidence\",\n    # Extract only the month using regex\n    names_pattern = \"(.*)_inc\"\n)\n\nlong_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 104 Ã— 3\n   state_id month incidence\n      <int> <chr>     <int>\n 1        1 july        399\n 2        1 aug         613\n 3        2 july        409\n 4        2 aug         578\n 5        3 july        381\n 6        3 aug         604\n 7        4 july        381\n 8        4 aug         607\n 9        5 july        387\n10        5 aug         603\n# â„¹ 94 more rows\n```\n\n\n:::\n:::\n\n\n\n\nYou will notice that our new dataframe contains three columns still, but is longer than previously; two time as long, in fact.\n\n::: {.callout-note collapse=true}\nParticularly keen-eyed reader may also notice that `long_df` is also has class **tibble**, not a **data.frame**.\nA **tibble** effectively is a **data.frame**, but is an object commonly used and output by `{tidyverse}` functions, as it has a few extra safety features over the base **data.frame**.\n:::\n\n\n## Core code used\n\nWe're finally ready to talk about the functions that are used throughout this workshop.\nThe first package to mention is the `{tidyverse}` package, which actually a collection of packages: the core packages can be found [here](https://www.tidyverse.org/packages/).\nThe reason why are using the `{tidyverse}` packages throughout this workshop is that they are relatively easily to learn, compared to base `R` and `{data.table}` (not that they are mutually exclusive), and what most people are familiar with.\nThey also are well designed and powerful, so you should be able to do most things you need using their packages.\n\nYou can find a list of cheatsheets for all of these packages (and more) [here](https://posit.co/resources/cheatsheets/?type=posit-cheatsheets&_page=1/).\n\nLet's load the `{tidyverse}` packages and then go through the key functions used.\nUnless stated explicitly, these packages will be available to you after loading the `{tidyverse}` with the following command.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nâ”€â”€ Attaching core tidyverse packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 2.0.0 â”€â”€\nâœ” dplyr     1.1.4     âœ” readr     2.1.5\nâœ” forcats   1.0.0     âœ” stringr   1.5.1\nâœ” ggplot2   3.5.1     âœ” tibble    3.2.1\nâœ” lubridate 1.9.3     âœ” tidyr     1.3.1\nâœ” purrr     1.0.2     \nâ”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€\nâœ– dplyr::filter() masks stats::filter()\nâœ– dplyr::lag()    masks stats::lag()\nâ„¹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n\n\n\n### `tibble()`\n\nThe **tibble** is a modern reincarnation of the **dataframes** that is slightly safer i.e., is more restricted in what you can do with it, and will throw errrors more frequently, but very rarely for anything other than a bug.\nWe will use the terms interchangeably, as most people will just talk about **dataframes**, as for the most part, they can be treated identically.\nUse the same syntax as the `data.frame()` function to create the **tibble**.\n\n### `dplyr::filter()`\n\nIf we wanted to take a subset of rows of a **dataframe**, we would use the `dplyr::filter()` function.\nHere, we're listing the package it's coming from, as there are some other packages that also export their own version of the `filter()` function.\nHowever, for all the code in this workshop, there aren't any concerns about [**namespace conflicts**](#namespace-conflict), so we won't use it from here on in.\n\nThe `filter()` function is relatively simple to work with: you specify the **dataframe** variable you want to subset by, the filtering criteria, and that's it.\nIf we include multiple arguments, they get treated as *AND* statements (`&`), so all conditions need to be met.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(\n    long_df,\n    month == \"july\",\n    incidence > 410\n    # equivalent to: month == \"july\" & incidence > 410\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 Ã— 3\n  state_id month incidence\n     <int> <chr>     <int>\n1       10 july        422\n2       14 july        421\n3       34 july        422\n4       38 july        426\n5       42 july        441\n6       45 july        417\n7       51 july        414\n8       52 july        417\n```\n\n\n:::\n:::\n\n\n\n\nWe can filter using *OR* statements (`|`), so if either condition returns `TRUE`, then it will be included in the subset.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(\n    long_df,\n    month == \"july\" | incidence > 600\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 78 Ã— 3\n   state_id month incidence\n      <int> <chr>     <int>\n 1        1 july        399\n 2        1 aug         613\n 3        2 july        409\n 4        3 july        381\n 5        3 aug         604\n 6        4 july        381\n 7        4 aug         607\n 8        5 july        387\n 9        5 aug         603\n10        6 july        372\n# â„¹ 68 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n### `select()`\n\nIf, instead, we wanted to subset of columns of a **dataframe**, we would use the `dplyr::select()` function.\n\nLet's say, from our wide incidence data, we only want the state's ID and their August incidence.\nWe can directly select the columns this way.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(\n    wide_df,\n    state_id, aug_inc\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   state_id aug_inc\n1         1     613\n2         2     578\n3         3     604\n4         4     607\n5         5     603\n6         6     614\n7         7     597\n8         8     605\n9         9     604\n10       10     595\n11       11     597\n12       12     590\n13       13     618\n14       14     598\n15       15     603\n16       16     614\n17       17     585\n18       18     598\n19       19     604\n20       20     618\n21       21     599\n22       22     601\n23       23     587\n24       24     609\n25       25     591\n26       26     607\n27       27     591\n28       28     603\n29       29     585\n30       30     601\n31       31     596\n32       32     579\n33       33     633\n34       34     607\n35       35     578\n36       36     597\n37       37     568\n38       38     590\n39       39     587\n40       40     586\n41       41     589\n42       42     602\n43       43     600\n44       44     591\n45       45     615\n46       46     606\n47       47     617\n48       48     594\n49       49     579\n50       50     603\n51       51     609\n52       52     606\n```\n\n\n:::\n:::\n\n\n\n\nBut in this case, it would be more efficient (for us) to tell `R` the columns we *don't* want.\nWe can do that using the `-` sign.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(\n    wide_df,\n    -july_inc\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   state_id aug_inc\n1         1     613\n2         2     578\n3         3     604\n4         4     607\n5         5     603\n6         6     614\n7         7     597\n8         8     605\n9         9     604\n10       10     595\n11       11     597\n12       12     590\n13       13     618\n14       14     598\n15       15     603\n16       16     614\n17       17     585\n18       18     598\n19       19     604\n20       20     618\n21       21     599\n22       22     601\n23       23     587\n24       24     609\n25       25     591\n26       26     607\n27       27     591\n28       28     603\n29       29     585\n30       30     601\n31       31     596\n32       32     579\n33       33     633\n34       34     607\n35       35     578\n36       36     597\n37       37     568\n38       38     590\n39       39     587\n40       40     586\n41       41     589\n42       42     602\n43       43     600\n44       44     591\n45       45     615\n46       46     606\n47       47     617\n48       48     594\n49       49     579\n50       50     603\n51       51     609\n52       52     606\n```\n\n\n:::\n:::\n\n\n\n\nIf there were multiple columns we didn't want, we would pass them in a vector.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(\n    wide_df,\n    -c(july_inc, aug_inc)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   state_id\n1         1\n2         2\n3         3\n4         4\n5         5\n6         6\n7         7\n8         8\n9         9\n10       10\n11       11\n12       12\n13       13\n14       14\n15       15\n16       16\n17       17\n18       18\n19       19\n20       20\n21       21\n22       22\n23       23\n24       24\n25       25\n26       26\n27       27\n28       28\n29       29\n30       30\n31       31\n32       32\n33       33\n34       34\n35       35\n36       36\n37       37\n38       38\n39       39\n40       40\n41       41\n42       42\n43       43\n44       44\n45       45\n46       46\n47       47\n48       48\n49       49\n50       50\n51       51\n52       52\n```\n\n\n:::\n:::\n\n\n\n\nWhen it comes to selecting columns, the `{tidyselect}` package has a few very handy functions for us.\nTo understand when they are most useful, let's first look at the `mutate()` function, and then we'll highlight how to use the different column selection functions available to use through `{tidyselect}`.\n\n### `mutate()`\n\nIf we have a **dataframe** and want to add or edit a column, we use the `mutate()` function.\nUsually the `mutate()` function is used to add a column that is related to the existing data, but it is not necessary.\nBelow are examples of both.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# add September incidence that is based on August incidence\nmutate(\n    wide_df,\n    sep_inc = round(aug_inc * 1.2 + rnorm(52, 0, 10), digits = 0)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   state_id july_inc aug_inc sep_inc\n1         1      399     613     735\n2         2      409     578     692\n3         3      381     604     725\n4         4      381     607     733\n5         5      387     603     733\n6         6      372     614     740\n7         7      403     597     726\n8         8      407     605     737\n9         9      388     604     695\n10       10      422     595     710\n11       11      343     597     722\n12       12      377     590     697\n13       13      406     618     732\n14       14      421     598     720\n15       15      407     603     719\n16       16      400     614     719\n17       17      387     585     711\n18       18      407     598     709\n19       19      387     604     729\n20       20      405     618     746\n21       21      378     599     734\n22       22      390     601     723\n23       23      399     587     711\n24       24      398     609     742\n25       25      398     591     705\n26       26      401     607     712\n27       27      387     591     711\n28       28      410     603     737\n29       29      396     585     688\n30       30      375     601     731\n31       31      398     596     715\n32       32      406     579     696\n33       33      405     633     756\n34       34      422     607     739\n35       35      395     578     708\n36       36      391     597     732\n37       37      384     568     672\n38       38      426     590     716\n39       39      390     587     701\n40       40      399     586     693\n41       41      373     589     711\n42       42      441     602     722\n43       43      365     600     728\n44       44      397     591     727\n45       45      417     615     748\n46       46      374     606     720\n47       47      398     617     742\n48       48      390     594     727\n49       49      404     579     707\n50       50      403     603     708\n51       51      414     609     740\n52       52      417     606     724\n```\n\n\n:::\n\n```{.r .cell-code}\n# add random September incidence\nmutate(\n    wide_df,\n    sep_inc = rbinom(52, 1000, 0.7)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   state_id july_inc aug_inc sep_inc\n1         1      399     613     702\n2         2      409     578     722\n3         3      381     604     711\n4         4      381     607     709\n5         5      387     603     684\n6         6      372     614     682\n7         7      403     597     689\n8         8      407     605     706\n9         9      388     604     688\n10       10      422     595     690\n11       11      343     597     688\n12       12      377     590     674\n13       13      406     618     708\n14       14      421     598     711\n15       15      407     603     718\n16       16      400     614     700\n17       17      387     585     706\n18       18      407     598     680\n19       19      387     604     702\n20       20      405     618     705\n21       21      378     599     701\n22       22      390     601     691\n23       23      399     587     704\n24       24      398     609     689\n25       25      398     591     694\n26       26      401     607     708\n27       27      387     591     703\n28       28      410     603     650\n29       29      396     585     706\n30       30      375     601     713\n31       31      398     596     725\n32       32      406     579     704\n33       33      405     633     690\n34       34      422     607     713\n35       35      395     578     721\n36       36      391     597     716\n37       37      384     568     677\n38       38      426     590     703\n39       39      390     587     708\n40       40      399     586     704\n41       41      373     589     719\n42       42      441     602     697\n43       43      365     600     703\n44       44      397     591     716\n45       45      417     615     721\n46       46      374     606     716\n47       47      398     617     679\n48       48      390     594     706\n49       49      404     579     705\n50       50      403     603     688\n51       51      414     609     717\n52       52      417     606     691\n```\n\n\n:::\n:::\n\n\n\n\nIf we wanted to update a column, we can do that by specifying the column on both sides of the equals sign.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Update the August incidence to add random noise\nmutate(\n    wide_df,\n    aug_inc = aug_inc + round(rnorm(52, 0, 10), digits = 0)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   state_id july_inc aug_inc\n1         1      399     609\n2         2      409     587\n3         3      381     614\n4         4      381     616\n5         5      387     577\n6         6      372     605\n7         7      403     606\n8         8      407     598\n9         9      388     608\n10       10      422     597\n11       11      343     608\n12       12      377     583\n13       13      406     617\n14       14      421     601\n15       15      407     616\n16       16      400     612\n17       17      387     588\n18       18      407     585\n19       19      387     610\n20       20      405     620\n21       21      378     605\n22       22      390     597\n23       23      399     604\n24       24      398     608\n25       25      398     592\n26       26      401     606\n27       27      387     599\n28       28      410     595\n29       29      396     587\n30       30      375     607\n31       31      398     584\n32       32      406     581\n33       33      405     627\n34       34      422     621\n35       35      395     585\n36       36      391     580\n37       37      384     577\n38       38      426     592\n39       39      390     581\n40       40      399     582\n41       41      373     576\n42       42      441     606\n43       43      365     584\n44       44      397     590\n45       45      417     620\n46       46      374     607\n47       47      398     626\n48       48      390     595\n49       49      404     602\n50       50      403     594\n51       51      414     624\n52       52      417     590\n```\n\n\n:::\n:::\n\n\n\n\nOne crucial thing to note is that `mutate()` applies our function/operation to each row simultaneously, so the new column's value only depends on the *row's* original values (or the vector in the case of the second example that didn't use the values from the data).\n\n### `paste0()`\n\nThe `paste0()` function is useful for manipulating objects and coercing them into string, allowing us to do *string interpolation*.\nIt comes installed with base `R`, so there's nothing to install, and because of the way `mutate()` works, apply functions to each row simultaneously, we can modify whole columns at once, depending on the row's original values.\nIt works to *squish* all the values together, without any separators by default.\nIf you wanted spaces between your words, for example, you can use the `paste(..., sep = \" \")` function, which takes the `sep` argument.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchar_df <- mutate(\n    long_df,\n    # Notice that text is in commas, and object values being passed to paste0()\n    # are unquoted.\n    state_id = paste0(\"state_\", state_id)\n)\n\nchar_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 104 Ã— 3\n   state_id month incidence\n   <chr>    <chr>     <int>\n 1 state_1  july        399\n 2 state_1  aug         613\n 3 state_2  july        409\n 4 state_2  aug         578\n 5 state_3  july        381\n 6 state_3  aug         604\n 7 state_4  july        381\n 8 state_4  aug         607\n 9 state_5  july        387\n10 state_5  aug         603\n# â„¹ 94 more rows\n```\n\n\n:::\n:::\n\n\n\n### `glue::glue()` {#sec-glue}\n\n`glue()` is a function that comes installed with `{tidyverse}`, but is not loaded automatically, so you have to reference it explicitly by either using `library(glue)` or the `::` notation shown below.\nIt serves the same purpose as the base `paste0()`, but in a slightly different syntax.\nInstead of using a mix of quotations and unquoted object names, `glue()` requires everything to be in quotation marks, with any value being passed to the *string interpolation* being *enclosed* in `{ }`.\nIt is worth learning `glue()` as it is used throughout the `{tidyverse}` packages, such as in the `pivot_wider()` function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchar_df <- mutate(\n    long_df,\n    state_id = glue::glue(\"state_{state_id}\")\n)\n\nchar_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 104 Ã— 3\n   state_id month incidence\n   <glue>   <chr>     <int>\n 1 state_1  july        399\n 2 state_1  aug         613\n 3 state_2  july        409\n 4 state_2  aug         578\n 5 state_3  july        381\n 6 state_3  aug         604\n 7 state_4  july        381\n 8 state_4  aug         607\n 9 state_5  july        387\n10 state_5  aug         603\n# â„¹ 94 more rows\n```\n\n\n:::\n:::\n\n\n\n\n### `str_replace_all()`\n\nIf we want to replace characters throughout the whole of a string vector, we can do that with the `str_replace_all()` function.\nAnd because **dataframes** are made up of individual **vectors**, we can use this to modify vectors.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(\n    char_df,\n    # pass in the vector (a column, here), the pattern to remove, and the replacement\n    clean_state_id = str_replace_all(state_id, \"state_\", \"\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 104 Ã— 4\n   state_id month incidence clean_state_id\n   <glue>   <chr>     <int> <chr>         \n 1 state_1  july        399 1             \n 2 state_1  aug         613 1             \n 3 state_2  july        409 2             \n 4 state_2  aug         578 2             \n 5 state_3  july        381 3             \n 6 state_3  aug         604 3             \n 7 state_4  july        381 4             \n 8 state_4  aug         607 4             \n 9 state_5  july        387 5             \n10 state_5  aug         603 5             \n# â„¹ 94 more rows\n```\n\n\n:::\n:::\n\n\n\n\n### `across()`\n\nAbove, we were only **mutating** a single column at a time, which is what we often do.\nBut, sometimes we want to apply the exact same transformation to multiple columns.\nFor example, say we wanted to turn our monthly incidence data into the average weekly incidence.\nWe could write out each transformation by hand, but when there are more than two columns, this gets rather tedious and introduces the opportunity for mistakes when copying code (one of our motivations for using functions).\nThe `tidyselect::across()` function allows us to specify the columns we want to apply the transformation, and the function (can be named or anonymous), and that's it.\n\nThere are a couple of points to understand about the code below:\n\n- Note the `.` preceding the `cols`, `fns`, and `x`\n- Each column is passed to the `.x` value in the function argument\n- `~` is required to pass arguments into the function. In this case it is an anonymous function using the [`map_*()` syntax](#sec-map-functions).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(\n    wide_df,\n    across(\n        .cols = c(july_inc, aug_inc),\n        .fns = ~.x * 7 / 30\n    )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   state_id  july_inc  aug_inc\n1         1  93.10000 143.0333\n2         2  95.43333 134.8667\n3         3  88.90000 140.9333\n4         4  88.90000 141.6333\n5         5  90.30000 140.7000\n6         6  86.80000 143.2667\n7         7  94.03333 139.3000\n8         8  94.96667 141.1667\n9         9  90.53333 140.9333\n10       10  98.46667 138.8333\n11       11  80.03333 139.3000\n12       12  87.96667 137.6667\n13       13  94.73333 144.2000\n14       14  98.23333 139.5333\n15       15  94.96667 140.7000\n16       16  93.33333 143.2667\n17       17  90.30000 136.5000\n18       18  94.96667 139.5333\n19       19  90.30000 140.9333\n20       20  94.50000 144.2000\n21       21  88.20000 139.7667\n22       22  91.00000 140.2333\n23       23  93.10000 136.9667\n24       24  92.86667 142.1000\n25       25  92.86667 137.9000\n26       26  93.56667 141.6333\n27       27  90.30000 137.9000\n28       28  95.66667 140.7000\n29       29  92.40000 136.5000\n30       30  87.50000 140.2333\n31       31  92.86667 139.0667\n32       32  94.73333 135.1000\n33       33  94.50000 147.7000\n34       34  98.46667 141.6333\n35       35  92.16667 134.8667\n36       36  91.23333 139.3000\n37       37  89.60000 132.5333\n38       38  99.40000 137.6667\n39       39  91.00000 136.9667\n40       40  93.10000 136.7333\n41       41  87.03333 137.4333\n42       42 102.90000 140.4667\n43       43  85.16667 140.0000\n44       44  92.63333 137.9000\n45       45  97.30000 143.5000\n46       46  87.26667 141.4000\n47       47  92.86667 143.9667\n48       48  91.00000 138.6000\n49       49  94.26667 135.1000\n50       50  94.03333 140.7000\n51       51  96.60000 142.1000\n52       52  97.30000 141.4000\n```\n\n\n:::\n:::\n\n\n\n\n### `everything()`\n\nIf we wanted to select every column in a dataframe, we would use the `everything()` function.\nThis may not seem helpful initially, but there are occasions when it's very useful.\nFor instance, in the previous example we still specified the exact columns we wanted to transform.\nHowever, if there were five times as many, we wouldn't want to do that.\nDo note that if we replaced this with `everything()`, we would also `mutate()` our `state_id` column, which we probably don't want to do, so we could combine it with the `-` selection seen previously.\n\n### `contains()`\n\nAnother very handy function is the `tidyselect::contains()` function.\nThis allows us to specify a string that the column names must *contain* for them to be selected.\nWe could change the above example to look like this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(\n    wide_df,\n    across(\n        .cols = contains(\"_inc\"),\n        .fns = ~.x * 7 / 30\n    )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   state_id  july_inc  aug_inc\n1         1  93.10000 143.0333\n2         2  95.43333 134.8667\n3         3  88.90000 140.9333\n4         4  88.90000 141.6333\n5         5  90.30000 140.7000\n6         6  86.80000 143.2667\n7         7  94.03333 139.3000\n8         8  94.96667 141.1667\n9         9  90.53333 140.9333\n10       10  98.46667 138.8333\n11       11  80.03333 139.3000\n12       12  87.96667 137.6667\n13       13  94.73333 144.2000\n14       14  98.23333 139.5333\n15       15  94.96667 140.7000\n16       16  93.33333 143.2667\n17       17  90.30000 136.5000\n18       18  94.96667 139.5333\n19       19  90.30000 140.9333\n20       20  94.50000 144.2000\n21       21  88.20000 139.7667\n22       22  91.00000 140.2333\n23       23  93.10000 136.9667\n24       24  92.86667 142.1000\n25       25  92.86667 137.9000\n26       26  93.56667 141.6333\n27       27  90.30000 137.9000\n28       28  95.66667 140.7000\n29       29  92.40000 136.5000\n30       30  87.50000 140.2333\n31       31  92.86667 139.0667\n32       32  94.73333 135.1000\n33       33  94.50000 147.7000\n34       34  98.46667 141.6333\n35       35  92.16667 134.8667\n36       36  91.23333 139.3000\n37       37  89.60000 132.5333\n38       38  99.40000 137.6667\n39       39  91.00000 136.9667\n40       40  93.10000 136.7333\n41       41  87.03333 137.4333\n42       42 102.90000 140.4667\n43       43  85.16667 140.0000\n44       44  92.63333 137.9000\n45       45  97.30000 143.5000\n46       46  87.26667 141.4000\n47       47  92.86667 143.9667\n48       48  91.00000 138.6000\n49       49  94.26667 135.1000\n50       50  94.03333 140.7000\n51       51  96.60000 142.1000\n52       52  97.30000 141.4000\n```\n\n\n:::\n:::\n\n\n\n\n### `rename_with()`\n\nIf we wanted to rename columns of a **dataframe**, we can use the `rename()` function.\nHowever, like the previous `{tidyselect}` examples, sometimes we want to apply the same renaming scheme (function) to the columns.\n`rename_with()` allows us to pass a function to multiple columns at once, achieving what we want with minimal effort, and without needing to use `across()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrename_with(\n    wide_df,\n    .cols = contains(\"_inc\"),\n    .fn = ~str_replace_all(.x, \"_inc\", \"_incidence\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   state_id july_incidence aug_incidence\n1         1            399           613\n2         2            409           578\n3         3            381           604\n4         4            381           607\n5         5            387           603\n6         6            372           614\n7         7            403           597\n8         8            407           605\n9         9            388           604\n10       10            422           595\n11       11            343           597\n12       12            377           590\n13       13            406           618\n14       14            421           598\n15       15            407           603\n16       16            400           614\n17       17            387           585\n18       18            407           598\n19       19            387           604\n20       20            405           618\n21       21            378           599\n22       22            390           601\n23       23            399           587\n24       24            398           609\n25       25            398           591\n26       26            401           607\n27       27            387           591\n28       28            410           603\n29       29            396           585\n30       30            375           601\n31       31            398           596\n32       32            406           579\n33       33            405           633\n34       34            422           607\n35       35            395           578\n36       36            391           597\n37       37            384           568\n38       38            426           590\n39       39            390           587\n40       40            399           586\n41       41            373           589\n42       42            441           602\n43       43            365           600\n44       44            397           591\n45       45            417           615\n46       46            374           606\n47       47            398           617\n48       48            390           594\n49       49            404           579\n50       50            403           603\n51       51            414           609\n52       52            417           606\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-important}\nHopefully you are noticing a pattern between the `{tidyselect}`-type functions.\nWhen you need to apply a function to multiple columns in a **dataframe**, you will select the columns with the `.cols` argument, and pass the function to the `.fn(s)` argument with the `~` symbol indicating you are using the `.x` to represent the column in the function (yes, there is a touch of ambiguity between `.fns` and `.fn`, but the general pattern holds).\nThis will be useful when we look at the `map_*()` family of functions.\n:::\n\n### `magrittr::%>%`\nThe `%>%` operator is an interesting and very useful function that comes installed (and loaded) with the `{tidyverse}` package (technically from the `{magrittr}` package from within the `{tidyverse}`).\nIt allows us to chain together operations without needing to create intermediate objects.\nSay for example we have our wide incidence data and want to add data for September before turning it into a **long dataframe**, we could create and intermediate object before using the `pivot_longer()` function from before, but we might not want to create another object that we don't really care about.\nThis is when we would want to use a pipe, as it takes the output of one operation and *pipes* it into the next one.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(\n    wide_df,\n    sep_inc = round(aug_inc * 1.2 + rnorm(52, 0, 10), digits = 0)\n    ) %>%\n    pivot_longer(\n        cols = c(july_inc, aug_inc, sep_inc),\n        names_to = \"month\",\n        values_to = \"incidence\",\n        names_pattern = \"(.*)_inc\",\n        data = .\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 156 Ã— 3\n   state_id month incidence\n      <int> <chr>     <dbl>\n 1        1 july        399\n 2        1 aug         613\n 3        1 sep         725\n 4        2 july        409\n 5        2 aug         578\n 6        2 sep         685\n 7        3 july        381\n 8        3 aug         604\n 9        3 sep         710\n10        4 july        381\n# â„¹ 146 more rows\n```\n\n\n:::\n:::\n\n\n\n\nBy default, the previous object gets input into the first argument of the next function, but here we've shown that you can manipulate the position the object is *piped* into by specify the argument using the `.` syntax.\n\n### `|>`\n\nIn `R` version 4.1.0, the `|>` was added as the base pipe operator.\nIt works slightly differently to `%>%`, and frankly, is less powerful and less common (at the moment), so we won't use it in this workshop.\n\n### `group_by()`\n\nIf we have groups in our **dataframe** and want to apply some function to each group's data, we can use the `group_by()` function.\nFor example, if we wanted to calculate the mean and median incidence in our fake data from earlier, but group it by the month.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup_by(long_df, month) %>%\n    summarize(mean = mean(incidence), median = median(incidence))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 Ã— 3\n  month  mean median\n  <chr> <dbl>  <dbl>\n1 aug    599.   600.\n2 july   397.   398 \n```\n\n\n:::\n:::\n\n\n\n\n### `pivot_*()` {#sec-pivot-functions}\n\nWe've [already seen](#tidy-data) the purpose of the `pivot_longer()` function: taking wide data and reshaping it to be long.\nThere is an equivalent to go from long to wide: `pivot_wider()`.\nOccassionally this is useful (though it is less common than creating long data).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npivot_wider(\n    long_df,\n    names_from = month,\n    values_from = incidence,\n    names_glue = \"{month}_inc\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 52 Ã— 3\n   state_id july_inc aug_inc\n      <int>    <int>   <int>\n 1        1      399     613\n 2        2      409     578\n 3        3      381     604\n 4        4      381     607\n 5        5      387     603\n 6        6      372     614\n 7        7      403     597\n 8        8      407     605\n 9        9      388     604\n10       10      422     595\n# â„¹ 42 more rows\n```\n\n\n:::\n:::\n\n\n\n\nHere, the `names_glue` argument is making use of the `glue::glue()` function ([see above](#sec-glue)) that is installed with `{tidyverse}`, but not loaded automatically for use by the users.\n\n### `map_*()` {#sec-map-functions}\n\nThe `map_*()` functions come from the `{purrr}` package (a core part of the `{tidyverse}`), and are incredibly useful.\nThey are relatively complicated, so there isn't enough space to go into full detail, but here we'll just outline enough so you can read more and understand what's going on.\n\nWe've [already seen](#anonymous-functions) we can apply functions to each element of a vector (**atomic** or **list** vectors).\nThe key points to note are the `.` preceding the `x` and `f` arguments.\nIf we use `map()` we get a **list** returned, `map_dbl()` a **double vector**, `map_char()` a **character vector**, `map_dfr()` a **dataframe** etc.\n\nIn the example below, we'll walk through `map_dfr()` as it's one of the more confusing variants due to the **return** requirements.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dfr_example <- map_dfr(\n    .x = my_dbl_vec,\n    .f = function(.x) {\n        # Note we don't use , at the end of each line - it's as if we were\n        # running the code in the console\n        times_ten <- .x * 10\n        divide_ten <- .x / 10\n\n        # construct a tibble as normal (requires , between arguments)\n        tibble(\n            original_val = .x,\n            times_ten = times_ten,\n            divide_ten = divide_ten\n        )\n    }\n)\n\nmap_dfr_example\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 Ã— 3\n   original_val times_ten divide_ten\n          <int>     <dbl>      <dbl>\n 1            1        10        0.1\n 2            2        20        0.2\n 3            3        30        0.3\n 4            4        40        0.4\n 5            5        50        0.5\n 6            6        60        0.6\n 7            7        70        0.7\n 8            8        80        0.8\n 9            9        90        0.9\n10           10       100        1  \n```\n\n\n:::\n:::\n\n\n\n\nWhat's happening under the hood is that `map_dfr()` is applying the [anonymous function](#anonymous-functions) we defined to each element in our vector and returning a **list** of **dataframes** that contains one row and three columns, i.e. for the first element, we would get this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(map_dfr_example[1, ])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n# A tibble: 1 Ã— 3\n  original_val times_ten divide_ten\n         <int>     <dbl>      <dbl>\n1            1        10        0.1\n```\n\n\n:::\n:::\n\n\n\n\nIt then calls the `bind_rows()` function to *squash* all of those **dataframes** together, one row stacked on top of the next, to create one large **dataframe**.\nWe could write the equivalent code like this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbind_rows(\n    map(\n    .x = my_dbl_vec,\n    .f = function(.x) {\n        # Note we don't use , at the end of each line - it's as if we were\n        # running the code in the console\n        times_ten <- .x * 10\n        divide_ten <- .x / 10\n\n        # construct a tibble as normal (requires , between arguments)\n        tibble(\n            original_val = .x,\n            times_ten = times_ten,\n            divide_ten = divide_ten\n        )\n    }\n)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 Ã— 3\n   original_val times_ten divide_ten\n          <int>     <dbl>      <dbl>\n 1            1        10        0.1\n 2            2        20        0.2\n 3            3        30        0.3\n 4            4        40        0.4\n 5            5        50        0.5\n 6            6        60        0.6\n 7            7        70        0.7\n 8            8        80        0.8\n 9            9        90        0.9\n10           10       100        1  \n```\n\n\n:::\n:::\n\n\n\n\n`map_dfc()` does exactly the same thing, but calls `bind_cols()` instead, to place the columns next to each other.\n\nThere is one more important variant to go through: `pmap_*()`.\nIf `map_*()` takes one vector as an argument, `pmap_*()` takes a **list** of arguments.\nWhat this means is that we can iterate through the elements of as many arguments as we'd like, *in sequence*.\nFor example, let's multiply the elements of two **double** vectors together.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a second vector of numbers\nmy_second_dbl_vec <- rnorm(length(my_dbl_vec), 20, 20)\nmy_second_dbl_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 45.583594  7.463083 20.505265 46.030180 15.004206 22.699967 17.066535\n [8] 44.678612 22.708520 21.344806\n```\n\n\n:::\n\n```{.r .cell-code}\n# Remind ourselves what our original vector looks like\nmy_dbl_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\npmap_dbl(\n    .l = list(first_num = my_dbl_vec, sec_num = my_second_dbl_vec),\n    .f = function(first_num, sec_num) {\n        first_num * sec_num\n    }\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  45.58359  14.92617  61.51580 184.12072  75.02103 136.19980 119.46575\n [8] 357.42890 204.37668 213.44806\n```\n\n\n:::\n:::\n\n\n\n\nThere are a couple of important points to note here:\n\n- All vectors need to be the same length\n- The function is applied to each element index of the input vectors, i.e., the first elements of the vectors are multiplied together, the second element of the vectors are multiplied together, and so on, until the last elements are reached.\n- We use `.l` instead of `.x` to denote we are passing a `list()` of vectors.\n- Our function specifies the names of the vectors in the `list()`, which are then used within the function itself (similar to how we used `.x` in our `map_*()` functions)\n\n::: {.callout-note collapse=true}\nAs before, this is an unnecessary approach as `R` would vectorize the operation, but it is useful to demonstrate the principle.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_dbl_vec * my_second_dbl_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  45.58359  14.92617  61.51580 184.12072  75.02103 136.19980 119.46575\n [8] 357.42890 204.37668 213.44806\n```\n\n\n:::\n:::\n\n\n\n:::\n\n### `nest()`\n\nNesting is a relatively complex, but powerful, concept, particularly when combined with the `map_*()` functions.\nCommonly, as in this workshop, it is used to apply a model function to multiple different datasets, and store them all in one **dataframe** for easy of manipulation.\nWhat it effectively does is group your existing **dataframe** by a variable, and then shrink all the columns (except the grouping column), into a single list column, leaving you with as many rows as there are distinct groups.\nEach element of the new list column is itself a small **dataframe** that contains all the original variables and data, but only those that are relevant for the group.\nHopefully this example will make it clearer.\nHere, we'll take the `mtcars` dataset, and like before, we'll group by the `cyl` variable, but this time we'll nest the rest of the data.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnested_mtcars <- nest(mtcars, data = -cyl)\nnested_mtcars\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 2\n    cyl data              \n  <dbl> <list>            \n1     6 <tibble [7 Ã— 10]> \n2     4 <tibble [11 Ã— 10]>\n3     8 <tibble [14 Ã— 10]>\n```\n\n\n:::\n:::\n\n\n\n\nWe can see we've nested all columns, *except* cyl.\nLooking at the `data` column for just the first row (`cyl == 6`), we see we have a list with one item: the rest of the data that's relevant to the rows where `cyl == 6` (notice the `[[1]]` above the **tibble**).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnested_mtcars[1, ]$data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n# A tibble: 7 Ã— 10\n    mpg  disp    hp  drat    wt  qsec    vs    am  gear  carb\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1  21    160    110  3.9   2.62  16.5     0     1     4     4\n2  21    160    110  3.9   2.88  17.0     0     1     4     4\n3  21.4  258    110  3.08  3.22  19.4     1     0     3     1\n4  18.1  225    105  2.76  3.46  20.2     1     0     3     1\n5  19.2  168.   123  3.92  3.44  18.3     1     0     4     4\n6  17.8  168.   123  3.92  3.44  18.9     1     0     4     4\n7  19.7  145    175  3.62  2.77  15.5     0     1     5     6\n```\n\n\n:::\n:::\n\n\n\n\nNow we can use `map` to fit a model to this subsetted data.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(\n    nested_mtcars,\n    model_fit = map(data, ~glm(mpg ~ hp + wt + ordered(carb), data = .x))\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 3\n    cyl data               model_fit\n  <dbl> <list>             <list>   \n1     6 <tibble [7 Ã— 10]>  <glm>    \n2     4 <tibble [11 Ã— 10]> <glm>    \n3     8 <tibble [14 Ã— 10]> <glm>    \n```\n\n\n:::\n:::\n\n\n\n\nThis creates a **list** column (because we used the `map()` function, which returns a list) that contains the relevant model fits.\n\n::: {.callout-important}\nIt is important to note that there is also a function called `nest_by()`.\nHowever, it  returns a `rowwise` **tibble**, i.e., any later manipulations will be applied on a row-by-row basis, unlike a standard **tibble** that applies the manipulation to every row all at once, so we would need to use normal `mutate()` syntax (and explicitly return a list column) to get the same effect as before.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnest_by(mtcars, .by = cyl) %>%\n    mutate(model_fit = list(glm(mpg ~ hp + wt + ordered(carb), data = data)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 3\n# Rowwise:  .by\n    .by                data model_fit\n  <dbl> <list<tibble[,11]>> <list>   \n1     4           [11 Ã— 11] <glm>    \n2     6            [7 Ã— 11] <glm>    \n3     8           [14 Ã— 11] <glm>    \n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n### `ggplot()`\n\nTo create out plots, we can use the base `plot()` functions, but `{ggplot2}` package provides a clean and consistent interface to plotting that has many benefits.\nIn essence, plots are built up in layers, with each stacking on top of the previous.\n\nTo initialize a plot, we simply use the `ggplot()` function call, that creates the background of a figure.\nNow we need to add data, and **geoms** to interpret that data.\n\nLet's use the `mtcars` dataset again.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n```\n\n\n:::\n:::\n\n\n\n\nLooking at the data, we might be interested in how the `mpg` of a car is affected by it horsepower (`hp`).\nTo add data, we just use the `ggplot()` function argument `data = mtcars`.\nWe also need to tell `ggplot()` how to map the data points to the figure, i.e., the values for the `x` and `y` axes.\n\n**Because this depends on the underlying data, this must go within an argument called `aes()` i.e., `aes(x = hp, y = mpg)`**.\n\nTo add a layer to show the data, we add a **geom**.\nIn this case, because we have continuous independent and dependent variables, we could use the `geom_point()` **geom**, that will give us a scatter plot.\nMuch like basic arithmetic, we *add* layers using the `+` operator.\n\n\n\n\n::: {.cell .column-body}\n\n```{.r .cell-code}\nggplot(data = mtcars, aes(x = hp, y = mpg)) +\n    geom_point()\n```\n\n::: {.cell-output-display}\n![](just-enough-r_files/figure-html/unnamed-chunk-60-1.png){width=100%}\n:::\n:::\n\n\n\n\nNow let's imagine we wanted to explore this relationship, but separated by engine type (the `vs` column).\nWe can use color to separate these points.\nBecause this is an argument that depends on the underlying data, again, this must be placed *within* `aes()`.\n\n\n\n\n::: {.cell .column-body}\n\n```{.r .cell-code}\nggplot(data = mtcars, aes(x = hp, y = mpg, color = vs)) +\n    geom_point()\n```\n\n::: {.cell-output-display}\n![](just-enough-r_files/figure-html/unnamed-chunk-61-1.png){width=100%}\n:::\n:::\n\n\n\n\nWhat you'll notice here is that despite `vs` being a binary choice, because it is of type **double**, `ggplot()` interprets this as a number, so provides a continuous color scale.\nTo correct this, let's convert `vs` into a factor before plotting.\n\n\n\n\n::: {.cell .column-body}\n\n```{.r .cell-code}\nmtcars %>%\n    mutate(vs = factor(vs)) %>%\n    ggplot(aes(x = hp, y = mpg, color = vs)) +\n    geom_point()\n```\n\n::: {.cell-output-display}\n![](just-enough-r_files/figure-html/unnamed-chunk-62-1.png){width=100%}\n:::\n:::\n\n\n\n\nWe can change the theme by layering in more information, as we did with the other plotting layers.\nHere, let's change the background to white, and add some different colors.\nWe'll also change the size of the points.\n\n\n\n\n::: {.cell .column-body}\n\n```{.r .cell-code}\nmtcars %>%\n    mutate(vs = factor(vs)) %>%\n    ggplot(aes(x = hp, y = mpg, color = vs)) +\n    geom_point(size = 5) +\n    theme_minimal() +\n    # We don't need to specify the relationship between the levels and the colors\n    # and labels, but it means we're less likely to make a mistake in interpretation\n    # and labelling\n    scale_color_manual(\n        values = c(\"0\" = \"#6b3df5ff\", \"1\" = \"#f5c13cff\"),\n        labels = c(\"0\" = \"V-Shaped\", \"1\" = \"Straight\")\n    )\n```\n\n::: {.cell-output-display}\n![](just-enough-r_files/figure-html/unnamed-chunk-63-1.png){width=100%}\n:::\n:::\n\n\n\n\nImagine we wanted to use one more grouping: automatic vs manual transmission (`am`).\nRather than adding yet another color, we could do something called a `facet_wrap()`, which creates separate panels for each group.\nAdding this to a `ggplot()` is very easy - it's just another `+` operation!\nAs before, we will add labels for easier interpretation.\n\n\n\n\n::: {.cell .column-body}\n\n```{.r .cell-code}\nmtcars %>%\n    mutate(vs = factor(vs)) %>%\n    ggplot(aes(x = hp, y = mpg, color = vs)) +\n    geom_point(size = 5) +\n    theme_minimal() +\n    # We don't need to specify the relationship between the levels and the colors\n    # and labels, but it means we're less likely to make a mistake in interpretation\n    # and labelling\n    scale_color_manual(\n        values = c(\"0\" = \"#6b3df5ff\", \"1\" = \"#f5c13cff\"),\n        labels = c(\"0\" = \"V-Shaped\", \"1\" = \"Straight\")\n    ) +\n    facet_wrap(~am, labeller = as_labeller(c(\"0\" = \"Automatic\", \"1\" = \"Manual\")))\n```\n\n::: {.cell-output-display}\n![](just-enough-r_files/figure-html/unnamed-chunk-64-1.png){width=100%}\n:::\n:::\n\n\n\n\nThis is looking much better, but we might want to add a line to show the trends within the groups.\nAgain, this is as simple as adding another layer.\nOne thing to note about the plot below, because we specified the `data` and `aes()` arguments in the original `ggplot()` function call, those data relationships will also be applied to our new **geom**.\nWe could just as easily write them within the `geom_*()` explicitly, but then we would have to do that for each `geom_*()` in our plot, which is unnecessary when they all have the same data relationships.\nTo demonstrate this, let's also make a small modification so that only the points are colored, and the lines are all red.\nTo do that, we will remove `color = vs` from the global `aes()`, and add it to one specific to `geom_point()`.\nBut because we still want to fit a linear model to the different engine types (`vs`) separately, we will add `group = vs` to the `geom_smooth(aes(), ...)` call, to let `ggplot()` know to treat them as separate groups for the `geom_smooth()`\nBecause the line color doesn't depend on the data, it is not in an `aes()` argument call.\n\n\n\n\n::: {.cell .column-body}\n\n```{.r .cell-code}\nmtcars %>%\n    mutate(vs = factor(vs)) %>%\n    ggplot(aes(x = hp, y = mpg)) +\n    geom_point(aes(color = vs), size = 5) +\n    geom_smooth(aes(group = vs), color = \"red\", method = \"lm\") +\n    theme_minimal() +\n    # We don't need to specify the relationship between the levels and the colors\n    # and labels, but it means we're less likely to make a mistake in interpretation\n    # and labelling\n    scale_color_manual(\n        values = c(\"0\" = \"#6b3df5ff\", \"1\" = \"#f5c13cff\"),\n        labels = c(\"0\" = \"V-Shaped\", \"1\" = \"Straight\")\n    ) +\n    facet_wrap(~am, labeller = as_labeller(c(\"0\" = \"Automatic\", \"1\" = \"Manual\")))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](just-enough-r_files/figure-html/unnamed-chunk-65-1.png){width=100%}\n:::\n:::\n\n\n\n\nAs you can see, once you get used to it, the layering system makes it relatively intuitive to build complex and interesting plots.\nWe've only stratched the surface here, so be sure to read the [suggested books](#suggested-reading) and the [`{ggplot2}` cheatsheet](https://posit.co/wp-content/uploads/2022/10/data-visualization-1.pdf) for more information.\n\n### `%*%`\n\nThis is the matrix multiplication operator.\nIt works exactly as you'd expect given matrix multiplication rules.\nAs such, you can use it on any combination of vectors and matrices.\n\n::: {.callout-important}\nAs you can see below, `R` treats vectors as dimensionless, and will try to convert it to *either* a row *or* column vector, depending on what makes sense for the matrix multiplication\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_dbl_vec %*% my_second_dbl_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         [,1]\n[1,] 1412.086\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix <- matrix(1:60, nrow = 10)\nmy_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1] [,2] [,3] [,4] [,5] [,6]\n [1,]    1   11   21   31   41   51\n [2,]    2   12   22   32   42   52\n [3,]    3   13   23   33   43   53\n [4,]    4   14   24   34   44   54\n [5,]    5   15   25   35   45   55\n [6,]    6   16   26   36   46   56\n [7,]    7   17   27   37   47   57\n [8,]    8   18   28   38   48   58\n [9,]    9   19   29   39   49   59\n[10,]   10   20   30   40   50   60\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_dbl_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_dbl_vec %*% my_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]  385  935 1485 2035 2585 3135\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_matrix %*% my_dbl_vec\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in my_matrix %*% my_dbl_vec: non-conformable arguments\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_matrix %*% t(my_dbl_vec)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in my_matrix %*% t(my_dbl_vec): non-conformable arguments\n```\n\n\n:::\n\n```{.r .cell-code}\nt(my_matrix) %*% my_dbl_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]  385\n[2,]  935\n[3,] 1485\n[4,] 2035\n[5,] 2585\n[6,] 3135\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}