{
  "hash": "df39c4d65bb0526b8d7500af2ba301aa",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute:\n    echo: false\neditor: \n  markdown: \n    wrap: sentence\n---\n\n\n\n\n\n# R Session 01\n\n## Interactive Plot {#sec-interactive-plots}\n\n\n\n\n\n```{ojs}\ninit_beta = 0.3\ninit_dur_inf = 6.0\ninit_I0 = 0.01\ninit_births = 0.0\ninit_tmax = 200\n```\n\n```{ojs}\nfunction set(input, value) {\n  input.value = value;\n  input.dispatchEvent(new Event(\"input\", {bubbles: true}));\n}\n```\n\n```{ojs}\n//| panel: sidebar\nviewof reset = Inputs.button([\n  [\"Reset all sliders\", () => {\n    set(viewof beta, init_beta)\n    set(viewof dur_inf, init_dur_inf)\n    set(viewof I0, init_I0)\n    set(viewof births, init_births)\n    set(viewof tmax, init_tmax)\n  }]\n])\n\nviewof beta = Inputs.range(\n  [0.0, 2.0],\n  {value: init_beta, step: 0.01, label: \"Transmission rate (per day)\"}\n)\n\nviewof dur_inf = Inputs.range(\n  [0.0, 20],\n  {value: init_dur_inf, step: 0.5, label: \"Duration of Infection (days)\"}\n)\n\nviewof I0 = Inputs.range(\n  [0.0, 1.0],\n  {value: init_I0, step: 0.01, label: \"Initial fraction infected\"}\n)\n\nviewof births = Inputs.range(\n  [0, 0.05],\n  {value: init_births, step: 0.001, label: \"Birth rate\"}\n)\n\nviewof tmax = Inputs.range(\n  [200, 600],\n  {value: init_tmax, step: 10.0, label: \"Maximum simulation time (years)\"}\n)\n\nviewof area = Inputs.toggle(\n  {label: \"Cumulative Area plot\", value: false}\n)\n\nmd`${tex`R_0 = ${R0_str}`}`\n\n{\n  if (births == 0){\n    var finalsize = sir_sol.get(\"R\", sir_sol.numRows()-1)\n    var finalsize_str = finalsize.toLocaleString(undefined, {minimumFractionDigits: 2})\n\n    return md`${tex`\\text{Final size} = ${finalsize_str}`}`\n  } else {\n    return md``\n  }\n}\n```\n\n```{ojs}\ngamma = 1 / dur_inf\ndt = 0.01\n```\n\n```{ojs}\nimport {odeRK4} from '@rreusser/integration@3064'\nimport { aq, op } from '@uwdata/arquero'\n```\n\n```{ojs}\nfunction sir(dydt, y, t) {\n  dydt[0] = - beta * y[0] * y[1] + births * (1 - y[0])\n  dydt[1] = beta * y[0] * y[1] - gamma * y[1] - births * y[1]\n  dydt[2] = gamma * y[1] - births * y[2]\n}\n```\n\n```{ojs}\nfunction simulate(f, t0, y0, dt, tmax) {\n  var t = t0\n  var y = y0\n  var i = 0\n\n  var tsim = [t0]\n  var ysim = [y0]\n\n  for (t = t0 + dt; t <= tmax; t += dt) {\n    ysim.push(odeRK4([], ysim[i], f, dt))\n    tsim.push(t)\n    i += 1\n  }\n  \n  return aq.table({\n    Time: tsim,\n    S: ysim.map(d => d[0]),\n    I: ysim.map(d => d[1]),\n    R: ysim.map(d => d[2])\n    })\n}\n```\n\n```{ojs}\nsir_sol = simulate(sir, 0, [1.0-I0, I0, 0.0], dt, tmax)\nsir_sol_long = sir_sol.fold(aq.not('Time'), {as: ['State', 'Fraction']})\n```\n\n```{ojs}\nSIRcolors = [\"#1f77b4\", \"#ff7f0e\", \"#FF3851\"]\n```\n\n```{ojs}\nR0 = beta / (gamma + births)\nR0_str = R0.toLocaleString(undefined, {minimumFractionDigits: 2})\n```\n\n```{ojs}\nfunction calculate_equil(R0){\n  if (births > 0) {\n    var eq_S = 1 / R0\n    var eq_I = births / beta * (R0 - 1)\n    var eq_R = 1 - (eq_S + eq_I)\n\n    const eq_vals = aq.table({\n      State: [\"S\", \"I\", \"R\"],\n      Fraction: [eq_S, eq_I, eq_R]\n    })\n\n    return eq_vals\n  } else {\n    return null\n  }\n}\n```\n\n```{ojs}\neq_vals = calculate_equil(R0)\n```\n\n```{ojs}\n//| panel: fill\nPlot.plot({\n  color: {\n    legend: true,\n    domain: [\"S\", \"I\", \"R\"],\n    range: SIRcolors\n  },\n  style: {fontSize: \"20px\"},\n  marginLeft: 65,\n  marginTop: 40,\n  marginBottom: 55,\n  grid: true,\n  width: 800,\n  height: 670,\n  y: {domain: [0, 1]},\n  marks: [\n    area ?\n      Plot.areaY(sir_sol_long, {x: \"Time\", y: \"Fraction\", fill: \"State\"}) :\n      [\n        R0 >= 1.0 && births > 0 ?\n        Plot.ruleY(\n          eq_vals,\n          {y: \"Fraction\", stroke: \"State\", strokeWidth: 2, strokeDasharray: [10]}\n        ) :\n        null,\n        Plot.lineY(\n          sir_sol_long,\n          {x: \"Time\", y: \"Fraction\", stroke: \"State\", strokeWidth: 6}\n        )\n      ]\n  ]\n})\n```\n\n\n\n\n\n## Closed Population Model Intuition\n\nWe'll first get develop an intuition for the closed population model.\nWe'll then extend this intuition to the open population model.\nWhen the `Birth rate` slider in the side panel of the interactive figure is set to 0, we have no births or deaths, so their is no replenishment of the susceptible population i.e., it is a closed population.\n\n::: {.callout-note title=\"SET\"}\nTransmission rate = 1\n\nDuration of infection = 4.\n:::\n\n### What is $R_0$? {#sec-whatisr0}\n\n### What is epidemic final size?\n\n### Does this make sense given our definition of $R_0$?\n\n::: {.callout-note title=\"Instruction\" appearance=\"minimal\"}\nToggle on the cumulative area button and see what the epidemic final size is (approximately)\n:::\n\n### At approximately what time does the epidemic end?\n\n::: {.callout-note title=\"SET\"}\nDuration of infection = 8 days\n\nTransmission rate so you get the same $R_0$ in @sec-whatisr0\n:::\n\n### How does the epidemic final size compare?\n\n### At what time (approx) does the epidemic end?\n\n::: callout-note\nSize is determined by $R_0$, duration is determined by recovery rate $\\left(\\gamma = \\frac{1}{\\text{duration of infection}}\\right)$\n:::\n\nNow, imagine that we have a drug (or vaccine) available to everyone that either reduced transmission OR shortened the duration of infection.\n\n::: {.callout-note title=\"SET\"}\nTransmission rate = 1\n\nDuration of infection = 8 days\n:::\n\n### Note the epidemic final size and the time until the epidemic is over.\n\nNow, imagine everyone has access to the drug (unrealistic) that reduces transmission by $P \\%$\n\n### What happens to the final size and outbreak duration?\n\nNow, imagine everyone has access to a drug that reduces the duration of infection from 8 to 2 days (75% reduction).\n\n### What happens to the final size and outbreak duration?\n\n### Which assumption would you prefer and why?\n\n::: callout-note\nThis is the only really open ended question, but should be pretty straightforward discussion\n:::\n\n## Demographic Model Intuition\n\n::: {.callout-note title=\"SET\"}\nTransmission = 1\n\nDuration = 8\n\nBirth rate = .002\n:::\n\n### What is $R_0$? {#sec-demog-whatisr0}\n\n### What is the equilibrium proportion that is susceptible?\n\n### If you were to test for antibodies against infection in the population, what proportion would you expect to be positive?\n\n::: callout-note\nAssume a perfectly accurate serological test\n:::\n\n### At what time (approximately) does the system reach equilibrium?\n\n::: {.callout-note title=\"SET\"}\nBirth rate = 0.005\n:::\n\n### What is the new $R_0$? {#sec-demog-updatedr0}\n\n### At what time (approximately) does the system reach equilibrium?\n\n::: {.callout-note title=\"SET\"}\nTransmission rate so you get the same $R_0$ in @sec-demog-whatisr0\n:::\n\n### What is the new equilibrium proportion that is susceptible?\n\n### What is different about the prevalence of infection (equilibrium proportion that is infected) in the scenarios @sec-demog-whatisr0 and @sec-demog-updatedr0 i.e. higher birth rate with the same $R_0$?\n\n## Model Building With R\n\n### Setting Up A Script\n\nNow we have some intuition behind how the different parameters affect the dynamics of the SIR system, let's look at how we can implement this in R.\nBelow is some R code that implements the basic closed-population SIR model.\nThe purpose of the questions in this exercise is to guide you through the code and help you understand how it works so you can modify it to answer your own questions.\n\n<a id=\"quarto-tips\"></a>\n\n::: {.callout-note title=\"Instruction\" appearance=\"minimal\"}\nCopy the code below into a new R script.\nYou can open a new script in RStudio using ctrl+shift+N (Windows) or cmd+shift+N (macOS).\nSave it with the name `S01_basic-sir.R`.\nThis script should live in your SISMID directory, as described [previously](project-management.qmd).\nRun it to check you get the same figure output as above.\n:::\n\n\n\n\n\n::: {.cell .column-body}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(deSolve)\n\ntheme_set(theme_minimal())\n\nsir_model <- function(time, state, params, ... ){\n  transmission <- params[\"transmission\"]\n  recovery <- 1 / params[\"duration\"]\n\n  S <- state[\"S\"]\n  I <- state[\"I\"]\n  R <- state[\"R\"]\n\n  dSdt <- -transmission * S * I\n  dIdt <- (transmission * S * I) - (recovery * I)\n  dRdt <- recovery * I\n\n  return(list(c(dSdt, dIdt, dRdt)))\n}\n\nsir_params <- c(transmission = 0.3, duration = 6)\nsir_init_states <- c(S = 0.99, I = 0.01, R = 0)\nsim_times <- seq(0, 200, by = 0.1)\n\nsir_sol <- deSolve::ode(\n  y = sir_init_states,\n  times = sim_times,\n  func = sir_model,\n  parms = sir_params\n)\n\n# Turn the output from the ODE solver into a tibble (dataframe)\n# so we can manipulate and plot it easily\nsir_sol_df <- as_tibble(sir_sol) %>%\n  # Convert all columns to numeric (they are currently type\n  # deSolve so will produce warnings when plotting etc)\n  mutate(\n    # Rather than repeatedly type the same function for every\n    # column, use the across() function to apply the function\n    # to a selection of columns\n    across(\n      # The cols argument takes a selection of columns to apply\n      # a function to. Here, we want to apply the as.numeric()\n      # function to all columns, so we use the function\n      # everything() to select all columns.\n      .cols = everything(),\n      .fns = as.numeric\n    )\n  ) %>%\n  # Convert the dataframe from wide to long format, so we have a\n  # column for the time, a column for the state, and a column\n  # for the proportion of the population in that state at that\n  # time\n  pivot_longer(\n    # Don't pivot the time column\n    cols = -time,\n    names_to = \"state\",\n    values_to = \"proportion\"\n  ) %>%\n  # Update the state column to be a factor, so the plot will\n  # show the states in the correct order\n  mutate(state = factor(state, levels = c(\"S\", \"I\", \"R\")))\n\nSIRcolors <- c(S = \"#1f77b4\", I = \"#ff7f0e\", R = \"#FF3851\")\n\nggplot(sir_sol_df, aes(x = time, y = proportion, color = state)) +\n  geom_line(linewidth = 1.5) +\n  scale_color_manual(values = SIRcolors) +\n  labs(\n    x = \"Time\",\n    y = \"Fraction\",\n    color = \"State\"\n  ) +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![](r-session-01_files/figure-html/unnamed-chunk-14-1.png){width=100%}\n:::\n:::\n\n\n\n\n\n### Commenting the code {#sec-ex-commenting-code}\n\nFor this part of the exercise, go through the basic SIR code and add comments to each section of code explaining what it does.\nTo get you started, we've added some comments to the creating of the dataframe object `sir_sol_df` between lines 32-62 in the code block above, as some of the functions used there are a bit more complicated.\n\n::: callout-note\nNormally you would not use nearly as extensive comments.\nHere, we've gone overboard to help you understand what each line does, as some may not be familiar with all the functions used.\nWe've also broken up the comments into multiple lines so that it is easier to read on this website.\nFor your code that you view in RStudio (or some other text editor), use one line per sentence of the comment i.e., start a new comment line after each period.\n\nGenerally, you want to use comments to explain why you are doing something, not what you are doing.\nSometimes that is unavoidable (e.g., you had to look up how to do a particular thing in R and need the hints to be able to understand the code), but try to stick to this guideline where possible.\n:::\n\nAs you're going through the code, if you don't understand what a particular function does, try looking up the documentation for it!\nYou can do this by clicking on the function within the website (as described [in the intro](index.qmd#tips-about-the-website)), or by typing `?function_name` into the R console (Google also is your friend here!).\n\n### Adding in demographics {#sec-ex-add-demographics}\n\nNow we have a better sense of how the code works, let's add in some demographic structure.\nTo recreate the demographic model from the interactive plot in @sec-interactive-plots, we just need to add births and deaths to the system.\n\nRecall the equations for the demographic model:\n\n$$\n\\begin{aligned}\n\\frac{dS}{dt} &= \\mu N - \\beta S I - \\mu S \\\\\n\\frac{dI}{dt} &= \\beta S I - \\gamma I - \\mu I \\\\\n\\frac{dR}{dt} &= \\gamma I - \\mu R\n\\end{aligned}\n$$ {#eq-demographic-sir}\n\n#### Create a new R script called `S01_demographic-sir.R` and copy the code from `S01_basic-sir.R` into it.\n\n#### Rename the function `sir_model()` to `demographic_sir_model()` in your new script (`S01_demographic-sir.R`).\n\n#### Adapt the function `demographic_sir_model()` to match the above equations (@eq-demographic-sir).\n\n::: {.callout-note title=\"SET\"}\nbirth rate = 0.05\n:::\n\n#### Rename the variables to reflect that we are now working with a demographic model, not the basic SIR model.\n\n#### Run the code in the `S01_demographic-sir.R file`. Plot the results of your demographic model. Does it look like this?\n\n\n\n\n\n::: {.cell .column-body}\n::: {.cell-output-display}\n![](r-session-01_files/figure-html/unnamed-chunk-15-1.png){width=100%}\n:::\n:::\n\n\n\n\n\n#### Update the comments in your code to reflect the changes you have made.\n\n## Exercise Solutions {.appendix}\n\n::: callout-note\nHere, we're using the `{roxygen2}` package to create the comments for the functions we've created, i.e., `sir_model <- function(...)`.\nThis provides a consistent framework for commenting functions, and if we wanted, we could use the comments to create documentation for our functions.\nThe main benefit for our purposes is that the framework allows us to quickly understand exactly what the function does, as well as the context it should be used in.\n:::\n\n### @sec-ex-commenting-code: Commented basic SIR code\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Load packages\nlibrary(tidyverse)\nlibrary(deSolve)\n\n# Set the ggplot2 theme\ntheme_set(theme_minimal())\n\n#' Basic SIR model\n#'\n#' A basic SIR model with no demographic structure to be used in deSolve\n#'\n#' @param time deSolve passes the time parameter to the function.\n#' @param state A vector of states.\n#' @param params A vector of parameter values .\n#' @param ... Other arguments passed by deSolve.\n#'\n#' @return A deSolve matrix of states at each time step.\n#' @examples\n#' sir_params <- c(transmission = 0.3, duration = 6)\n#' sir_init_states <- c(S = 0.99, I = 0.01, R = 0)\n#' sim_times <- seq(0, 200, by = 0.1)\n#' \n#' sir_sol <- deSolve::ode(\n#'    y = sir_init_states,\n#'    times = sim_times,\n#'    func = sir_model,\n#'    parms = sir_params\n#' ))\nsir_model <- function(time, state, params, ... ){\n  # Extract parameters for cleaner calculations\n  transmission <- params[\"transmission\"]\n  recovery <- 1 / params[\"duration\"]\n\n  # Extract states for cleaner calculations\n  S <- state[\"S\"]\n  I <- state[\"I\"]\n  R <- state[\"R\"]\n\n  # Differential equations of the SIR model\n  dSdt <- -transmission * S * I\n  dIdt <- (transmission * S * I) - (recovery * I)\n  dRdt <- recovery * I\n\n  # Return a list whose first element is a vector of the\n  # state derivatives - must be in the same order as the\n  # state vector (S, I, R)\n  return(list(c(dSdt, dIdt, dRdt)))\n}\n\n# Create the parameter, initial state, and time vectors\nsir_params <- c(transmission = 0.3, duration = 6)\nsir_init_states <- c(S = 0.99, I = 0.01, R = 0)\nsim_times <- seq(0, 200, by = 0.1)\n\n# Solve the SIR model with deSolve's ode() function\nsir_sol <- deSolve::ode(\n  y = sir_init_states,\n  times = sim_times,\n  func = sir_model,\n  parms = sir_params\n)\n\n# Turn the output from the ODE solver into a tibble (dataframe)\n# so we can manipulate and plot it easily\nsir_sol_df <- as_tibble(sir_sol) %>%\n  # Convert all columns to numeric (they are currently type\n  # deSolve so will produce warnings when plotting etc)\n  mutate(\n    # Rather than repeatedly type the same function for every\n    # column, use the across() function to apply the function\n    # to a selection of columns\n    across(\n      # The cols argument takes a selection of columns to apply\n      # a function to. Here, we want to apply the as.numeric()\n      # function to all columns, so we use the function\n      # everything() to select all columns.\n      .cols = everything(),\n      .fns = as.numeric\n    )\n  ) %>%\n  # Convert the dataframe from wide to long format, so we have a\n  # column for the time, a column for the state, and a column\n  # for the proportion of the population in that state at that\n  # time\n  pivot_longer(\n    # Don't pivot the time column\n    cols = -time,\n    names_to = \"state\",\n    values_to = \"proportion\"\n  ) %>%\n  # Update the state column to be a factor, so the plot will\n  # show the states in the correct order\n  mutate(state = factor(state, levels = c(\"S\", \"I\", \"R\")))\n\n# Save the colors to a vector\nSIRcolors <- c(S = \"#1f77b4\", I = \"#ff7f0e\", R = \"#FF3851\")\n\n# Plot the results\nggplot(sir_sol_df, aes(x = time, y = proportion, color = state)) +\n  geom_line(linewidth = 1.5) +\n  scale_color_manual(values = SIRcolors) +\n  labs(\n    x = \"Time\",\n    y = \"Fraction\",\n    color = \"State\"\n  ) +\n  theme(legend.position = \"top\")\n```\n:::\n\n\n\n\n\n### @sec-ex-add-demographics: Commented demographic SIR code\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Load packages\nlibrary(tidyverse)\nlibrary(deSolve)\n\n# Set the ggplot2 theme\ntheme_set(theme_minimal())\n\n#' Demographic SIR model\n#'\n#' An SIR model with births and deaths (constant pop) to be used in deSolve\n#'\n#' @param time deSolve passes the time parameter to the function.\n#' @param state A vector of states.\n#' @param params A vector of parameter values .\n#' @param ... Other arguments passed by deSolve.\n#'\n#' @return A deSolve matrix of states at each time step.\n#' @examples\n#' sir_params <- c(transmission = 0.3, duration = 6, birth_rate = 0.05)\n#' sir_init_states <- c(S = 0.99, I = 0.01, R = 0)\n#' sim_times <- seq(0, 200, by = 0.1)\n#' \n#' sir_sol <- deSolve::ode(\n#'    y = sir_init_states,\n#'    times = sim_times,\n#'    func = sir_demog_model,\n#'    parms = sir_params\n#' ))\nsir_demog_model <- function(time, state, params, ... ){\n  transmission <- params[\"transmission\"]\n  recovery <- 1 / params[\"duration\"]\n  birth_rate <- params[\"birth_rate\"]\n\n  S <- state[\"S\"]\n  I <- state[\"I\"]\n  R <- state[\"R\"]\n\n  dSdt <- birth_rate -transmission * S * I - (birth_rate * S)\n  dIdt <- (transmission * S * I) - (recovery * I) - (birth_rate * I)\n  dRdt <- (recovery * I) - (birth_rate * R)\n\n  return(list(c(dSdt, dIdt, dRdt)))\n}\n\n# Create the parameter, initial state, and time vector\nsir_demog_params <- c(transmission = 0.3, duration = 6, birth_rate = 0.05)\nsir_init_states <- c(S = 0.99, I = 0.01, R = 0)\nsim_times <- seq(0, 200, by = 0.1)\n\n# Solve the SIR model with deSolve's ode() function\nsir_demog_sol <- deSolve::ode(\n  y = sir_init_states,\n  times = sim_times,\n  func = sir_demog_model,\n  parms = sir_demog_params\n)\n\n# Turn the output from the ODE solver into a tibble (dataframe)\n# so we can manipulate and plot it easily\nsir_demog_sol_df <- as_tibble(sir_demog_sol) %>%\n  # Convert all columns to numeric (they are currently type\n  # deSolve so will produce warnings when plotting etc)\n  mutate(\n    # Rather than repeatedly type the same function for every\n    # column, use the across() function to apply the function\n    # to a selection of columns\n    across(\n      # The cols argument takes a selection of columns to apply\n      # a function to. Here, we want to apply the as.numeric()\n      # function to all columns, so we use the function\n      # everything() to select all columns.\n      .cols = everything(),\n      .fns = as.numeric\n    )\n  ) %>%\n  # Convert the dataframe from wide to long format, so we have a\n  # column for the time, a column for the state, and a column\n  # for the proportion of the population in that state at that\n  # time\n  pivot_longer(\n    # Don't pivot the time column\n    cols = -time,\n    names_to = \"state\",\n    values_to = \"proportion\"\n  ) %>%\n  # Update the state column to be a factor, so the plot will\n  # show the states in the correct order\n  mutate(state = factor(state, levels = c(\"S\", \"I\", \"R\")))\n\n# Save the colors to a vector\nSIRcolors <- c(S = \"#1f77b4\", I = \"#ff7f0e\", R = \"#FF3851\")\n\n# Plot the results\nggplot(sir_demog_sol_df, aes(x = time, y = proportion, color = state)) +\n  geom_line(linewidth = 1.5) +\n  scale_color_manual(values = SIRcolors) +\n  labs(\n    x = \"Time\",\n    y = \"Fraction\",\n    color = \"State\"\n  ) +\n  theme(legend.position = \"top\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}