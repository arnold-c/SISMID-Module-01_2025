[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "SISMID Module 2 Materials (2023)",
    "section": "",
    "text": "Welcome"
  },
  {
    "objectID": "r-session-01.html#sec-interactive-plots",
    "href": "r-session-01.html#sec-interactive-plots",
    "title": "\n3  R Session 01\n",
    "section": "\n3.1 Interactive Plot",
    "text": "3.1 Interactive Plot\n\nCodeinit_beta = 0.3\ninit_dur_inf = 6.0\ninit_I0 = 0.01\ninit_births = 0.0\ninit_tmax = 200\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodefunction set(input, value) {\n  input.value = value;\n  input.dispatchEvent(new Event(\"input\", {bubbles: true}));\n}\n\n\n\n\n\n\n\n\nCodeviewof reset = Inputs.button([\n  [\"Reset all sliders\", () =&gt; {\n    set(viewof beta, init_beta)\n    set(viewof dur_inf, init_dur_inf)\n    set(viewof I0, init_I0)\n    set(viewof births, init_births)\n    set(viewof tmax, init_tmax)\n  }]\n])\n\nviewof beta = Inputs.range(\n  [0.0, 2.0],\n  {value: init_beta, step: 0.01, label: \"Transmission rate (per day)\"}\n)\n\nviewof dur_inf = Inputs.range(\n  [0.0, 20],\n  {value: init_dur_inf, step: 0.5, label: \"Duration of Infection (days)\"}\n)\n\nviewof I0 = Inputs.range(\n  [0.0, 1.0],\n  {value: init_I0, step: 0.01, label: \"Initial fraction infected\"}\n)\n\nviewof births = Inputs.range(\n  [0, 0.05],\n  {value: init_births, step: 0.001, label: \"Birth rate\"}\n)\n\nviewof tmax = Inputs.range(\n  [200, 600],\n  {value: init_tmax, step: 10.0, label: \"Maximum simulation time (years)\"}\n)\n\nviewof area = Inputs.toggle(\n  {label: \"Cumulative Area plot\", value: false}\n)\n\nmd`${tex`R_0 = ${R0_str}`}`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode{\n  if (births == 0){\n    var finalsize = sir_sol.get(\"R\", sir_sol.numRows()-1)\n    var finalsize_str = finalsize.toLocaleString(undefined, {minimumFractionDigits: 2})\n\n    return md`${tex`\\text{Final size} = ${finalsize_str}`}`\n  } else {\n    return md``\n  }\n}\n\n\n\n\n\n\n\n\n\n\nCodegamma = 1 / dur_inf\ndt = 0.01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodeimport {odeRK4} from '@rreusser/integration@3064'\nimport { aq, op } from '@uwdata/arquero'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodefunction sir(dydt, y, t) {\n  dydt[0] = - beta * y[0] * y[1] + births * (1 - y[0])\n  dydt[1] = beta * y[0] * y[1] - gamma * y[1] - births * y[1]\n  dydt[2] = gamma * y[1] - births * y[2]\n}\n\n\n\n\n\n\n\nCodefunction simulate(f, t0, y0, dt, tmax) {\n  var t = t0\n  var y = y0\n  var i = 0\n\n  var tsim = [t0]\n  var ysim = [y0]\n\n  for (t = t0 + dt; t &lt;= tmax; t += dt) {\n    ysim.push(odeRK4([], ysim[i], f, dt))\n    tsim.push(t)\n    i += 1\n  }\n  \n  return aq.table({\n    Time: tsim,\n    S: ysim.map(d =&gt; d[0]),\n    I: ysim.map(d =&gt; d[1]),\n    R: ysim.map(d =&gt; d[2])\n    })\n}\n\n\n\n\n\n\n\nCodesir_sol = simulate(sir, 0, [1.0-I0, I0, 0.0], dt, tmax)\nsir_sol_long = sir_sol.fold(aq.not('Time'), {as: ['State', 'Fraction']})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodeSIRcolors = [\"#1f77b4\", \"#ff7f0e\", \"#FF3851\"]\n\n\n\n\n\n\n\nCodeR0 = beta / (gamma + births)\nR0_str = R0.toLocaleString(undefined, {minimumFractionDigits: 2})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodefunction calculate_equil(R0){\n  if (births &gt; 0) {\n    var eq_S = 1 / R0\n    var eq_I = births / beta * (R0 - 1)\n    var eq_R = 1 - (eq_S + eq_I)\n\n    const eq_vals = aq.table({\n      State: [\"S\", \"I\", \"R\"],\n      Fraction: [eq_S, eq_I, eq_R]\n    })\n\n    return eq_vals\n  } else {\n    return null\n  }\n}\n\n\n\n\n\n\n\nCodeeq_vals = calculate_equil(R0)\n\n\n\n\n\n\n\n\n\nCodePlot.plot({\n  color: {\n    legend: true,\n    domain: [\"S\", \"I\", \"R\"],\n    range: SIRcolors\n  },\n  style: {fontSize: \"20px\"},\n  marginLeft: 65,\n  marginTop: 40,\n  marginBottom: 55,\n  grid: true,\n  width: 800,\n  height: 670,\n  y: {domain: [0, 1]},\n  marks: [\n    area ?\n      Plot.areaY(sir_sol_long, {x: \"Time\", y: \"Fraction\", fill: \"State\"}) :\n      [\n        R0 &gt;= 1.0 && births &gt; 0 ?\n        Plot.ruleY(\n          eq_vals,\n          {y: \"Fraction\", stroke: \"State\", strokeWidth: 2, strokeDasharray: [10]}\n        ) :\n        null,\n        Plot.lineY(\n          sir_sol_long,\n          {x: \"Time\", y: \"Fraction\", stroke: \"State\", strokeWidth: 6}\n        )\n      ]\n  ]\n})"
  },
  {
    "objectID": "r-session-01.html#closed-population-model-intuition",
    "href": "r-session-01.html#closed-population-model-intuition",
    "title": "\n3  R Session 01\n",
    "section": "\n3.2 Closed Population Model Intuition",
    "text": "3.2 Closed Population Model Intuition\nWe’ll first get develop an intuition for the closed population model. We’ll then extend this intuition to the open population model. When the Birth rate slider in the side panel of the interactive figure is set to 0, we have no births or deaths, so their is no replenishment of the susceptible population i.e., it is a closed population.\n\n\n\n\n\n\nSET\n\n\n\nTransmission rate = 1\nDuration of infection = 4.\n\n\n\n3.2.1 What is \\(R_0\\)?\n\n3.2.2 What is epidemic final size?\n\n3.2.3 Does this make sense given our definition of \\(R_0\\)?\n\n\n\n\n\n\nToggle on the cumulative area button and see what the epidemic final size is (approximately)\n\n\n\n\n3.2.4 At approximately what time does the epidemic end?\n\n\n\n\n\n\nSET\n\n\n\nDuration of infection = 8 days\nTransmission rate so you get the same \\(R_0\\) in Section 3.2.1\n\n\n\n3.2.5 How does the epidemic final size compare?\n\n3.2.6 At what time (approx) does the epidemic end?\n\n\n\n\n\n\nNote\n\n\n\nSize is determined by \\(R_0\\), duration is determined by recovery rate \\(\\left(\\gamma = \\frac{1}{\\text{duration of infection}}\\right)\\)\n\n\nNow, imagine that we have a drug (or vaccine) available to everyone that either reduced transmission OR shortened the duration of infection.\n\n\n\n\n\n\nSET\n\n\n\nTransmission rate = 1\nDuration of infection = 8 days\n\n\n\n3.2.7 Note the epidemic final size and the time until the epidemic is over.\n\n\n\n\n\n\nNow, imagine everyone has access to the drug (unrealistic) that reduces transmission by \\(P \\%\\)\n\n\n\n\n3.2.8 What happens to the final size and outbreak duration?\nNow, imagine everyone has access to a drug that reduces the duration of infection from 8 to 2 days (75% reduction).\n\n3.2.9 What happens to the final size and outbreak duration?\n\nWhich would you prefer and why? (This is the only really open ended question, but should be pretty straightforward discussion)"
  },
  {
    "objectID": "r-session-01.html#demographic-model-intuition",
    "href": "r-session-01.html#demographic-model-intuition",
    "title": "\n3  R Session 01\n",
    "section": "\n3.3 Demographic Model Intuition",
    "text": "3.3 Demographic Model Intuition\n\n\n\n\n\n\nSET\n\n\n\nTransmission = 1\nDuration = 8\nBirth rate = .002\n\n\n\n3.3.1 What is \\(R_0\\)?\n\n3.3.2 What is the equilibrium proportion that is susceptible?\n\n3.3.3 If you were to test for antibodies against infection in the population, what proportion would you expect to be positive?\n\n\n\n\n\n\nNote\n\n\n\nAssume a perfectly accurate serological test\n\n\n\n3.3.4 At what time (approximately) does the system reach equilibrium?\n\n\n\n\n\n\nSET\n\n\n\nBirth rate = 0.005\n\n\n\n3.3.5 What is the new \\(R_0\\)?\n\n3.3.6 At what time (approximately) does the system reach equilibrium?\n\n\n\n\n\n\nSET\n\n\n\nTransmission rate so you get the same \\(R_0\\) in Section 3.3.1\n\n\n\n3.3.7 What is the new equilibrium proportion that is susceptible?\n\n3.3.8 What is different about the prevalence of infection (equilibrium proportion that is infected) in the scenarios Section 3.3.1 and Section 3.3.5 i.e. higher birth rate with the same \\(R_0\\)?"
  },
  {
    "objectID": "r-session-01.html#model-building-with-r",
    "href": "r-session-01.html#model-building-with-r",
    "title": "\n3  R Session 01\n",
    "section": "\n3.4 Model Building With R",
    "text": "3.4 Model Building With R\n\n3.4.1 Setting Up A Script\nNow we have some intuition behind how the different parameters affect the dynamics of the SIR system, let’s look at how we can implement this in R. Below is some R code that implements the basic closed-population SIR model. The purpose of the questions in this exercise is to guide you through the code and help you understand how it works so you can modify it to answer your own questions.\n\n\n\n\n\n\n\nInstruction\n\n\n\nCopy the code below into a new R script. This script should live in your SISMID directory, as described previously. Run it to check you get the same figure output as above.\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nThere are a number of useful features throughout this website to help you.\nFirstly, clicking on the text ▶ Code will hide the code if open (the default), or show the code if hidden.\nSecondly, in the top right corner of each code block, there is a button that looks like a clipboard. Clicking this button will copy the code to your clipboard, so you can paste it into your own R session.\nFinally, within the code blocks (and, in fact, in the regular text like this section), functions (e.g. list(), pivot_longer()) that come from a package (i.e., ones we didn’t write) show up in a different color. In most cases, you can hover your cursor over them (on the part next the the parentheses e.g., ode() from the line deSolve::ode()), and if they become underlined, you can click on them to go to the documentation for that function. This is like searching for the documentation from your R console using ?ode.\n\n\n\n\nCodelibrary(tidyverse)\nlibrary(deSolve)\n\ntheme_set(theme_minimal())\n\nsir_model &lt;- function(time, state, params, ... ){\n  transmission &lt;- params[\"transmission\"]\n  recovery &lt;- 1 / params[\"duration\"]\n\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n\n  dSdt &lt;- -transmission * S * I\n  dIdt &lt;- (transmission * S * I) - (recovery * I)\n  dRdt &lt;- recovery * I\n\n  return(list(c(dSdt, dIdt, dRdt)))\n}\n\nsir_params &lt;- c(transmission = 0.3, duration = 6)\nsir_init_states &lt;- c(S = 0.99, I = 0.01, R = 0)\nsim_times &lt;- seq(0, 200, by = 0.1)\n\nsir_sol &lt;- deSolve::ode(\n  y = sir_init_states,\n  times = sim_times,\n  func = sir_model,\n  parms = sir_params\n)\n\n# Turn the output from the ODE solver into a tibble (dataframe)\n# so we can manipulate and plot it easily\nsir_sol_df &lt;- as_tibble(sir_sol) %&gt;%\n  # Convert all columns to numeric (they are currently type\n  # deSolve so will produce warnings when plotting etc)\n  mutate(\n    # Rather than repeatedly type the same function for every\n    # column, use the across() function to apply the function\n    # to a selection of columns\n    across(\n      # The cols argument takes a selection of columns to apply\n      # a function to. Here, we want to apply the as.numeric()\n      # function to all columns, so we use the function\n      # everything() to select all columns.\n      .cols = everything(),\n      .fns = as.numeric\n    )\n  ) %&gt;%\n  # Convert the dataframe from wide to long format, so we have a\n  # column for the time, a column for the state, and a column\n  # for the proportion of the population in that state at that\n  # time\n  pivot_longer(\n    # Don't pivot the time column\n    cols = -time,\n    names_to = \"state\",\n    values_to = \"proportion\"\n  ) %&gt;%\n  # Update the state column to be a factor, so the plot will\n  # show the states in the correct order\n  mutate(state = factor(state, levels = c(\"S\", \"I\", \"R\")))\n\nSIRcolors &lt;- c(S = \"#1f77b4\", I = \"#ff7f0e\", R = \"#FF3851\")\n\nggplot(sir_sol_df, aes(x = time, y = proportion, color = state)) +\n  geom_line(linewidth = 1.5) +\n  scale_color_manual(values = SIRcolors) +\n  labs(\n    x = \"Time\",\n    y = \"Fraction\",\n    color = \"State\"\n  ) +\n  theme(legend.position = \"top\")\n\n\n\n\n\n3.4.2 Commenting the code\nFor this part of the exercise, go through the basic SIR code and add comments to each section of code explaining what it does. To get you started, we’ve added some comments to the creating of the dataframe object sir_sol_df between lines 32-62 in the code block above, as some of the functions used there are a bit more complicated.\n\n\n\n\n\n\nNote\n\n\n\nNormally you would not use nearly as extensive comments. Here, we’ve gone overboard to help you understand what each line does, as some may not be familiar with all the functions used. We’ve also broken up the comments into multiple lines so that it is easier to read on this website. For your code that you view in RStudio (or some other text editor), use one line per sentence of the comment i.e., start a new comment line after each period.\nGenerally, you want to use comments to explain why you are doing something, not what you are doing. Sometimes that is unavoidable (e.g., you had to look up how to do a particular thing in R and need the hints to be able to understand the code), but try to stick to this guideline where possible.\n\n\nAs you’re going through the code, if you don’t understand what a particular function does, try looking up the documentation for it! You can do this by clicking on the function within the website (as described above), or by typing ?function_name into the R console (Google also is your friend here!).\n\n3.4.3 Adding in demographics\nNow we have a better sense of how the code works, let’s add in some demographic structure. To recreate the demographic model from the interactive plot in Section 3.1, we just need to add births and deaths to the system.\nRecall the equations for the demographic model:\n\\[\n\\begin{aligned}\n\\frac{dS}{dt} &= \\mu N - \\beta S I - \\mu S \\\\\n\\frac{dI}{dt} &= \\beta S I - \\gamma I - \\mu I \\\\\n\\frac{dR}{dt} &= \\gamma I - \\mu R\n\\end{aligned}\n\\tag{3.1}\\]\n\n3.4.3.1 Create a new R script called 01_demographic-sir.R and copy the code from S01_basic-sir.R into it.\n\n3.4.3.2 Rename the function sir_model() to demographic_sir_model() in your new script (S01_demographic-sir.R).\n\n3.4.3.3 Adapt the function demographic_sir_model() to match the above equations (Equation 3.1).\n\n\n\n\n\n\nSET\n\n\n\nbirth rate = 0.05\n\n\n\n3.4.3.4 Rename the variables to reflect that we are now working with a demographic model, not the basic SIR model.\n\n3.4.3.5 Plot the results of your demographic model. Does it look like this?\n\n\n\n\n\n\n3.4.3.6 Update the comments in your code to reflect the changes you have made."
  },
  {
    "objectID": "r-session-01.html#exercise-solutions",
    "href": "r-session-01.html#exercise-solutions",
    "title": "\n3  R Session 01\n",
    "section": "\n3.5 Exercise Solutions",
    "text": "3.5 Exercise Solutions\n\n\n\n\n\n\nNote\n\n\n\nHere, we’re using the roxygen2 package to create the comments for the functions we’ve created, i.e., sir_model &lt;- function(...). This provides a consistent framework for commenting functions, and if we wanted, we could use the comments to create documentation for our functions. The main benefit for our purposes is that the framework allows us to quickly understand exactly what the function does, as well as the context it should be used in.\n\n\n\n3.5.1 Section 3.4.2: Commented basic SIR code\n\nCode# Load packages\nlibrary(tidyverse)\nlibrary(deSolve)\n\n# Set the ggplot2 theme\ntheme_set(theme_minimal())\n\n#' Basic SIR model\n#'\n#' A basic SIR model with no demographic structure to be used in deSolve\n#'\n#' @param time deSolve passes the time parameter to the function.\n#' @param state A vector of states.\n#' @param params A vector of parameter values .\n#' @param ... Other arguments passed by deSolve.\n#'\n#' @return A deSolve matrix of states at each time step.\n#' @examples\n#' sir_params &lt;- c(transmission = 0.3, duration = 6)\n#' sir_init_states &lt;- c(S = 0.99, I = 0.01, R = 0)\n#' sim_times &lt;- seq(0, 200, by = 0.1)\n#' \n#' sir_sol &lt;- deSolve::ode(\n#'    y = sir_init_states,\n#'    times = sim_times,\n#'    func = sir_model,\n#'    parms = sir_params\n#' ))\nsir_model &lt;- function(time, state, params, ... ){\n  # Extract parameters for cleaner calculations\n  transmission &lt;- params[\"transmission\"]\n  recovery &lt;- 1 / params[\"duration\"]\n\n  # Extract states for cleaner calculations\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n\n  # Differential equations of the SIR model\n  dSdt &lt;- -transmission * S * I\n  dIdt &lt;- (transmission * S * I) - (recovery * I)\n  dRdt &lt;- recovery * I\n\n  # Return a list whose first element is a vector of the\n  # state derivatives - must be in the same order as the\n  # state vector (S, I, R)\n  return(list(c(dSdt, dIdt, dRdt)))\n}\n\n# Create the parameter, initial state, and time vectors\nsir_params &lt;- c(transmission = 0.3, duration = 6)\nsir_init_states &lt;- c(S = 0.99, I = 0.01, R = 0)\nsim_times &lt;- seq(0, 200, by = 0.1)\n\n# Solve the SIR model with deSolve's ode() function\nsir_sol &lt;- deSolve::ode(\n  y = sir_init_states,\n  times = sim_times,\n  func = sir_model,\n  parms = sir_params\n)\n\n# Turn the output from the ODE solver into a tibble (dataframe)\n# so we can manipulate and plot it easily\nsir_sol_df &lt;- as_tibble(sir_sol) %&gt;%\n  # Convert all columns to numeric (they are currently type\n  # deSolve so will produce warnings when plotting etc)\n  mutate(\n    # Rather than repeatedly type the same function for every\n    # column, use the across() function to apply the function\n    # to a selection of columns\n    across(\n      # The cols argument takes a selection of columns to apply\n      # a function to. Here, we want to apply the as.numeric()\n      # function to all columns, so we use the function\n      # everything() to select all columns.\n      .cols = everything(),\n      .fns = as.numeric\n    )\n  ) %&gt;%\n  # Convert the dataframe from wide to long format, so we have a\n  # column for the time, a column for the state, and a column\n  # for the proportion of the population in that state at that\n  # time\n  pivot_longer(\n    # Don't pivot the time column\n    cols = -time,\n    names_to = \"state\",\n    values_to = \"proportion\"\n  ) %&gt;%\n  # Update the state column to be a factor, so the plot will\n  # show the states in the correct order\n  mutate(state = factor(state, levels = c(\"S\", \"I\", \"R\")))\n\n# Save the colors to a vector\nSIRcolors &lt;- c(S = \"#1f77b4\", I = \"#ff7f0e\", R = \"#FF3851\")\n\n# Plot the results\nggplot(sir_sol_df, aes(x = time, y = proportion, color = state)) +\n  geom_line(linewidth = 1.5) +\n  scale_color_manual(values = SIRcolors) +\n  labs(\n    x = \"Time\",\n    y = \"Fraction\",\n    color = \"State\"\n  ) +\n  theme(legend.position = \"top\")\n\n\n\n3.5.2 Section 3.4.3: Commented demographic SIR code\n\nCode# Load packages\nlibrary(tidyverse)\nlibrary(deSolve)\n\n# Set the ggplot2 theme\ntheme_set(theme_minimal())\n\n#' Demographic SIR model\n#'\n#' An SIR model with births and deaths (constant pop) to be used in deSolve\n#'\n#' @param time deSolve passes the time parameter to the function.\n#' @param state A vector of states.\n#' @param params A vector of parameter values .\n#' @param ... Other arguments passed by deSolve.\n#'\n#' @return A deSolve matrix of states at each time step.\n#' @examples\n#' sir_params &lt;- c(transmission = 0.3, duration = 6, birth_rate = 0.05)\n#' sir_init_states &lt;- c(S = 0.99, I = 0.01, R = 0)\n#' sim_times &lt;- seq(0, 200, by = 0.1)\n#' \n#' sir_sol &lt;- deSolve::ode(\n#'    y = sir_init_states,\n#'    times = sim_times,\n#'    func = sir_demog_model,\n#'    parms = sir_params\n#' ))\nsir_demog_model &lt;- function(time, state, params, ... ){\n  transmission &lt;- params[\"transmission\"]\n  recovery &lt;- 1 / params[\"duration\"]\n  birth_rate &lt;- params[\"birth_rate\"]\n\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n\n  dSdt &lt;- birth_rate -transmission * S * I - (birth_rate * S)\n  dIdt &lt;- (transmission * S * I) - (recovery * I) - (birth_rate * I)\n  dRdt &lt;- (recovery * I) - (birth_rate * R)\n\n  return(list(c(dSdt, dIdt, dRdt)))\n}\n\n# Create the parameter, initial state, and time vector\nsir_demog_params &lt;- c(transmission = 0.3, duration = 6, birth_rate = 0.05)\nsir_init_states &lt;- c(S = 0.99, I = 0.01, R = 0)\nsim_times &lt;- seq(0, 200, by = 0.1)\n\n# Solve the SIR model with deSolve's ode() function\nsir_demog_sol &lt;- deSolve::ode(\n  y = sir_init_states,\n  times = sim_times,\n  func = sir_demog_model,\n  parms = sir_demog_params\n)\n\n# Turn the output from the ODE solver into a tibble (dataframe)\n# so we can manipulate and plot it easily\nsir_demog_sol_df &lt;- as_tibble(sir_demog_sol) %&gt;%\n  # Convert all columns to numeric (they are currently type\n  # deSolve so will produce warnings when plotting etc)\n  mutate(\n    # Rather than repeatedly type the same function for every\n    # column, use the across() function to apply the function\n    # to a selection of columns\n    across(\n      # The cols argument takes a selection of columns to apply\n      # a function to. Here, we want to apply the as.numeric()\n      # function to all columns, so we use the function\n      # everything() to select all columns.\n      .cols = everything(),\n      .fns = as.numeric\n    )\n  ) %&gt;%\n  # Convert the dataframe from wide to long format, so we have a\n  # column for the time, a column for the state, and a column\n  # for the proportion of the population in that state at that\n  # time\n  pivot_longer(\n    # Don't pivot the time column\n    cols = -time,\n    names_to = \"state\",\n    values_to = \"proportion\"\n  ) %&gt;%\n  # Update the state column to be a factor, so the plot will\n  # show the states in the correct order\n  mutate(state = factor(state, levels = c(\"S\", \"I\", \"R\")))\n\n# Save the colors to a vector\nSIRcolors &lt;- c(S = \"#1f77b4\", I = \"#ff7f0e\", R = \"#FF3851\")\n\n# Plot the results\nggplot(sir_demog_sol_df, aes(x = time, y = proportion, color = state)) +\n  geom_line(linewidth = 1.5) +\n  scale_color_manual(values = SIRcolors) +\n  labs(\n    x = \"Time\",\n    y = \"Fraction\",\n    color = \"State\"\n  ) +\n  theme(legend.position = \"top\")"
  },
  {
    "objectID": "r-session-02.html#load-packages",
    "href": "r-session-02.html#load-packages",
    "title": "\n7  R Session 02\n",
    "section": "\n7.1 Load Packages",
    "text": "7.1 Load Packages\n\nCodelibrary(diagram)\nlibrary(deSolve)\nlibrary(tidyverse)\nlibrary(gt)\n\n\n\nCodetheme_set(theme_minimal())"
  },
  {
    "objectID": "r-session-02.html#a-model-with-2-classes",
    "href": "r-session-02.html#a-model-with-2-classes",
    "title": "\n7  R Session 02\n",
    "section": "\n7.2 A Model With 2 Classes",
    "text": "7.2 A Model With 2 Classes\nWe’ll start with the simplest mechanistic model of two classes we can think of, which has separate classes for two groups \\(a\\) and \\(b\\). These groups could represent different socioeconomic classes, for example.\n\n\n\n\n\nWhich can be written in equations as, \\[\n\\begin{aligned}\n    \\frac{dS_a}{dt} &= -\\lambda_a\\,S_a \\phantom{-\\gamma\\,I_b}\\\\\n    \\frac{dS_b}{dt} &= -\\lambda_b\\,S_b \\phantom{-\\gamma\\,I_b}\\\\\n    \\frac{dI_a}{dt} &= \\phantom{-}\\lambda_a\\,S_a -\\gamma\\,I_a\\\\\n    \\frac{dI_b}{dt} &= \\phantom{-}\\lambda_b\\,S_b-\\gamma\\,I_b\\\\\n    \\frac{dR_a}{dt} &= \\phantom{-\\lambda_a\\,S_b}+\\gamma\\,I_a\\\\\n    \\frac{dR_b}{dt} &= \\phantom{-\\lambda_a\\,S_b}+\\gamma\\,I_b\\\\\n  \\end{aligned}\n\\]\nThe \\(\\lambda\\)s denote the group-specific force of infections:\n\\[\n\\begin{aligned}\n        \\lambda_a &= \\beta_{aa}\\,I_a+\\beta_{ab}\\,I_b\\\\\n        \\lambda_b &= \\beta_{ba}\\,I_a+\\beta_{bb}\\,I_b\n\\end{aligned}\n\\]\nIn this model, each population can infect each other but the infection moves through the populations separately. Let’s simulate such a model. To make things concrete, we’ll assume that the transmission rates \\(\\beta\\) are greater within groups than between them.\n\nCodeab_params &lt;- c(\n    beta_within = 0.025,\n    beta_between = 0.005,\n    recovery = 10\n)\n\n\n\nCode# Here we set up the ODE model that matches the equations above\nab_model &lt;- function (t, x, p, ...) {\n    Sa &lt;- x[\"Sa\"]\n    Sb &lt;- x[\"Sb\"]\n    Ia &lt;- x[\"Ia\"]\n    Ib &lt;- x[\"Ib\"]\n    Ra &lt;- x[\"Ra\"]\n    Rb &lt;- x[\"Rb\"]\n    \n    beta_within &lt;- p[\"beta_within\"]\n    beta_between &lt;- p[\"beta_between\"]\n    recovery &lt;- p[\"recovery\"]\n\n    # group A force of infection\n    lambda_a &lt;- beta_within * Ia + beta_between * Ib\n\n    # group B force of infection\n    lambda_b &lt;- beta_within * Ib + beta_between * Ia\n    \n    dSadt &lt;- - lambda_a * Sa\n    dSbdt &lt;- - lambda_b * Sb\n    dIadt &lt;- lambda_a * Sa - recovery * Ia\n    dIbdt &lt;- lambda_b * Sb - recovery * Ib\n    dRadt &lt;- recovery * Ia\n    dRbdt &lt;- recovery * Ib\n\n    list(c(\n        dSadt,\n        dSbdt,\n        dIadt,\n        dIbdt,\n        dRadt,\n        dRbdt\n    ))\n}\n\n\n\nCode# initial conditions\nab_yinit &lt;- c(Sa = 1000, Sb = 2000, Ia = 1, Ib = 1, Ra = 0, Rb = 0) # set starting conditions\n\n# Run the ODE solver from the deSolve package\nab_sol &lt;- deSolve::ode(\n    y = ab_yinit,\n    times = seq(0, 2, by = 0.001),\n    func = ab_model,\n    parms = ab_params,\n)\n\n\n\nCodeab_df &lt;- ab_sol %&gt;%\n    as_tibble() %&gt;%\n    mutate(\n        across(everything(), as.numeric),\n        Na = Sa + Ia + Ra,\n        Nb = Sb + Ib + Rb\n    ) %&gt;%\n    pivot_longer(\n        cols = -time,\n        names_to = c(\"state\", \"group\"),\n        names_sep = 1,\n        values_to = \"value\"\n    ) %&gt;%\n    mutate(\n        state = factor(state, levels = c(\"S\", \"I\", \"R\", \"N\")),\n        group = paste(\"Group\", str_to_upper(group))\n    )\n\n\n\nCodeSIRcolors &lt;- c(\"#1f77b4\", \"#ff7f0e\", \"#FF3851\", \"#591099\")\n\nggplot(ab_df, aes(x = time, y = value, color = state)) +\n    geom_line(linewidth = 1.5) +\n    facet_wrap(~group, scales = \"free_y\") +\n    scale_color_manual(\n        values = SIRcolors,\n        labels = c(\"Susceptible\", \"Infected\", \"Recovered\", \"Total\")\n    ) +\n    labs(\n        x = \"Time\",\n        y = \"Number of individuals\",\n        color = \"State\"\n    ) +\n    theme(legend.position = \"bottom\")\n\n\n\n\n\nDespite using the same transmission rates, the epidemic in group B is much larger than in group A. Why do you think this is?\n\nNow let’s plot the proportion of individuals in each state for the two groups.\n\nCodeab_df_props &lt;- ab_df %&gt;%\n    filter(state != \"N\") %&gt;%\n    mutate(\n        state_group = paste0(state, str_extract_all(group, \"[^Group ]\")),\n        state_group = factor(state_group, levels = c(\"RA\", \"RB\", \"IA\", \"IB\", \"SA\", \"SB\"))\n    ) %&gt;%\n    group_by(time, state_group) %&gt;%\n    mutate(\n        prop = value / sum(ab_yinit)\n    ) %&gt;%\n    ungroup()\n\n\n\nCodeScolors &lt;- RColorBrewer::brewer.pal(3, \"Blues\")[c(2, 3)]\nIcolors &lt;- RColorBrewer::brewer.pal(3, \"Oranges\")[c(2, 3)]\nRcolors &lt;- RColorBrewer::brewer.pal(3, \"Greens\")[c(2, 3)]\n\nggplot(ab_df_props, aes(x = time, y = prop, fill = state_group)) +\n    geom_area() +\n    scale_fill_manual(\n        values = c(Scolors, Icolors, Rcolors),\n        limits = c(\"SA\", \"SB\", \"IA\", \"IB\", \"RA\", \"RB\"),\n    ) +\n    labs(\n        x = \"Time\",\n        y = \"Proportion of individuals\",\n        fill = \"State\"\n    ) +\n    theme(legend.position = \"bottom\")"
  },
  {
    "objectID": "r-session-02.html#a-model-with-2-age-classes",
    "href": "r-session-02.html#a-model-with-2-age-classes",
    "title": "\n7  R Session 02\n",
    "section": "\n7.3 A Model With 2 Age Classes",
    "text": "7.3 A Model With 2 Age Classes\nNote that age is a special kind of heterogeneity in an epidemic model because individuals necessarily move from one class (younger) to another class (older) in a directional fashion that is independent of the infection and recovery process.\n\n\n\nWe’ll start by introducing age into the model above. So now \\(a\\) becomes juveniles and \\(b\\) becomes adults. And, independent of the disease process, juveniles (of any category) age into adults. Additionally, new juveniles are added through births (always first susceptible) and old individuals are lost to death.\n\n\n\n\n\nWe can do this very simply using the same ingredients that go into the basic SIR model. In that model, the waiting times in the S and I classes are exponential. Let’s assume the same thing about the aging process. We’ll also add in births into the juvenile susceptible class and deaths from the adult classes.\n\\[\n  \\begin{aligned}\n    \\frac{dS_J}{dt} &= B -\\lambda_J\\,S_J \\phantom{- \\gamma\\,I_A} -\\alpha\\,S_J \\phantom{-\\mu\\,S_A}\\\\\n    \\frac{dS_A}{dt} &= \\phantom{B} - \\lambda_A\\,S_A \\phantom{- \\gamma\\,I_A} +\\alpha\\,S_J -\\mu\\,S_A\\\\\n    \\frac{dI_J}{dt} &= \\phantom{B} +\\lambda_J\\,S_J - \\gamma\\,I_J -\\alpha\\,I_J \\phantom{-\\mu\\,S_A}\\\\\n    \\frac{dI_A}{dt} &= \\phantom{B} +\\lambda_A\\,S_A - \\gamma\\,I_A + \\alpha\\,I_J - \\mu\\,I_A\\\\\n    \\frac{dR_J}{dt} &= \\phantom{B - \\lambda_J\\,S_A} + \\gamma\\,I_J - \\alpha\\,R_J \\phantom{- \\mu\\,S_A}\\\\\n    \\frac{dR_A}{dt} &= \\phantom{B - \\lambda_J\\,S_A} + \\gamma\\,I_A + \\alpha\\,R_J -\\mu\\,R_A\\\\\n  \\end{aligned}\n\\]\nNow, let’s simulate this model, under the same assumptions about transmission rates as above.\n\nCode# define the parameters\ndemog_params &lt;- c(\n    beta_within = 0.004,\n    beta_between = 0.002,\n    recovery = 10,\n    births = 100,\n    age_band_j = 20,\n    age_band_a = 60\n)\n\n\n\nCodedemog_model &lt;- function (t, x, p, ...) {\n    Sj &lt;- x[\"Sj\"]\n    Sa &lt;- x[\"Sa\"]\n    Ij &lt;- x[\"Ij\"]\n    Ia &lt;- x[\"Ia\"]\n    Rj &lt;- x[\"Rj\"]\n    Ra &lt;- x[\"Ra\"]\n\n    beta_within &lt;- p[\"beta_within\"]\n    beta_between &lt;- p[\"beta_between\"]\n    recovery &lt;- p[\"recovery\"]\n    births &lt;- p[\"births\"]\n    aging_j &lt;- 1 / p[\"age_band_j\"]\n    aging_a &lt;- 1 / p[\"age_band_a\"]\n\n    # juv. force of infection \n    lambda_j &lt;- beta_within * Ij + beta_between * Ia\n    \n    # adult. force of infection\n    lambda_a &lt;- beta_within * Ia + beta_between * Ij\n\n    dSjdt &lt;- births - (lambda_j * Sj) - (aging_j * Sj)\n    dSadt &lt;- -(lambda_a * Sa) + (aging_j * Sj) - (aging_a * Sa)\n    dIjdt &lt;- (lambda_j * Sj) - (recovery * Ij) - (aging_j * Ij)\n    dIadt &lt;- (lambda_a * Sa) - (recovery * Ia) + (aging_j * Ij) - (aging_a * Ia)\n    dRjdt &lt;- (recovery * Ij) - (aging_j * Rj)\n    dRadt &lt;- (recovery * Ia) + (aging_j * Rj) - (aging_a * Ra)\n    \n    list(c(\n        dSjdt,\n        dSadt,\n        dIjdt,\n        dIadt,\n        dRjdt,\n        dRadt\n    ))\n}\n\n\nNote that in this function, \\(\\mu=\\) aging_a \\(=\\) 1 / p[\"age_band_a\"], i.e., death, is just like another age class.\n\nCode## initial conditions\ndemog_yinit &lt;- c(Sj = 2000, Sa = 3000, Ij = 0, Ia = 1, Rj = 0, Ra = 1000)\n\ndemog_sol &lt;- deSolve::ode(\n    y = demog_yinit,\n    times = seq(0, 200, by = 0.1),\n    func = demog_model,\n    parms = demog_params\n)\n\ndemog_df &lt;- demog_sol %&gt;%\n    as_tibble() %&gt;%\n    mutate(\n        across(everything(), as.numeric),\n        Nj = Sj + Ij + Rj,\n        Na = Sa + Ia + Ra,\n        N = Nj + Na\n    ) %&gt;%\n    pivot_longer(\n        cols = -c(time, N),\n        names_to = c(\"state\", \"group\"),\n        names_sep = 1,\n        values_to = \"value\"\n    ) %&gt;%\n    mutate(\n        state = factor(state, levels = c(\"S\", \"I\", \"R\", \"N\")),\n        group = paste(\"Group\", str_to_upper(group))\n    )\n\n\n\n7.3.1 Exercise 1: Use this code to plot the number of susceptible, infected, and recovered individuals over time.\n\nCodeggplot(demog_df, aes(x = time, y = value, color = state)) +\n    geom_line(linewidth = 1.5) +\n    facet_wrap(~group, nrow = 2, scales = \"free_y\") +\n    scale_color_manual(\n        values = SIRcolors,\n        labels = c(\"Susceptible\", \"Infected\", \"Recovered\", \"Total\")\n    ) +\n    labs(\n        x = \"Time\",\n        y = \"Number of individuals\",\n        color = \"State\"\n    ) +\n    theme(legend.position = \"bottom\")\n\n\n\n\nNote that now that births are replenishing susceptibles, infection persists. The results of the above are plotted here:\nNow let’s plot the proportion of individuals in each state for the two groups.\n\nCodedemog_df_props &lt;- demog_df %&gt;%\n    filter(state != \"N\") %&gt;%\n    mutate(\n        state_group = paste0(state, str_extract_all(group, \"[^Group ]\")),\n        state_group = factor(state_group, levels = c(\"RA\", \"RJ\", \"IA\", \"IJ\", \"SA\", \"SJ\"))\n    ) %&gt;%\n    group_by(time, state_group) %&gt;%\n    mutate(\n        prop = value / N\n    ) %&gt;%\n    ungroup()\n\n\n\nCodeggplot(demog_df_props, aes(x = time, y = prop, fill = state_group)) +\n    geom_area() +\n    scale_fill_manual(\n        values = c(Scolors, Icolors, Rcolors),\n        limits = c(\"SA\", \"SJ\", \"IA\", \"IJ\", \"RA\", \"RJ\")\n    ) +\n    labs(\n        x = \"Time\",\n        y = \"Proportion of individuals\",\n        fill = \"State\"\n    ) +\n    theme(legend.position = \"bottom\")\n\n\n\n\nNow let’s plot the equilibrium seroprevalence for each age group.\n\nCodedemog_equil_seroprev &lt;- tail(demog_df) %&gt;%\n    mutate(\n        prop = value / sum(value),\n        group = case_when(group == \"Group J\" ~ \"Juveniles\", TRUE ~ \"Adults\"),\n        group = factor(group, levels = c(\"Juveniles\", \"Adults\")),\n        .by = group\n    ) %&gt;%\n    filter(state == \"R\")\n\n\n\nCodeage_group_colors &lt;- c(\"#2980B9\", \"#154360\")\n\nggplot(demog_equil_seroprev, aes(x = group, y = prop, fill = group)) +\n    geom_col(position = \"identity\") +\n    scale_fill_manual(\n        values = age_group_colors\n    ) +\n    labs(\n        x = \"Age group\",\n        y = \"Equilibrium seroprevalence\",\n        fill = \"Age group\"\n    ) +\n    theme(legend.position = \"none\")\n\n\n\n\nTo compute \\(R_0\\), we need to know the stable age distribution (the relative proportion in the juvenile and adult age classes) of the population, which we can find by solving for the disease-free equilibrium: \\(S_J^*=B/\\alpha\\) and \\(S_A^*=B/\\mu\\).\nWith the stable age distribution, we can calculate \\(R_0\\) by constructing the next generation matrix. Details on this method are described in the last section of this worksheet (Equation 7.2) and are not required for completing the exercises in the worksheet. The code below outlines how the next generation matrix is constructed using the \\(\\alpha\\) (aging from juvenile to adult), \\(\\mu\\) (death), \\(n\\) (total births), \\(\\gamma\\) (recovery), \\(da\\) (width of age groups in years), and \\(\\beta\\) (transmission) parameters.\n\nCode# this code can be re-run to set parameter values\nalpha &lt;- 1 / demog_params[\"age_band_j\"]\nmu &lt;- 1 / demog_params[\"age_band_a\"]\nn &lt;- demog_params[\"births\"] / c(alpha, mu)\n\nbeta_demog &lt;- matrix(c(\n    demog_params[\"beta_within\"],\n    demog_params[\"beta_between\"],\n    demog_params[\"beta_between\"],\n    demog_params[\"beta_within\"]\n    ),\n    nrow = 2,\n    ncol = 2\n)\n\n# this command creates the next generation matrix\nngm &lt;- matrix(\n    c(\n        n[1] * (beta_demog[1, 1] / (demog_params[\"recovery\"] + alpha)) +\n            alpha / (demog_params[\"recovery\"] + mu) *\n            n[1] * beta_demog[1, 2] / (demog_params[\"recovery\"] + mu),\n        \n        n[2] * beta_demog[2, 1] / (demog_params[\"recovery\"] + alpha) +\n            alpha / (demog_params[\"recovery\"] + mu) *\n            n[2] * (beta_demog[2, 2] / (demog_params[\"recovery\"] + mu)),\n\n        n[1] * beta_demog[1, 2] / (demog_params[\"recovery\"] + mu),\n\n        n[2] * beta_demog[2, 2] / (demog_params[\"recovery\"] + mu)\n    ),\n    nrow = 2,\n    ncol = 2\n)\n\n# this command outputs the R0 value\nmax(Re(eigen(ngm, only.values = TRUE)$values))\n\n[1] 2.655305"
  },
  {
    "objectID": "r-session-02.html#getting-more-realistic-adding-more-age-classes",
    "href": "r-session-02.html#getting-more-realistic-adding-more-age-classes",
    "title": "\n7  R Session 02\n",
    "section": "\n7.4 Getting more realistic: adding more age classes",
    "text": "7.4 Getting more realistic: adding more age classes\nIn the models above, the aging process follows an exponential distribution, which means that whether an individual is 1~year old or 10 years old, the chance of them becoming an adult is the same! To improve on this, we can assume that the time a juvenile must wait before becoming an adult follows a gamma distribution. This is equivalent to saying that the waiting time is a sum of some number of exponential distributions. This suggests that we can achieve such a distribution by adding age classes to the model, so that becoming an adult means passing through some number of stages. We’ll use 30 age classes, and since they don’t have to be of equal duration, we’ll assume that they’re not. Specifically, we’ll have 20 1-yr age classes to take us up to adulthood and break adults into 10 age classes of 5~yr duration each. The last age class covers age 66-80.\nNow, when we had just two age classes, we could write out each of the equations easily enough, but now that we’re going to have 30, we’ll need to be more systematic. In particular, we’ll need to think of \\(\\beta\\) as a matrix of transmission rates. Let’s see how to define such a matrix in R. So that we don’t change too many things all at once, let’s keep the same contact structure as in the juvenile-adult model.\n\nCodeages_params &lt;- c(\n    beta_j = 0.02,\n    beta_a = 0.01,\n    beta_aj = 0.01 / 2,\n    recovery = 10,\n    births = 100\n)\n\nages &lt;- c(seq(1, 20, by = 1), seq(25, 65, by = 5), 80) # upper end of age classes\n\nda_ages &lt;- diff(c(0, ages))                  # widths of age classes\n\n# set up a matrix of contact rates between classes -- more contact within juveniles and adults than between\nages_beta_mat &lt;- matrix(nrow = 30, ncol = 30)\n\n# transmission rate for juveniles\nages_beta_mat[1:20, 1:20] &lt;- ages_params[\"beta_j\"]\n\n# transmission rate for adults\nages_beta_mat[21:30, 21:30] &lt;- ages_params[\"beta_a\"]\n\n# lower transmission rate between juveniles and adults\nages_beta_mat[1:20, 21:30] &lt;- ages_params[\"beta_aj\"]\n\n# lower transmission rate between juveniles and adults\nages_beta_mat[21:30, 1:20] &lt;- ages_params[\"beta_aj\"]\n\n\n\n\nCodeages_beta_mat %&gt;%\n    # Turn into a data.frame so we can use ggplot()\n    as.data.frame.table() %&gt;%\n    mutate(\n        Age_J = rep(ages, 30),\n        Age_A = unlist(purrr::map(.x = ages, ~rep(.x, 30))),\n    ) %&gt;%\n    ggplot(aes(x = Age_J, y = Age_A, z = Freq)) +\n    geom_contour_filled(bins = 8) +\n    scale_fill_brewer(\n        palette = \"Reds\",\n        drop = FALSE\n    )\n\n\n\n\nWe’ll assume that, at the time of introduction, all children are susceptible, as are adults over 45, but that individuals aged 20–45 have seen the pathogen before and are immune. The vector yinit expresses these initial conditions.\n\nCodedemog_yinit_ages &lt;- c(\n    S = c(rep(100, 20), rep(0, 5), rep(200, 5)),\n    I = c(rep(0, 25), 1, rep(0, 4)),\n    R = c(rep(0, 20), rep(1000, 5), rep(0, 5))\n)\n\n\nNote that we’re starting out with 1 infected individual in the 26th age class.\nThe codes that follow will be a bit easier to follow if we introduce some indexes that will allow us to pick out certain bits of the yinit vector.\n\nCodesindex &lt;- 1:30\niindex &lt;- 31:60\nrindex &lt;- 61:90\njuvies &lt;- 1:20\nadults &lt;- 21:30\n\n\nNow, to capture the aging process, it’s convenient to define another matrix to hold the rates of movement between age classes.\n\nCode# Create a diagonal matrix that holds the rates of aging out of each age class\n# The rows represent the age class you're in, the columns represent the age class\n# you're moving to\naging_mat &lt;- diag(-1 / da_ages)\n\n# Fill in the rates of aging into each age class\naging_mat[row(aging_mat) - col(aging_mat) == 1] &lt;- 1 / head(da_ages, -1)\n\n\nHave a look at the aging matrix, for example by doing:\n\nCode# move fast through the 1-year age classes - negatives are moves out, positives are moves in\naging_mat[1:5,1:5]\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   -1    0    0    0    0\n[2,]    1   -1    0    0    0\n[3,]    0    1   -1    0    0\n[4,]    0    0    1   -1    0\n[5,]    0    0    0    1   -1\n\n\n\nCode# don't age between these classes -- e.g. can't age from 1 to 6\naging_mat[1:10,1:10]\n\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n [1,]   -1    0    0    0    0    0    0    0    0     0\n [2,]    1   -1    0    0    0    0    0    0    0     0\n [3,]    0    1   -1    0    0    0    0    0    0     0\n [4,]    0    0    1   -1    0    0    0    0    0     0\n [5,]    0    0    0    1   -1    0    0    0    0     0\n [6,]    0    0    0    0    1   -1    0    0    0     0\n [7,]    0    0    0    0    0    1   -1    0    0     0\n [8,]    0    0    0    0    0    0    1   -1    0     0\n [9,]    0    0    0    0    0    0    0    1   -1     0\n[10,]    0    0    0    0    0    0    0    0    1    -1\n\n\n\nCode# move slowly between the wider age classes\naging_mat[25:30,25:30]\n\n     [,1] [,2] [,3] [,4] [,5]        [,6]\n[1,] -0.2  0.0  0.0  0.0  0.0  0.00000000\n[2,]  0.2 -0.2  0.0  0.0  0.0  0.00000000\n[3,]  0.0  0.2 -0.2  0.0  0.0  0.00000000\n[4,]  0.0  0.0  0.2 -0.2  0.0  0.00000000\n[5,]  0.0  0.0  0.0  0.2 -0.2  0.00000000\n[6,]  0.0  0.0  0.0  0.0  0.2 -0.06666667\n\n\n\nCodeaging_mat %&gt;%\n    as.data.frame.table() %&gt;%\n    mutate(\n        Age_J = rep(ages, 30),\n        Age_A = unlist(purrr::map(.x = ages, ~rep(.x, 30)))\n    ) %&gt;%\n    ggplot(aes(x = Age_J, y = Age_A, z = Freq)) +\n    geom_contour_filled() +\n    scale_fill_brewer(\n        palette = \"RdBu\",\n        drop = FALSE\n    )\n\n\n\n\n\n7.4.1 Exercise 2: What can you say about its structure? How are the different age groups in contact with each other?\nNow we can put the pieces together to write a simulator for the age-structured SIR dynamics.\n\nCode# Using a list instead of a vector to hold the parameters, as ages_beta_mat and aging \n# are both matrices, so we want to keep them as matrices, rather than flattening\nmultistage_params &lt;- list(\n    beta_mat = ages_beta_mat,\n    recovery = ages_params[\"recovery\"],\n    births = ages_params[\"births\"],\n    aging_mat = aging_mat\n)\n\nmultistage_model &lt;- function (t, x, p, ...) {\n    s &lt;- x[sindex]                  # susceptibles\n    i &lt;- x[iindex]                  # infecteds\n    r &lt;- x[rindex]                  # recovereds\n    \n    beta_mat &lt;- p[[\"beta_mat\"]]    # transmission rate\n\n    recovery &lt;- p[[\"recovery\"]]   # recovery rate\n    births &lt;- p[[\"births\"]] # birth rate\n    aging_mat &lt;- p[[\"aging_mat\"]]\n\n    lambda &lt;- beta_mat %*% i        # force of infection\n    \n    dsdt &lt;- -lambda * s + aging_mat %*% s\n    didt &lt;- lambda * s + aging_mat %*% i - recovery * i\n    drdt &lt;- aging_mat %*% r + recovery * i \n    dsdt[1] &lt;- dsdt[1] + births\n    \n    list(c(dsdt, didt, drdt))\n\n}\n\n\nWe can plug this into ode just as we did the simpler models to simulate an epidemic. We’ll then plot the epidemic curve.\n\nCodemultistage_sol &lt;- deSolve::ode(\n    y = demog_yinit_ages,\n    times = seq(0, 100, by = 0.1),\n    func = multistage_model,\n    parms = multistage_params\n)\n\nmultistage_infecteds &lt;- multistage_sol[, 1 + iindex]\n\n\n\nCodemultistage_df &lt;- tibble(\n        time = multistage_sol[, 1],\n        Juveniles = apply(multistage_infecteds[, juvies], 1, sum),\n        Adults = apply(multistage_infecteds[, adults], 1, sum)\n    ) %&gt;%\n    pivot_longer(\n        cols = c(Juveniles, Adults),\n        names_to = \"age_group\",\n        values_to = \"infections\"\n    ) %&gt;%\n    mutate(\n        age_group = factor(age_group, levels = c(\"Juveniles\", \"Adults\"))\n    )\n\n\n\nCodeggplot(multistage_df, aes(x = time, y = infections, color = age_group)) +\n    geom_line(linewidth = 1.5) +\n    scale_color_manual(\n        values = age_group_colors\n    ) +\n    labs(\n        x = \"Time\",\n        y = \"Number of infections\",\n        color = \"Age group\"\n    )\n\n\n\n\nLet’s mimic a situation where we have cross-sectional seroprevalence data (e.g. measures of antibodies that tell you someone is in the R class). In using such data, we’d typically assume that the system was at equilibrium.\n\n7.4.2 Exercise 3: What does the equilibrium age-specific seroprevalence look like in this example?\nUse the code below to display the age-specific seroprevalence (i.e., the seroprevalence for each age group at equilibrium)\n\nCodemultistage_equil &lt;- drop(tail(multistage_sol, 1))[-1]\nmultistage_equil_n &lt;- multistage_equil[sindex] + multistage_equil[iindex] + multistage_equil[rindex]\nmultistage_equil_seroprev &lt;- multistage_equil[rindex] / multistage_equil_n\n\nmultistage_equil_seroprev_df &lt;- tibble(\n    age = ages,\n    seroprev = multistage_equil_seroprev,\n    width = da_ages\n)\n\n\n\nCodeggplot(multistage_equil_seroprev_df, aes(x = age, y = seroprev, fill = age)) +\n    geom_col(width = multistage_equil_seroprev_df$width, just = 1.0, color = \"black\") +\n    labs(\n        x = \"Age\",\n        y = \"Seroprevalence\"\n    ) +\n    scale_x_continuous(breaks = seq(0, 80, 10)) +\n    scale_fill_continuous(low = age_group_colors[1], high = age_group_colors[2])\n\n\n\n\nLet’s also compute \\(R_0\\). To do so, we’ll need the stable age distribution. We can get that by simulating an infection-free population, which we get by setting the initial I to all 0s:\n\nCodemultistage_sonly_yinit &lt;- c(\n    S = c(rep(250, 30)),\n    I = c(rep(0, 30)),\n    R = c(rep(0, 30))\n)\n\nmultistage_sonly_sol &lt;- deSolve::ode(\n    y = multistage_sonly_yinit,\n    times = seq(0, 300, by = 1),\n    func = multistage_model,\n    parms = multistage_params\n)\n\nmultistage_sonly_pop &lt;- tibble(\n    time = multistage_sonly_sol[, 1],\n    pop = apply(multistage_sonly_sol[, -1], 1 , sum)\n)\n\n\n\nCodeggplot(multistage_sonly_pop, aes(x = time, y = pop)) +\n    geom_area(fill = SIRcolors[4], alpha = 0.6) +\n    labs(\n        x = \"Time\",\n        y = \"Population size\"\n    )\n\n\n\n\nAlternatively, we can get the stable age distribution by finding the population structure that balances the birth, aging, and death processes. At equilibrium, we have the matrix equation\n\\[\n\\begin{pmatrix}\n    -\\alpha_1 & 0 & 0 & \\cdots & 0\\\\\n    \\alpha_1 & -\\alpha_2 & 0 & \\cdots & 0\\\\\n    0 & \\alpha_2 & -\\alpha_3 & \\cdots & 0\\\\\n    \\vdots &  & \\ddots & \\ddots & \\vdots \\\\\n    0 & \\cdots & & \\alpha_{29} & -\\alpha_{30}\\\\\n\\end{pmatrix} .\n\\begin{pmatrix}\n    n_1 \\\\ n_2 \\\\ n_3 \\\\ \\vdots \\\\ n_{30}\n\\end{pmatrix} +\n\\begin{pmatrix}\n    B \\\\ 0 \\\\ 0 \\\\ \\vdots \\\\ 0\n\\end{pmatrix} =\n\\begin{pmatrix}\n    0 \\\\ 0 \\\\ 0 \\\\ \\vdots \\\\ 0\n\\end{pmatrix}\n\\]\nTo solve this equation in R, we can do\n\nCode# solve(a, b) solves the equation a %*% x = b for x, so rearrange equation above so b is on the RHS of the equation\nmultistage_stable_n &lt;- solve(\n    aging_mat,\n    c(-1 * multistage_params[[\"births\"]], rep(0, 29))\n)\n\nmultistage_stable_n\n\n [1]  100  100  100  100  100  100  100  100  100  100  100  100  100  100  100\n[16]  100  100  100  100  100  500  500  500  500  500  500  500  500  500 1500\n\n\n\nCode# Check the final pop value of the S-only sim is equal to the sum of the stable age distribution calculated above\nround(tail(multistage_sonly_pop$pop, 1)) == sum(multistage_stable_n)\n\n[1] TRUE\n\n\nThe following lines then compute \\(R_0\\) using the next generation matrix method. More details are available in the “Bonus” section at the end of the document. This calculation comes from a recipe described in detail previously (Diekmann and Heesterbeek 2000; Heesterbeek 2002; Bjørnstad 2018; Heffernan, Smith, and Wahl 2005; Hurford, Cownden, and Day 2009) (we would recommend starting with (Bjørnstad 2018; and Heffernan, Smith, and Wahl 2005)).\n\nCodeF &lt;- diag(multistage_stable_n) %*% multistage_params[[\"beta_mat\"]] +\n    multistage_params[[\"aging_mat\"]] -\n    diag(diag(multistage_params[[\"aging_mat\"]]))\n\nV &lt;- diag(multistage_params[[\"recovery\"]] - diag(multistage_params[[\"aging_mat\"]]))\n\nmax(\n    Re(\n        eigen(solve(V, F), only.values = TRUE)$values\n    )\n)\n\n[1] 6.792003\n\n\nThe steps below are copied from (Bjørnstad 2018)\n\nIdentify all n infected compartments\nConstruct a n × 1 matrix, \\(\\mathbf{F}\\), that contains expressions for all completely new infections entering each infected compartment\nConstruct a n × 1 matrix, \\(\\mathbf{V^−}\\), that contains expressions for all losses out of each infected compartment\nConstruct a n × 1 matrix, \\(\\mathbf{V^+}\\), that contains expressions for all gains into each infected compartment that does not represent new infections but transfers among infectious classes\nConstruct a n × 1 matrix, \\(\\mathbf{V} = \\mathbf{V^−} − \\mathbf{V^+}\\)\n\nGenerate two n × n Jacobian matrices \\(f\\) and \\(v\\) that are the partial derivatives of \\(\\mathbf{F}\\) and \\(\\mathbf{V}\\) with respect to the \\(n\\) infectious state variables\nEvaluate the matrices at the disease free equilibrium (dfe), and finally\n\n\\(R_0\\) is the greatest eigenvalue of \\(\\mathbf{fv}^{−1}|_{dfe}\\).\n\n\nCodef &lt;- diag(multistage_stable_n) %*% multistage_params[[\"beta_mat\"]]\n\n# Losses occur due to recovery and aging\nv_minus &lt;- rep(multistage_params[[\"recovery\"]], 30) +\n    diag(multistage_params[[\"aging_mat\"]])\n\n# Non-infection gains occur due to aging\nv_plus &lt;- -diag(multistage_params[[\"aging_mat\"]])\n\n# Convert to matrix as required for solve() function\nv &lt;- diag(v_minus - v_plus)\n\nmax(\n    Re(\n        # Equivalent to fv^{-1} in the above recipe as solve effectively inverts\n        # V\n        eigen(solve(v, f), only.values = TRUE)$values\n    )\n)\n\n[1] 7.664112\n\n\n\n7.4.3 Exercise 4:\n\n7.4.3.1 Change the juvenile and adult contact rates (ages_params[1] and ages_params[2]) to reflect different transmission within groups. Make the juvenile contact rate 0.02 to reflect higher contact among kids (e.g. in schools).\n\nCodeupdate_age_beta_mat &lt;- matrix(data = 0.007, nrow = 30, ncol = 30)\nupdate_age_beta_mat[1:20,1:20] &lt;- 0.02\nupdate_age_beta_mat[6:16,6:16] &lt;- 0.03\n\nupdate_age_params &lt;- list(\n    beta_mat = update_age_beta_mat,\n    recovery = ages_params[\"recovery\"],\n    births = ages_params[\"births\"],\n    aging_mat = aging_mat\n)\n\n\n\n7.4.3.2 Edit the ggplot code from Section 7.3 to plot the new beta matrix.\n\nCodeupdate_age_beta_mat %&gt;%\n    # Turn into a data.frame so we can use ggplot()\n    as.data.frame.table() %&gt;%\n    mutate(\n        Age_J = rep(ages, 30),\n        Age_A = unlist(purrr::map(.x = ages, ~rep(.x, 30))),\n    ) %&gt;%\n    ggplot(aes(x = Age_J, y = Age_A, z = Freq)) +\n    geom_contour_filled(bins = 8) +\n    scale_fill_brewer(\n        palette = \"Reds\",\n        drop = FALSE\n    )\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou could also use the fill.contour() base-R function to plot the beta matrix without needing to do any dataframe modifications, but it doesn’t look as nice …\n\n\n\n7.4.3.3 Simulate and plot the age-structured SIR dynamics under your assumptions and record how the age-specific seroprevalence has changed.\n\nCodeupdate_age_sol &lt;- deSolve::ode(\n    y = demog_yinit_ages,\n    times = seq(0, 400, by = 0.1),\n    func = multistage_model,\n    parms = update_age_params\n)\n\n# Get the time series for each infectious age group\nupdate_age_infecteds &lt;- update_age_sol[, 1 + iindex]\n\n\n\nCodeupdate_age_infecteds_df &lt;- tibble(\n        time = update_age_sol[, 1],\n        Juveniles = apply(update_age_infecteds[, juvies], 1, sum),\n        Adults = apply(update_age_infecteds[, adults], 1, sum)\n    ) %&gt;%\n    pivot_longer(\n        cols = c(Juveniles, Adults),\n        names_to = \"age_group\",\n        values_to = \"infections\"\n    ) %&gt;%\n    mutate(\n        age_group = factor(age_group, levels = c(\"Juveniles\", \"Adults\"))\n    )\n\n\n\nCodeggplot(update_age_infecteds_df, aes(x = time, y = infections, color = age_group)) +\n    geom_line(linewidth = 1.5) +\n    scale_color_manual(\n        values = age_group_colors\n    ) +\n    labs(\n        x = \"Time\",\n        y = \"Number of infections\",\n        color = \"Age group\"\n    )\n\n\n\n\n\nCodeupdate_age_equil &lt;- drop(tail(update_age_sol, 1))[-1]\n\nupdate_age_equil_n &lt;- update_age_equil[sindex] +\n    update_age_equil[iindex] +\n    update_age_equil[rindex]\n\nupdate_age_equil_seroprev &lt;- update_age_equil[rindex] / update_age_equil_n\n\nupdate_age_equil_seroprev_df &lt;- tibble(\n    age = ages,\n    seroprev = update_age_equil_seroprev,\n    width = da_ages\n)\n\n\n\nCodeggplot(update_age_equil_seroprev_df, aes(x = age, y = seroprev, fill = age)) +\n    geom_col(width = update_age_equil_seroprev_df$width, just = 1.0, color = \"black\") +\n    labs(\n        x = \"Age\",\n        y = \"Seroprevalence\"\n    ) +\n    scale_x_continuous(breaks = seq(0, 80, 10)) +\n    scale_fill_continuous(low = age_group_colors[1], high = age_group_colors[2])\n\n\n\n\n\n7.4.3.4 Compute \\(R_0\\) for your assumptions.\n\nCodeF &lt;- diag(update_age_equil_n) %*% update_age_beta_mat +\n    update_age_params[[\"aging_mat\"]] -\n    diag(diag(update_age_params[[\"aging_mat\"]]))\n\nV &lt;- diag(update_age_params[[\"recovery\"]] - diag(update_age_params[[\"aging_mat\"]]))\n\nmax(Re(eigen(solve(V, F), only.values = TRUE)$values))\n\n[1] 6.526177\n\nCode# R0 = 6.53\n\n# Find the equilibrium values for each infected age group\nupdate_age_infecteds_equil &lt;- update_age_infecteds[dim(update_age_infecteds)[1], ]\n\n# Estimate R0 using the equilibrium values and how long people stay in each age group\nsum(ages * update_age_infecteds_equil / sum(update_age_infecteds_equil))\n\n[1] 6.076599\n\nCodesum(update_age_infecteds_equil[15:23])\n\n[1] 0.5441408\n\n\n\nCodeupdate_age_df &lt;- as_tibble(update_age_sol) %&gt;%\n    mutate(across(everything(), as.numeric)) %&gt;%\n    pivot_longer(\n        cols = -time,\n        names_to = c(\"state\", \"age_index\"),\n        names_pattern = \"(.)(.*)\",\n        values_to = \"number\"\n    ) %&gt;%\n    mutate(\n        age = ages[as.integer(age_index)],\n        state = factor(state, labels = c(\"S\", \"I\", \"R\")),\n    )\n\n\n\nCodeggplot(update_age_df, aes(x = time, y = number, color = age, group = age)) +\n    geom_line(linewidth = 1) +\n    facet_wrap(~state, ncol = 1, scale = \"free_y\") +\n    labs(\n        x = \"Time\",\n        y = \"Number of individuals\",\n        color = \"Age\"\n    ) +\n    scale_color_continuous(low = age_group_colors[1], high = age_group_colors[2])"
  },
  {
    "objectID": "r-session-02.html#r0-and-the-mean-age-of-infection",
    "href": "r-session-02.html#r0-and-the-mean-age-of-infection",
    "title": "\n7  R Session 02\n",
    "section": "\n7.5 R0 and the mean age of infection",
    "text": "7.5 R0 and the mean age of infection\nTo first investigate the relationship between \\(R_0\\) and the mean age of infection, we will assume that the population is completely susceptible and that the force of infection is constant. We’ll also assume that there is heterogenous mixing i.e. no age structure.\nAs we’ve seen, we can calculate the mean age of infection using the equation below:\n\\[\nA \\approx \\frac{L}{R_E - 1}\n\\tag{7.1}\\]\nwhere \\(L\\) is the life expectancy \\(\\left(L = \\frac{1}{\\mu}\\right)\\) and \\(R_E\\) is the effective reproductive number (\\(R_E = R_0 * (1 - p)\\) where \\(p\\) is the fraction of individuals vaccinated).\n\n7.5.1 Interactive Plot\n\n\nCodeviewof R0 = Inputs.range(\n    [1.0, 10.0],\n    {value: 2.0, step: 0.01, label: md`${tex`R_0`}`}\n)\n\nviewof vacc = Inputs.range(\n    [0.0, 1.0],\n    {value: 0.0, step: 0.01, label: \"Vaccination coverage\"}\n)\n\nviewof lifeexp = Inputs.range(\n    [50, 100],\n    {value: 75, step: 1, label: \"Life expectancy\"}\n)\n\nmd`${tex`R_E = ${Re_str}`}`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodemd`${tex`\\text{Mean age of infection} = ${Re_mean_age_str}`}`\n\n\n\n\n\n\n\n\n\n\nCodeRe = R0 * (1 - vacc)\nRe_str = Re.toPrecision(4).toLocaleString()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodefunction calc_mean_age(Re, lifeexp) {\n    if(Re &gt;= 1) {\n        var mean_age = (lifeexp / (Re - 1))\n    } else {\n        var mean_age = Infinity\n    }\n    return mean_age\n}\n\n\n\n\n\n\n\nCodeR0_mean_age = calc_mean_age(R0, lifeexp)\nRe_mean_age = calc_mean_age(Re, lifeexp)\nRe_mean_age_str = Re_mean_age.toPrecision(4).toLocaleString()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodeimport { aq, op } from '@uwdata/arquero'\n\n\n\n\n\n\n\nCodefunction calc_mean_age_arr(vacc, lifeexp, R0_min, R0_max, dR0) {\n    var R0_sim = R0_min\n\n    var R0 = []\n    var Re = []\n    var R0_mean_age = []\n    var Re_mean_age = []\n\n    for (R0_sim = R0_min; R0_sim &lt;= R0_max; R0_sim += dR0) {\n        var Re_sim = R0_sim * (1 - vacc)\n        var R0_mean_age_sim = calc_mean_age(R0_sim, lifeexp)\n        var Re_mean_age_sim = calc_mean_age(Re_sim, lifeexp)\n\n        R0.push(R0_sim)\n        Re.push(Re_sim)\n        R0_mean_age.push(R0_mean_age_sim)\n        Re_mean_age.push(Re_mean_age_sim)\n    }\n\n    return {\n        Re: aq.table({\n                R0: R0,\n                mean_age: Re_mean_age\n            }).filter((d) =&gt; d.mean_age &lt;= 100),\n        R0: aq.table({\n                R0: R0,\n                mean_age: R0_mean_age\n            }).filter((d) =&gt; d.mean_age &lt;= 100)\n    }\n}\n\n\n\n\n\n\n\nCodemean_age_arrs = calc_mean_age_arr(vacc, lifeexp, 1.0, 10.0, 0.01)\n\n\n\n\n\n\n\nCodemean_age_dots = [({\n    arrow_start: R0_mean_age &lt;= 100 ? R0_mean_age : 100,\n    arrow_end: Re_mean_age &lt;= 100 ? Re_mean_age : 100,\n    R0: R0.toPrecision(3),\n    Re: Re.toPrecision(3),\n    R0_mean_age,\n    Re_mean_age\n})]\n\n\n\n\n\n\n\n\n\nCode{\n    let R0Color = \"#1f77b4\"\n    let ReColor = \"#ff7f0e\"\n\n    let plot = Plot.plot({\n        color: {\n            legend: true,\n            domain: [\"Unvaccinated\", \"Vaccinated\"],\n            range: [\"#1f77b4\", \"#ff7f0e\"]\n        },\n        style: {fontSize: \"20px\"},\n        marginLeft: 65,\n        marginTop: 40,\n        marginBottom: 55,\n        grid: true,\n        width: 800,\n        height: 670,\n        x: {label: \"R0\", domain: [0, 10]},\n        y: {label: \"Mean Age of Infection\", domain: [0, 100]},\n        marks: [\n            Plot.line(mean_age_arrs.R0, {x: \"R0\", y: \"mean_age\", stroke: R0Color, strokeWidth: 6}),\n            Plot.line(mean_age_arrs.Re, {x: \"R0\", y: \"mean_age\", stroke: ReColor, strokeWidth: 6}),\n            R0_mean_age &lt;= 100 ?\n                [\n                Plot.dot(mean_age_dots, {x: \"R0\", y: \"R0_mean_age\", r: 12, stroke: R0Color, fill: R0Color, fillOpacity: 0.6}),\n                Plot.text(\n                    mean_age_dots,\n                    {x: \"R0\", y: \"R0_mean_age\", text: (d) =&gt; `R0 = ${d.R0}`, dx: -60, dy: 30, fontWeight:     \"bold\", fill: R0Color}\n                )\n                ] :\n            null,\n            Re_mean_age &lt;= 100 ?\n                [\n                    Plot.dot(mean_age_dots, {x: \"R0\", y: \"Re_mean_age\", r: 12, stroke: ReColor, fill:     ReColor,  fillOpacity: 0.6}),\n                    Plot.text(\n                        mean_age_dots,\n                        {x: \"R0\", y: \"Re_mean_age\", text: (d) =&gt; `Re = ${d.Re}`, dx: 55, dy: -25,   fontWeight:     \"bold\", fill: ReColor}\n                    )\n                ] :\n            null,\n            Plot.arrow(mean_age_dots, {x1: \"R0\", x2: \"R0\", y1: \"arrow_start\", y2: \"arrow_end\", strokeWidth: 4, headLength: 5, inset: 15}),\n        ]\n    });\n\n  return plot;\n}\n\n\n\n\n\n\n\n\n\n\n\n7.5.2 R Code\nNow let’s look at how we can investigate this using R. Unlike the interactive plot that simply uses Equation 7.1 to calculate the mean age of infection, let’s use a more realistic age-structured model. For simplicity, let’s return to the earlier models with a simple age-class mixing matrix. But this time, we’ll calculate \\(R_0\\), the mean age of infection, and the number of cases between 15-35 years as we increase the rate of contact. Recall from the rubella and CRS example that the risk of severe disease outcomes depends on the risk of infection in reproductive age women. Recall also that increasing vaccination reduces \\(R_E\\) – so here we’ll evalate at several values of \\(R_0\\) as a proxy for the impact of vaccination. We’ll then calculate how the mean age of infection changes, and specifically how the absolute number of cases among individuals between the ages of 15-35 (as a proxy for reproductive age women) changes. To do so, we’ll make a loop and evaluate the code for each of 10 increasing levels of mixing (which whill change R0)\n\nCodescale_contact &lt;- seq(0.2, 1, length = 10)\nbeta_low &lt;- 0.007\nbeta_medium &lt;- 0.02\nbeta_high &lt;- 0.03\n\nbeta_mat &lt;- matrix(beta_low, nrow = 30, ncol = 30)\nbeta_mat[1:20, 1:20] &lt;- beta_medium\nbeta_mat[6:16, 6:16] &lt;- beta_high\n\n\n\nCodeR0_mean_age_contacts_df &lt;- map_dfr(\n    .x = scale_contact,\n    .f = function(.x) {\n        # Scale contacts\n        scaled_beta_mat &lt;- beta_mat * .x\n\n        # Set up parameters\n        scaled_params &lt;- list(\n            beta_mat = scaled_beta_mat,\n            recovery = multistage_params[[\"recovery\"]],\n            aging_mat = multistage_params[[\"aging_mat\"]],\n            births = multistage_params[[\"births\"]]\n        )\n\n        # Solve the model\n        sol &lt;- deSolve::ode(\n            y = demog_yinit_ages,\n            times = seq(0, 400, by = 0.1),\n            func = multistage_model,\n            parms = scaled_params\n        )\n\n        # Get stable age distribution\n        stable_n &lt;- solve(\n            scaled_params[[\"aging_mat\"]],\n            -c(scaled_params[[\"births\"]], rep(0, 29))\n        )\n        \n        # Calculate R0 with NGM\n        F &lt;- diag(stable_n) %*% scaled_params[[\"beta_mat\"]] +\n            scaled_params[[\"aging_mat\"]] -\n            diag(diag(scaled_params[[\"aging_mat\"]]))\n\n        V &lt;- diag(scaled_params[[\"recovery\"]] -\n            diag(scaled_params[[\"aging_mat\"]]))\n\n        R0 &lt;- max(\n            Re(\n                eigen(solve(V, F), only.values = TRUE)$values\n            )\n        )\n\n        # Get final number of infected individuals for each I class\n        infecteds &lt;- sol[dim(sol)[1], 1 + iindex]\n\n        # Calculate mean age of infection\n        mean_age &lt;- sum(ages * infecteds / sum(infecteds))\n\n        # Calculate sum of cases between 15-35 years\n        sum_cases &lt;- sum(infecteds[15:23])\n\n        # Return a dataframe with the values\n        return(tibble(R0, mean_age, sum_cases))\n    }\n)\n\n\nNow we can make a table of the results and plot mean age and the sum of cases between 15-35 years of age as a function of \\(R_0\\).\n\nCodegt(R0_mean_age_contacts_df) %&gt;%\n    fmt_number(\n        columns = everything(),\n        decimals = 2\n    ) %&gt;%\n    cols_label(\n        R0 = md(\"**R0**\"),\n        mean_age = md(\"**Mean age of&lt;br&gt;infection**\"),\n        sum_cases = md(\"**Total cases between&lt;br&gt;15-35 years**\")\n    ) %&gt;%\n    opt_stylize(style = 1, color = 'gray') %&gt;%\n    opt_horizontal_padding(scale = 3) %&gt;%\n    cols_align(\"center\")\n\n\n\n\n\n\nR0\n      Mean age ofinfection\n      Total cases between15-35 years\n    \n\n\n1.35\n29.72\n1.48\n\n\n1.92\n21.50\n2.11\n\n\n2.50\n16.40\n2.01\n\n\n3.07\n13.11\n1.74\n\n\n3.65\n10.87\n1.45\n\n\n4.22\n9.30\n1.20\n\n\n4.80\n8.15\n0.98\n\n\n5.38\n7.28\n0.81\n\n\n5.95\n6.61\n0.66\n\n\n6.53\n6.08\n0.54\n\n\n\n\n\n\n\nCodeR0_mean_age_contacts_df %&gt;%\n    pivot_longer(-R0, names_to = \"metric\", values_to = \"value\") %&gt;%\n    ggplot(aes(x = R0, y = value)) +\n    geom_line(color = \"slategray4\") +\n    geom_point(shape = 21, size = 5, fill = \"slategray4\", alpha = 0.8) +\n    facet_wrap(\n        ~metric,\n        scales = \"free_y\",\n        labeller = as_labeller(c(\n            mean_age = \"Mean Age of Infection\",\n            sum_cases = \"Total cases between 15-35 years\"\n        ))\n    ) +\n    labs(\n        x = \"R0\",\n        y = \"Value\"\n    )\n\n\n\n\n\n7.5.3 Exercise 5: Try the same as you fix \\(R_0\\) but change the birth rate (as if new infants were vaccinated), instead of changing the contact rate.\nFor example, if the birth rate was 100 before, try using a sequence of birth rates ranging from 100 (i.e. no new infants are vaccinated) to 75 (i.e., 25% of new infants are vaccinated). You can use the technique we used above, where we ran the simulation in a loop multiple times, for varying levels of contact, modifying it to run on varying levels of births (e.g., between 75 and 100).\n\nCodebirths_seq &lt;- seq(75, 100, length = 10)\n\n\n\nCodeR0_mean_age_births_df &lt;- map_dfr(\n    .x = births_seq,\n    .f = function(.x) {\n\n        # Set up parameters\n        births_params &lt;- list(\n            beta_mat = beta_mat,\n            recovery = multistage_params[[\"recovery\"]],\n            aging_mat = multistage_params[[\"aging_mat\"]],\n            births = .x\n        )\n\n        # Solve the model\n        sol &lt;- deSolve::ode(\n            y = demog_yinit_ages,\n            times = seq(0, 400, by = 0.1),\n            func = multistage_model,\n            parms = births_params\n        )\n\n        # Get stable age distribution\n        stable_n &lt;- solve(\n            births_params[[\"aging_mat\"]],\n            -c(births_params[[\"births\"]], rep(0, 29))\n        )\n        \n        # Calculate R0 with NGM\n        F &lt;- diag(stable_n) %*% births_params[[\"beta_mat\"]] +\n            births_params[[\"aging_mat\"]] -\n            diag(diag(births_params[[\"aging_mat\"]]))\n\n        V &lt;- diag(births_params[[\"recovery\"]] -\n            diag(births_params[[\"aging_mat\"]]))\n\n        R0 &lt;- max(\n            Re(\n                eigen(solve(V, F), only.values = TRUE)$values\n            )\n        )\n\n        # Get final number of infected individuals for each I class\n        infecteds &lt;- sol[dim(sol)[1], 1 + iindex]\n\n        # Calculate mean age of infection\n        mean_age &lt;- sum(ages * infecteds / sum(infecteds))\n\n        # Calculate sum of cases between 15-35 years\n        sum_cases &lt;- sum(infecteds[15:23])\n\n        # Return a dataframe with the values\n        return(tibble(births = .x, R0, mean_age, sum_cases))\n    }\n)\n\n\n\nCodegt(R0_mean_age_births_df) %&gt;%\n    fmt_number(\n        columns = everything(),\n        decimals = 2\n    ) %&gt;%\n    cols_label(\n        births = md(\"**Birth rate**\"),\n        R0 = md(\"**R0**\"),\n        mean_age = md(\"**Mean age of&lt;br&gt;infection**\"),\n        sum_cases = md(\"**Total cases between&lt;br&gt;15-35 years**\")\n    ) %&gt;%\n    opt_stylize(style = 1, color = 'gray') %&gt;%\n    opt_horizontal_padding(scale = 3) %&gt;%\n    cols_align(\"center\")\n\n\n\n\n\n\nBirth rate\n      R0\n      Mean age ofinfection\n      Total cases between15-35 years\n    \n\n\n75.00\n4.91\n7.96\n0.71\n\n\n77.78\n5.09\n7.68\n0.69\n\n\n80.56\n5.27\n7.43\n0.67\n\n\n83.33\n5.45\n7.19\n0.65\n\n\n86.11\n5.63\n6.97\n0.64\n\n\n88.89\n5.81\n6.76\n0.62\n\n\n91.67\n5.99\n6.57\n0.60\n\n\n94.44\n6.17\n6.40\n0.58\n\n\n97.22\n6.35\n6.23\n0.56\n\n\n100.00\n6.53\n6.08\n0.54\n\n\n\n\n\n\n\nCodeR0_mean_age_births_df_long &lt;- R0_mean_age_births_df %&gt;%\n    pivot_longer(c(mean_age, sum_cases), names_to = \"metric\", values_to = \"value\") \n\n\n\nCodeR0_mean_age_births_df_long %&gt;%\n    ggplot(aes(x = R0, y = value)) +\n    geom_line(color = \"slategray4\") +\n    geom_point(shape = 21, size = 5, fill = \"slategray4\", alpha = 0.8) +\n    facet_wrap(\n        ~metric,\n        scales = \"free_y\",\n        labeller = as_labeller(c(\n            mean_age = \"Mean Age of Infection\",\n            sum_cases = \"Total cases between 15-35 years\"\n        ))\n    ) +\n    labs(\n        x = \"R0\",\n        y = \"Value\"\n    )\n\n\n\n\n\nCodeR0_mean_age_births_df_long %&gt;%\n    ggplot(aes(x = births, y = value)) +\n    geom_line(color = \"slategray4\") +\n    geom_point(shape = 21, size = 5, fill = \"slategray4\", alpha = 0.8) +\n    facet_wrap(\n        ~metric,\n        scales = \"free_y\",\n        labeller = as_labeller(c(\n            mean_age = \"Mean Age of Infection\",\n            sum_cases = \"Total cases between 15-35 years\"\n        ))\n    ) +\n    labs(\n        x = \"Births\",\n        y = \"Value\"\n    )"
  },
  {
    "objectID": "r-session-02.html#what-do-real-contact-networks-look-like",
    "href": "r-session-02.html#what-do-real-contact-networks-look-like",
    "title": "\n7  R Session 02\n",
    "section": "\n7.6 What do real contact networks look like?",
    "text": "7.6 What do real contact networks look like?\nThe POLYMOD study Mossong, 2008 was a journal-based look into the contact network in contemporary European society. Let’s have a look what these data tell us about the contact structure.\n\nCodemossong_cont_net &lt;- read.csv(\n    url(\"http://www.math.mcmaster.ca/~bolker/eeid/data/mossong.csv\"),\n    as.is = TRUE\n)\n\nmossong_ages &lt;- unique(mossong_cont_net$contactor)\nmossong_cont_net$contactor &lt;- ordered(mossong_cont_net$contactor, levels = mossong_ages)\nmossong_cont_net$contactee &lt;- ordered(mossong_cont_net$contactee, levels = mossong_ages)\n\n\nSince contacts are symmetric, we’ll need to estimate the symmetric contact matrix.\n\nCodemossong_mat &lt;- mossong_cont_net %&gt;%\n    pivot_wider(\n        names_from = contactor,\n        values_from = contact.rate\n    ) %&gt;%\n    select(-contactee) %&gt;%\n    as.matrix()\n\nrownames(mossong_mat) &lt;- mossong_ages\n\nmossong_mat_sym &lt;- (mossong_mat + t(mossong_mat)) / 2\n\n\nHere we’ll use the filled.contour function to visualize the contact matrix, to show you an alternative way of visualizing contact matrices. Notices that we are using the raw matrix object, not a long dataframe, as previously.\n\nCodefilled.contour(\n    ages, ages, log10(mossong_mat),\n    plot.title = title(\n        main = \"Log10 of raw contact rate\",\n        xlab = \"Age of contactor\",\n        ylab = \"Age of contactee\"\n    )\n)\n\n\n\n\n\nCodefilled.contour(\n    ages, ages, log10(mossong_mat_sym),\n    plot.title = title(\n        main = \"Log10 of symmetrical contact rate\",\n        xlab = \"Age of contactor\",\n        ylab = \"Age of contactee\"\n    )\n)\n\n\n\n\n\nCodemossong_cont_sums &lt;- tibble(\n        age = factor(mossong_ages, levels = mossong_ages),\n        contactees = rowSums(mossong_mat),\n        contactors = colSums(mossong_mat)\n    ) %&gt;%\n    pivot_longer(-age, names_to = \"type\", values_to = \"total_contacts\") \n\n\n\nCodeggplot(\n        mossong_cont_sums,\n        aes(x = age, y = total_contacts, color = type, fill = type, group = type)\n    ) +\n    geom_path(linewidth = 1) +\n    geom_point(\n        position = \"identity\",\n        alpha = 0.8,\n        shape = 21,\n        size = 4\n    ) +\n    scale_color_manual(\n        values = c(\"slategray4\", \"navy\"),\n        labels = c(\"Contactees\", \"Contactors\"),\n        aesthetics = c(\"color\", \"fill\")\n    ) +\n    guides(color = \"none\") +\n    labs(\n        x = \"Age\",\n        y = \"Total contacts\",\n        fill = \"Type of contact\"\n    ) +\n    theme(legend.position = \"bottom\")\n\n\n\n\nWhile this matrix tells us how many contacts are made per year by an individual of each age, it doesn’t tell us anything about the probability that a contact results in communication of infection. Let’s assume that each contact has a constant probability \\(q\\) of resulting in a transmission event.\n\nCodeq &lt;- 3e-5\nmossong_beta_mat &lt;- q * mossong_mat_sym\n\n\n\nCodefilled.contour(\n    ages, ages, log10(mossong_beta_mat),\n    plot.title = title(\n        main = \"WAIFW matrix based on POLYMOD data\",\n        xlab = \"Age\",\n        ylab = \"Age\"\n    )\n)\n\n\n\n\nNow let’s simulate the introduction of such a pathogen into a population characterized by this contact structure.\n\nCodemossong_sol &lt;- deSolve::ode(\n    y = demog_yinit_ages,\n    times = seq(0, 200, by = 0.5),\n    func = multistage_model,\n    parms = multistage_params\n)\n\nmossong_infecteds &lt;- mossong_sol[, 1 + iindex]\n\nmossong_infecteds_df &lt;- tibble(\n        time = mossong_sol[, 1],\n        Juveniles = apply(mossong_infecteds[, juvies], 1, sum),\n        Adults = apply(mossong_infecteds[, adults], 1, sum)\n    ) %&gt;%\n    pivot_longer(\n        cols = c(Juveniles, Adults),\n        names_to = \"age_group\",\n        values_to = \"infections\"\n    ) %&gt;%\n    mutate(\n        age_group = factor(age_group, levels = c(\"Juveniles\", \"Adults\"))\n    )\n\n\n\nCodeggplot(mossong_infecteds_df, aes(x = time, y = infections, color = age_group)) +\n    geom_line(linewidth = 1.5) +\n    scale_color_manual(\n        values = age_group_colors\n    ) +\n    labs(\n        x = \"Time\",\n        y = \"Number of infections\",\n        color = \"Age group\"\n    )\n\n\n\n\nAs before, we can also look at the equilibrium seroprevalence\n\nCodemossong_equil &lt;- drop(tail(mossong_sol, 1))[-1]\n\nmossong_equil_n &lt;- mossong_equil[sindex] +\n    mossong_equil[iindex] +\n    mossong_equil[rindex]\n\nmossong_equil_seroprev &lt;- mossong_equil[rindex] / mossong_equil_n\n\nmossong_equil_seroprev_df &lt;- tibble(\n    # We can reuse the ages vectors from before as they are the same\n    # as the POLYMOD data\n    age = ages,\n    seroprev = mossong_equil_seroprev,\n    width = da_ages\n)\n\n\n\nCodeggplot(mossong_equil_seroprev_df, aes(x = age, y = seroprev, fill = age)) +\n    geom_col(width = mossong_equil_seroprev_df$width, just = 1.0, color = \"black\") +\n    labs(\n        x = \"Age\",\n        y = \"Seroprevalence\"\n    ) +\n    scale_x_continuous(breaks = seq(0, 80, 10)) +\n    scale_fill_continuous(low = age_group_colors[1], high = age_group_colors[2])\n\n\n\n\nand compute the \\(R_0\\) for this infection.\n\nCoden_p &lt;- solve(\n    multistage_params[[\"aging_mat\"]],\n    -c(multistage_params[[\"births\"]], rep(0, 29))\n)\n\nF_p &lt;- diag(n_p) %*% multistage_params[[\"beta_mat\"]] +\n    multistage_params[[\"aging_mat\"]] -\n    diag(diag(multistage_params[[\"aging_mat\"]]))\n\nV_p &lt;- diag(\n    multistage_params[[\"recovery\"]] -\n        diag(multistage_params[[\"aging_mat\"]])\n    )\n\nmax(\n    Re(\n        eigen(solve(V_p, F_p),only.values=T)$values\n    )\n)\n\n[1] 6.792003\n\n\n\n\n\n\n\n\nImportant\n\n\n\nNeed to check what’s going on here as just recycling previous code and doesn’t depend on Mossong Matrix.\n\n\nHow does this R0 value compare to the R0 value obtained from Exercise 4?"
  },
  {
    "objectID": "r-session-02.html#bonus-calculating-r0-using-a-next-generation-matrix",
    "href": "r-session-02.html#bonus-calculating-r0-using-a-next-generation-matrix",
    "title": "\n7  R Session 02\n",
    "section": "\n7.7 Bonus: Calculating R0 Using a Next Generation Matrix",
    "text": "7.7 Bonus: Calculating R0 Using a Next Generation Matrix\nThe next generation matrix is a matrix that specifies how many new age-specific infections are generated by a typical infected individual of each age class (in a fully susceptible population). For example, let’s consider an infected adult and ask how many new juvenile infections it generates: this is the product of the number of susceptible juveniles (from the stable age distribution), the per capita transmission rate from adults to juveniles and the average duration of infection, i.e. \\(S_J^* \\times \\beta_{JA} \\times 1/ (\\gamma+\\mu)\\). This forms one element of our next generation matrix. The other elements look very similar, except there are extra terms when we consider an infected juvenile because there is a (very small) chance they may age during the infectious period and therefore cause new infections as an adult:\n\\[\n\\mathrm{NGM} = \\begin{pmatrix}\n        \\frac{S_J^* \\beta_{JJ}}{(\\gamma + \\alpha)} +\n        \\frac{\\alpha}{(\\gamma+\\mu)} \\frac{S_J^* \\beta_{JA}}{(\\gamma + \\mu)} &\n        \\frac{S_J^* \\beta_{JA}}{(\\gamma + \\mu)} \\\\\n        \\frac{S_A^* \\beta_{AJ}}{(\\gamma + \\alpha)} +\n            \\frac{\\alpha}{(\\gamma + \\mu)} \\frac{S_A^*\\beta_{AA}}{(\\gamma+\\mu)} &\n            \\frac{S_A^* \\beta_{AA}}{(\\gamma + \\mu)}\n    \\end{pmatrix}\n\\tag{7.2}\\]\n\\(R_0\\) can then be computed as the dominant eigenvalue (i.e., the one with the largest real part) of this matrix. Let’s take an example from a model with 2 age classes, from above. First, let’s define the components of the next generation matrix:\n\nCodengm_params &lt;- c(\n    beta_within = 0.011,\n    beta_between = 0.005,\n    age_band_j = 20,\n    age_band_a = 60,\n    recovery = 10\n)\n\nalpha_ngm &lt;- 1 / ngm_params[\"age_band_j\"]\nmu_ngm &lt;- 1 / ngm_params[\"age_band_a\"]\nn_ngm &lt;- demog_params[\"births\"] / c(alpha_ngm, mu_ngm)\n\nbeta_ngm &lt;- matrix(c(\n    ngm_params[\"beta_within\"],\n    ngm_params[\"beta_between\"],\n    ngm_params[\"beta_between\"],\n    ngm_params[\"beta_within\"]\n    ),\n    nrow = 2,\n    ncol = 2\n)\n\n\nThe Next Generation Matrix can be calculated in R as:\n\nCodengm &lt;- matrix(\n    c(\n        n_ngm[1] * (beta_ngm[1, 1] / (ngm_params[\"recovery\"] + alpha_ngm)) +\n            alpha_ngm / (ngm_params[\"recovery\"] + mu_ngm) *\n            n_ngm[1] * beta_ngm[1, 2] / (ngm_params[\"recovery\"] + mu_ngm),\n        \n        n_ngm[2] * beta_ngm[2, 1] / (ngm_params[\"recovery\"] + alpha_ngm) +\n            alpha_ngm / (ngm_params[\"recovery\"] + mu_ngm) *\n            n_ngm[2] * (beta_ngm[2, 2] / (ngm_params[\"recovery\"] + mu_ngm)),\n\n        n_ngm[1] * beta_ngm[1, 2] / (ngm_params[\"recovery\"] + mu_ngm),\n\n        n_ngm[2] * beta_ngm[2, 2] / (ngm_params[\"recovery\"] + mu_ngm)\n    ),\n    nrow = 2,\n    ncol = 2\n)\n\n\nWe can then calculate the eigenvalues and eigenvectors of this matrix:\n\nCodeeigen(ngm)\n\neigen() decomposition\n$values\n[1] 7.191869 1.591188\n\n$vectors\n           [,1]       [,2]\n[1,] -0.1958841 -0.8560336\n[2,] -0.9806271  0.5169202\n\n\nWe can also choose to just output the eigenvalues:\n\nCodeeigen(ngm, only.values = TRUE)\n\n$values\n[1] 7.191869 1.591188\n\n$vectors\nNULL\n\n\nFinally, let’s print \\(R_0\\):\n\nCodemax(\n    Re(\n        eigen(ngm, only.values = TRUE)$values\n    )\n)\n\n[1] 7.191869\n\n\n\n\n\n\n\n\nBjørnstad, Ottar N. 2018. “Advanced: The Next-Generation Matrix.” In Epidemics: Models and Data Using R, 51. Use R! Cham: Springer International Publishing. https://doi.org/10.1007/978-3-319-97487-3.\n\n\nDiekmann, O., and J. A. P. Heesterbeek. 2000. In Mathematical Epidemiology of Infectious Diseases: Model Building, Analysis and Interpretation. Wiley Series in Mathematical & Computational Biology. Wiley. https://books.google.ca/books?id=5VjSaAf35pMC.\n\n\nHeesterbeek, J. A. P. 2002. “A Brief History of R0 and a Recipe for Its Calculation.” Acta Biotheoretica 50 (3): 189–204. https://doi.org/10.1023/A:1016599411804.\n\n\nHeffernan, J. M, R. J Smith, and L. M Wahl. 2005. “Perspectives on the Basic Reproductive Ratio.” J R Soc Interface 2 (4): 281–93. https://doi.org/10.1098/rsif.2005.0042.\n\n\nHurford, Amy, Daniel Cownden, and Troy Day. 2009. “Next-Generation Tools for Evolutionary Invasion Analyses.” Journal of The Royal Society Interface 7 (45): 561–71. https://doi.org/10.1098/rsif.2009.0448."
  },
  {
    "objectID": "r-session-03.html#estimating-r_0",
    "href": "r-session-03.html#estimating-r_0",
    "title": "\n9  R Session 03\n",
    "section": "\n9.1 Estimating \\(R_0\\)\n",
    "text": "9.1 Estimating \\(R_0\\)\n\nSo far in this class we have focused on the theory of infectious disease. Often, however, we will want to apply this theory to particular situations. One of the key applied problems in epidemic modeling is the estimation of \\(R_0\\) from outbreak data. In this session, we study two methods for estimating \\(R_0\\) from an epidemic curve. As a running example, we will use the data on influenza in a British boarding school.\n\nCodeload(here::here(\"data\", \"R-estimation-data.RData\"))\n\nplot(\n  flu,\n  type = 'b',\n  log = 'y',\n  main = 'Epidemic in a British boarding school',\n  cex.main=0.85,\n  xlab='Day',\n  ylab='Active influenza cases'\n)"
  },
  {
    "objectID": "r-session-03.html#estimating-r_0-from-the-final-outbreak-size",
    "href": "r-session-03.html#estimating-r_0-from-the-final-outbreak-size",
    "title": "\n9  R Session 03\n",
    "section": "\n9.2 Estimating \\(R_0\\) from the final outbreak size",
    "text": "9.2 Estimating \\(R_0\\) from the final outbreak size\nOur first approach is to estimate \\(R_0\\) from the final outbreak size. Although unhelpful at the early stages of an epidemic (before the final epidemic size is observed), this method is nonetheless a useful tool for \\({post hoc}\\) analysis. The method is general and can be motivated by the following argument (Keeling and Rohani 2007): First, we assume that the epidemic is started by a single infectious individual in a completely susceptible population. On average, this individual infects \\(R_0\\) others. The probability a particular individual escaped infection is therefore \\(e^{-R_0/N}\\). If \\(Z\\) individuals have been infected, the probability of an individual escaping infection from all potential sources is \\(e^{-ZR_0/N}\\). It follows that at the end of the epidemic a proportion \\(R(\\infty)=Z/N\\) have been infected and the fraction remaining susceptible is \\(S(\\infty)=e^{-R(\\infty)R_0}\\), which is equal to \\(1-R(\\infty)\\), giving\n\\[\n  \\label{R0-estimator}\n  1 - R(\\infty) - e^{-R(\\infty)R_0} = 0\n\\]\nRearranging, we have the estimator\n\\[\n  \\label{R0-estimator-2}\n  \\hat{R_0} = \\frac{log(1-Z/N)}{-Z/N},\n\\]\nwhich, in this case, evaluates to \\(\\frac{log(1-512/764)}{-512/764} = 1.655\\).\n\n9.2.1 Exercise 1\nThis equation shows the important one-to-one relationship between \\(R_0\\) and the final epidemic size. Plot the relationship between the total epidemic size and \\(R_0\\) for the complete range of values between 0 and 1."
  },
  {
    "objectID": "r-session-03.html#linear-approximation",
    "href": "r-session-03.html#linear-approximation",
    "title": "\n9  R Session 03\n",
    "section": "\n9.3 Linear Approximation",
    "text": "9.3 Linear Approximation\nThe next method we introduce takes advantage of the fact that during the early stages of an outbreak, the number of infected individuals is given approximately as \\(Y(t) \\approx Y_0 e^{((R_0-1)(\\gamma + \\mu)t)}\\). Taking logarithms of both sides, we have \\(log(Y(t)) \\approx log(Y_0) + (R_0-1)(\\gamma + \\mu)t\\), showing that the log of the number of infected individuals is approximately linear in time with a slope that reflects both \\(R_0\\) and the recovery rate.\nThis suggests that a simple linear regression fit to the first several data points on a log-scale, corrected to account for \\(\\gamma\\) and \\(\\mu\\), provides a rough and ready estimate of \\(R_0\\). For flu, we can assume \\(\\mu =0\\) because the epidemic occurred over a time period during which natural mortality is negligible. Further, assuming an infectious period of about 2.5 days, we use \\(\\gamma = (2.5)^{-1} = 0.4\\) for the correction. Fitting to the first four data points, we obtain the slope as follows.\n\nCodemodel &lt;- lm(log(flu[1:4]) ~ day[1:4], data = flu);  #fit a linear model\nsummary(model)         #summary statistics for fit model\n\n\nCall:\nlm(formula = log(flu[1:4]) ~ day[1:4], data = flu)\n\nResiduals:\n       1        2        3        4 \n 0.03073 -0.08335  0.07450 -0.02188 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)   \n(Intercept) -0.02703    0.10218  -0.265  0.81611   \nday[1:4]     1.09491    0.03731  29.346  0.00116 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.08343 on 2 degrees of freedom\nMultiple R-squared:  0.9977,    Adjusted R-squared:  0.9965 \nF-statistic: 861.2 on 1 and 2 DF,  p-value: 0.001159\n\nCodeslope &lt;- coef(model)[2]  #extract slope parameter\nslope                 #print to screen\n\nday[1:4] \n1.094913 \n\n\nRearranging the linear equation above and denoting the slope coefficient by \\(\\hat \\beta_1\\) we have the estimator \\(\\hat R_0 = \\hat \\beta_1 / \\gamma +1\\) giving \\(\\hat R_0=1.094913/0.4+1 \\approx 3.7\\).\n\n9.3.1 Exercise 2\nOur estimate assumes that boys remained infectious during the natural course of infection. The original report on this epidemic indicates that boys found to have symptoms were immediately confined to bed in the infirmary. The report also indicates that only 1 out of 130 adults at the school exhibited any symptoms. It is reasonable, then, to suppose that transmission in each case ceased once he had been admitted to the infirmary. Supposing admission happened within 24 hours of the onset of symptoms. How does this affect our estimate of \\(R_0\\)? Twelve hours?\n\n9.3.2 Exercise 3\nBiweekly data for outbreaks of measles in three communities in Niamey, Niger are provided in the dataframe \\(\\tt niamey\\). Use this method to obtain estimates of \\(R_0\\) for measles from the first community assuming that the infectious period is approximately two weeks or \\(14/365 \\approx 0.0384\\) years.\n\n9.3.3 Exercise 4\nA defect with this method is that it uses only a small fraction of the information that might be available, i.e., the first few data points. Indeed, there is nothing in the method that tells one how many data points to use–this is a matter of judgment. Further, there is a tradeoff in that as more and more data points are used the precision of the estimate increases, but this comes at a cost of additional bias. Plot the estimate of \\(R_0\\) obtained from \\(n=3, 4, 5, ...\\) data points against the standard error of the slope from the regression analysis to show this tradeoff."
  },
  {
    "objectID": "r-session-03.html#estimating-dynamical-parameters-with-least-squares",
    "href": "r-session-03.html#estimating-dynamical-parameters-with-least-squares",
    "title": "\n9  R Session 03\n",
    "section": "\n9.4 Estimating dynamical parameters with least squares",
    "text": "9.4 Estimating dynamical parameters with least squares\nThe objective of the previous exercise was to estimate \\(R_0\\). Knowing \\(R_0\\) is critical to understanding the dynamics of any epidemic system. It is, however, a composite quantity and is not sufficient to completely describe the epidemic trajectory. For this, we require estimates for all parameters of the model. In this exercise, we introduce a simple approach to model estimation called least squares fitting, sometimes called trajectory matching. The basic idea is that we find the values of the model parameters that minimize the squared differences between model predictions and the observed data. To demonstrate least squares fitting, we consider an outbreak of measles in Niamey, Niger, reported on by Grais et al. 2006 (Grais, R.F., et al. 2006. Estimating transmission intensity for a measles outbreak in Niamey, Niger: lessons for intervention. Transactions of the Royal Society of Tropical Medicine and Hygiene 100:867-873.).\n\nCodeniamey[5,3] &lt;- 0  #replace a \"NA\"\nniamey &lt;- data.frame(\n  biweek = rep(seq(1, 16), 3),\n  site = c(rep(1, 16), rep(2, 16), rep(3, 16)),\n  cases = c(niamey[, 1], niamey[, 2], niamey[, 3])\n) #define \"biweeks\"\n\n\n\nCodeplot(\n  niamey$biweek,\n  niamey$cases,\n  type='p',\n  col = niamey$site,\n  xlab = 'Biweek',\n  ylab = 'Cases'\n)\n\nlines(niamey$biweek[niamey$site == 1], niamey$cases[niamey$site == 1]) \nlines(niamey$biweek[niamey$site == 2], niamey$cases[niamey$site == 2],col = 2)\nlines(niamey$biweek[niamey$site == 3], niamey$cases[niamey$site == 3],col = 3)"
  },
  {
    "objectID": "r-session-03.html#dynamical-model",
    "href": "r-session-03.html#dynamical-model",
    "title": "\n9  R Session 03\n",
    "section": "\n9.5 Dynamical Model",
    "text": "9.5 Dynamical Model\nFirst, we write a specialized function for simulating the \\(SIR\\) model in a case where the removal rate is ``hard-wired’’ and with no demography.\n\nCodeclosed_sir_model &lt;- function (t, x, params) {  #SIR model equations\n  X &lt;- x[1]\n  Y &lt;- x[2]\n  beta &lt;- params\n  dX &lt;- - beta * X * Y\n  dY &lt;- beta * X * Y -(365 / 13) * Y\n  \n  list(c(dX, dY))\n}"
  },
  {
    "objectID": "r-session-03.html#objective-function",
    "href": "r-session-03.html#objective-function",
    "title": "\n9  R Session 03\n",
    "section": "\n9.6 Objective function",
    "text": "9.6 Objective function\nNow we set up a function that will calculate the sum of the squared differences between the observations and the model at any parameterization (more commonly known as “sum of squared errors”). In general, this is called the objective function because it is the quantity that optimization seeks to minimize.\n\nCodesse_sir &lt;- function(params0, data, site){  #function to calculate squared errors\n  data &lt;- data[data$site == site, ]    #working dataset, based on site\n  t &lt;- data[, 1] * 14 / 365            #time in biweeks\n  cases &lt;- data[, 3]               #number of cases\n  beta &lt;- exp(params0[1])            #parameter beta\n  X0 &lt;- exp(params0[2])           #initial susceptibles\n  Y0 &lt;- exp(params0[3])           #initial infected        \n  \n  out &lt;- as.data.frame(\n    deSolve::ode(\n      c(X = X0, Y = Y0),\n      times = t,\n      closed_sir_model,\n      beta,\n      hmax = 1/120\n    )\n  )\n\n  sum((out$Y - cases)^2)       #sum of squared errors that is returned to the optim function\n}\n\n\nNotice that the code for sse_sir makes use of the following modeling trick. We know that \\(\\beta\\), \\(X_0\\), and \\(Y_0\\) must be positive, but our search to optimize these parameters will be over the entire number line. We could constrain the search using a more sophisticated algorithm, but this might introduce other problems (i.e., stability at the boundaries). Instead, we parameterize our objective function (sse_sir) in terms of some alternative variables \\(log(\\beta)\\), \\(log(X_0)\\), and \\(log(Y_0)\\). While these numbers range from \\(-\\infty\\) to \\(\\infty\\) (the range of our search) they map to our model parameters on a range from \\(0\\) to \\(\\infty\\) (the range that is biologically meaningful)."
  },
  {
    "objectID": "r-session-03.html#optimization",
    "href": "r-session-03.html#optimization",
    "title": "\n9  R Session 03\n",
    "section": "\n9.7 Optimization",
    "text": "9.7 Optimization\nOur final step is to use the function optim to find the values of \\(\\beta\\), \\(X_0\\), and \\(Y_0\\) that minimize the sum of squared errors as calculated using our function.\n\nCodeparams0 &lt;- c(-3.2, 7.3, -2.6)  #initial guess\nfit1 &lt;- optim(params0, sse_sir, data = niamey, site = 1) #fit\nexp(fit1$par)  #back-transform parameters\n\n[1] 5.463181e-03 9.110385e+03 2.331841e+00\n\nCodefit2 &lt;- optim(params0, sse_sir, data = niamey, site = 2) #fit\nexp(fit2$par)  #back-transform parameters\n\n[1] 8.666138e-03 6.276503e+03 2.843753e-01\n\nCodefit3 &lt;- optim(params0, sse_sir, data = niamey, site = 3) #fit\n\n\nFinally, we plot these fits against the data.\n\nCodepar(mfrow=c(3,1))   #set up plotting area for multiple panels\nplot(\n  cases ~ biweek,\n  data = subset(niamey, site == 1),\n  type = 'b',\n  col = 'blue',\n  pch = 21\n) #plot site 1\n\nt &lt;- subset(niamey, site == 1)[, 1] * 14 / 365\n\nmod_pred &lt;-as.data.frame(\n  deSolve::ode(\n    c(X = exp(fit1$par[2]),\n    Y = exp(fit1$par[3])),\n    times = t,\n    closed_sir_model,\n    exp(fit1$par[1]),\n    hmax=1/120\n  )\n)\n                              #obtain model predictions\nlines(mod_pred$Y ~ subset(niamey, site == 1)[, 1]) #and plot as a line\n\nplot(\n  cases ~ biweek,\n  data = subset(niamey, site == 2),\n  type = 'b',\n  col = site\n) #site 2\n\nt &lt;- subset(niamey, site == 2)[, 1] * 14 / 365\n\nmod_pred &lt;- as.data.frame(\n  deSolve::ode(\n    c(X = exp(fit2$par[2]), Y = exp(fit2$par[3])),\n    times = t,\n    closed_sir_model,\n    exp(fit2$par[1]),\n    hmax = 1/120\n  )\n)\n\nlines(mod_pred$Y ~ subset(niamey, site == 2)[, 1])\n\nplot(\n  cases ~ biweek,\n  data = subset(niamey, site == 3),\n  type = 'b',\n  col = site\n) #site 3\n\nt &lt;- subset(niamey, site == 3)[, 1] * 14 / 365\n\nmod_pred &lt;-as.data.frame(\n  deSolve::ode(\n    c(X = exp(fit3$par[2]), Y = exp(fit3$par[3])),\n    times = t,\n    closed_sir_model,\n    exp(fit3$par[1]),\n    hmax = 1/120\n  )\n)\n\nlines(mod_pred$Y ~ subset(niamey, site == 3)[, 1])\n\n\n\n\n\n9.7.1 Exercise 5\nTo make things easier, we have assumed the infectious period is known to be 14 days. In terms of years, \\(\\gamma = (365/14)^{-1} \\approx 0.0384\\). Now, modify the code above to estimate \\(\\gamma\\) and \\(\\beta\\) simultaneously.\n\n9.7.2 Exercise 6\nWhat happens if one or both of the other unknowns (\\(X_0\\) and \\(Y_0\\)) is fixed instead of \\(\\gamma\\)?"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Bjørnstad, Ottar N. 2018. “Advanced: The Next-Generation\nMatrix.” In Epidemics: Models and\nData Using R, 51. Use R!\nCham: Springer International Publishing. https://doi.org/10.1007/978-3-319-97487-3.\n\n\nDiekmann, O., and J. A. P. Heesterbeek. 2000. In Mathematical\nEpidemiology of Infectious Diseases: Model Building,\nAnalysis and Interpretation. Wiley Series in Mathematical &\nComputational Biology. Wiley. https://books.google.ca/books?id=5VjSaAf35pMC.\n\n\nHeesterbeek, J. A. P. 2002. “A Brief History of\nR0 and a Recipe for Its\nCalculation.” Acta Biotheoretica 50 (3):\n189–204. https://doi.org/10.1023/A:1016599411804.\n\n\nHeffernan, J. M, R. J Smith, and L. M Wahl. 2005. “Perspectives on\nthe Basic Reproductive Ratio.” J R Soc Interface 2 (4):\n281–93. https://doi.org/10.1098/rsif.2005.0042.\n\n\nHurford, Amy, Daniel Cownden, and Troy Day. 2009. “Next-Generation\nTools for Evolutionary Invasion Analyses.” Journal of The\nRoyal Society Interface 7 (45): 561–71. https://doi.org/10.1098/rsif.2009.0448."
  }
]