[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "SISMID Module 2 Materials (2023)",
    "section": "",
    "text": "Welcome"
  },
  {
    "objectID": "r-session-01.html#questions",
    "href": "r-session-01.html#questions",
    "title": "3  R Session 01",
    "section": "3.1 Questions",
    "text": "3.1 Questions\n\n3.1.1 Developing intuition in a closed population\nTo begin with, let’s consider a closed population (no births or deaths), and a low initial fraction infected. The initial values are set so that \\(R_0 = 1.8\\), with a duration of infection of 6 days (roughly similar to circulating influenza).\n\n3.1.1.1 What happens if we increase the transmission rate?\nPlay around with the slider for the transmission rate.\n\n3.1.1.1.1 What happens to the epidemic curve?\n\n\n3.1.1.1.2 What happens to the peak fraction infected?\n\n\n3.1.1.1.3 What happens to the total fraction infected?\n\n\n3.1.1.1.4 What happens to the duration of the epidemic?\n\n\n3.1.1.1.5 What happens to the final size (equilibrium) of the epidemic?\n\n\n\n\n3.1.2 Exploring the effect of births and deaths\nNow let’s consider a population with births and deaths. Move “Demographics” panel above.\n\n3.1.2.1 What happens if we increase the birth rate (above 0)?\n\n3.1.2.1.1 What happens to \\(R_0\\)?\n\n\n3.1.2.1.2 What happens to the epidemic curve?\n\n\n3.1.2.1.3 What happens to the peak fraction infected?\n\n\n3.1.2.1.4 What happens to the total fraction infected?\n\n\n3.1.2.1.5 What happens to the duration of the epidemic?\n\n\n3.1.2.1.6 What happens to the final size (equilibrium) of the epidemic?\n\n\n\n\n\n\nTip\n\n\n\nYou may want to increase the maximum simulation time.\n\n\nWhen \\(R_0 < 1\\), equilibrium lines are not calculated. Why?\n\n\n\n\n3.1.3 Effects of interventions\n\n3.1.3.1 Intervention effects transmission\n\n3.1.3.1.1 Based on your intuition from the previous questions, what do you think will happen if we enact an intervention that reduces transmission by 50%?\n\n\n3.1.3.1.2 How could we incorporate this into the model?\n\n\n3.1.3.1.3 What are the core assumptions being made in this model, and how might they affect the results?\n\n\n\n3.1.3.2 Intervention effects duration of infection\nWe could imagine that an intervention could also reduce the duration of infection, say, for example, Tamiflu for influenza.\n\n3.1.3.2.1 Based on your intuition from the previous questions, what do you think will happen if we enact an intervention that reduces the duration of infection by 50%?\n\n\n3.1.3.2.2 How could we incorporate this into the model?\n\n\n3.1.3.2.3 What are the core assumptions being made in this model, and how might they affect the results?\n\n\n\n3.1.3.3 Intervention effects proportion of population susceptible\nWe could imagine that an intervention could also reduce the proportion of the population susceptible, say, for example, a vaccine.\n\n3.1.3.3.1 Based on your intuition from the previous questions, what do you think will happen if we enact an intervention that reduces the proportion of the population susceptible by 50%?\n\n\n3.1.3.3.2 How could we incorporate this into the model?\n\n\n3.1.3.3.3 What are the core assumptions being made in this model, and how might they affect the results?"
  },
  {
    "objectID": "r-session-01.html#appendix",
    "href": "r-session-01.html#appendix",
    "title": "3  R Session 01",
    "section": "3.2 Appendix",
    "text": "3.2 Appendix"
  },
  {
    "objectID": "r-session-02.html#a-model-with-2-classes",
    "href": "r-session-02.html#a-model-with-2-classes",
    "title": "\n7  R Session 02\n",
    "section": "\n7.1 A Model With 2 Classes",
    "text": "7.1 A Model With 2 Classes\nWe’ll start with the simplest mechanistic model of two classes we can think of, which has separate classes for two groups \\(a\\) and \\(b\\). These groups could represent different socioeconomic classes, for example.\n\n\n\n\n\nWhich can be written in equations as, \\[\n\\begin{aligned}\n    \\frac{dS_a}{dt} &= -\\lambda_a\\,S_a \\phantom{-\\gamma\\,I_b}\\\\\n    \\frac{dS_b}{dt} &= -\\lambda_b\\,S_b \\phantom{-\\gamma\\,I_b}\\\\\n    \\frac{dI_a}{dt} &= \\phantom{-}\\lambda_a\\,S_a -\\gamma\\,I_a\\\\\n    \\frac{dI_b}{dt} &= \\phantom{-}\\lambda_b\\,S_b-\\gamma\\,I_b\\\\\n    \\frac{dR_a}{dt} &= \\phantom{-\\lambda_a\\,S_b}+\\gamma\\,I_a\\\\\n    \\frac{dR_b}{dt} &= \\phantom{-\\lambda_a\\,S_b}+\\gamma\\,I_b\\\\\n  \\end{aligned}\n\\]\nThe \\(\\lambda\\)s denote the group-specific force of infections:\n\\[\n\\begin{aligned}\n        \\lambda_a &= \\beta_{aa}\\,I_a+\\beta_{ab}\\,I_b\\\\\n        \\lambda_b &= \\beta_{ba}\\,I_a+\\beta_{bb}\\,I_b\n\\end{aligned}\n\\]\nIn this model, each population can infect each other but the infection moves through the populations separately. Let’s simulate such a model. To make things concrete, we’ll assume that the transmission rates \\(\\beta\\) are greater within groups than between them.\n\nba_params <- c(\n    beta_within = 0.025,\n    beta_between = 0.005,\n    recovery = 10\n)\n\n\n# Here we set up the ODE model that matches the equations above\nba_model <- function (t, x, p, ...) {     \n    s <- x[c(\"Sa\", \"Sb\")]   # susceptibles\n    i <- x[c(\"Ia\", \"Ib\")]   # infecteds\n    r <- x[c(\"Ra\", \"Rb\")]   # recovereds\n    \n    beta_within <- p[1]\n    beta_between <- p[2]\n    recovery <- p[3]\n\n    # group A force of infection\n    lambda_a <- beta_within * i[1] + beta_between * i[2]\n\n    # group B force of infection\n    lambda_b <- beta_within * i[2] + beta_between * i[1]\n    \n    list(c(\n        # dSa/dt\n        - lambda_a * s[1],\n        # dSb/dt\n        - lambda_b * s[2],\n        # dIa/dt\n        lambda_a * s[1] - recovery * i[1],\n        # dIb/dt\n        lambda_b * s[2] - recovery * i[2],\n        # dRa/dt\n        recovery * i[1],\n        # dRb/dt\n        recovery * i[2]\n    ))\n}\n\n\n# initial conditions\nba_yinit <- c(Sa = 1000, Sb = 2000, Ia = 1, Ib = 1, Ra = 0, Rb = 0) # set starting conditions\n\n# Run the ODE solver from the deSolve package\nsol_ba <- deSolve::ode(\n    y = ba_yinit,\n    times = seq(0, 2, by = 0.001),\n    func = ba_model,\n    parms = ba_params,\n)\n\n\nsol_ba_long <- sol_ba %>%\n    as_tibble() %>%\n    mutate(Na = Sa + Ia + Ra, Nb = Sb + Ib + Rb) %>%\n    pivot_longer(\n        cols = -time,\n        names_to = c(\"state\", \"group\"),\n        names_sep = 1,\n        values_to = \"value\"\n    ) %>%\n    mutate(\n        state = factor(state, levels = c(\"S\", \"I\", \"R\", \"N\")),\n        group = paste(\"Group\", str_to_upper(group))\n        )\n\n\nSIRcolors <- c(\"#1f77b4\", \"#ff7f0e\", \"#FF3851\", \"#591099\")\n\nggplot(sol_ba_long, aes(x = time, y = value, color = state)) +\n    geom_line(linewidth = 1.5) +\n    facet_wrap(~group, scales = \"free_y\") +\n    scale_color_manual(\n        values = SIRcolors,\n        labels = c(\"Susceptible\", \"Infected\", \"Recovered\", \"Total\")\n    ) +\n    labs(\n        x = \"Time\",\n        y = \"Number of individuals\",\n        color = \"State\"\n    ) +\n    theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nDespite using the same transmission rates, the epidemic in group B is much larger than in group A. Why do you think this is?\n\n\nNow let’s plot the proportion of individuals in each state for the two groups.\n\nsol_ba_long_props <- sol_ba_long %>%\n    filter(state != \"N\") %>%\n    mutate(\n        state_group = paste0(state, str_extract_all(group, \"[^Group ]\")),\n        state_group = factor(state_group, levels = c(\"RA\", \"RB\", \"IA\", \"IB\", \"SA\", \"SB\"))\n    ) %>%\n    group_by(time, state_group) %>%\n    mutate(\n        prop = value / sum(ba_yinit)\n    ) %>%\n    ungroup()\n\n\nScolors <- RColorBrewer::brewer.pal(3, \"Blues\")[c(2, 3)]\nIcolors <- RColorBrewer::brewer.pal(3, \"Oranges\")[c(2, 3)]\nRcolors <- RColorBrewer::brewer.pal(3, \"Greens\")[c(2, 3)]\n\nggplot(sol_ba_long_props, aes(x = time, y = prop, fill = state_group)) +\n    geom_area() +\n    scale_fill_manual(\n        values = c(Scolors, Icolors, Rcolors),\n        limits = c(\"SA\", \"SB\", \"IA\", \"IB\", \"RA\", \"RB\"),\n    ) +\n    labs(\n        x = \"Time\",\n        y = \"Proportion of individuals\",\n        fill = \"State\"\n    ) +\n    theme(legend.position = \"bottom\")"
  },
  {
    "objectID": "r-session-02.html#a-model-with-2-age-classes",
    "href": "r-session-02.html#a-model-with-2-age-classes",
    "title": "\n7  R Session 02\n",
    "section": "\n7.2 A Model With 2 Age Classes",
    "text": "7.2 A Model With 2 Age Classes\nNote that age is a special kind of heterogeneity in an epidemic model because individuals necessarily move from one class (younger) to another class (older) in a directional fashion that is independent of the infection and recovery process.\n\n\n\nWe’ll start by introducing age into the model above. So now \\(a\\) becomes juveniles and \\(b\\) becomes adults. And, independent of the disease process, juveniles (of any category) age into adults. Additionally, new juveniles are added through births (always first susceptible) and old individuals are lost to death.\n\n\n\n\n\nWe can do this very simply using the same ingredients that go into the basic SIR model. In that model, the waiting times in the S and I classes are exponential. Let’s assume the same thing about the aging process. We’ll also add in births into the juvenile susceptible class and deaths from the adult classes.\n\\[\n  \\begin{aligned}\n    \\frac{dS_J}{dt} &= B -\\lambda_J\\,S_J \\phantom{- \\gamma\\,I_A} -\\alpha\\,S_J \\phantom{-\\mu\\,S_A}\\\\\n    \\frac{dS_A}{dt} &= \\phantom{B} - \\lambda_A\\,S_A \\phantom{- \\gamma\\,I_A} +\\alpha\\,S_J -\\mu\\,S_A\\\\\n    \\frac{dI_J}{dt} &= \\phantom{B} +\\lambda_J\\,S_J - \\gamma\\,I_J -\\alpha\\,I_J \\phantom{-\\mu\\,S_A}\\\\\n    \\frac{dI_A}{dt} &= \\phantom{B} +\\lambda_A\\,S_A - \\gamma\\,I_A + \\alpha\\,I_J - \\mu\\,I_A\\\\\n    \\frac{dR_J}{dt} &= \\phantom{B - \\lambda_J\\,S_A} + \\gamma\\,I_J - \\alpha\\,R_J \\phantom{- \\mu\\,S_A}\\\\\n    \\frac{dR_A}{dt} &= \\phantom{B - \\lambda_J\\,S_A} + \\gamma\\,I_A + \\alpha\\,R_J -\\mu\\,R_A\\\\\n  \\end{aligned}\n\\]\nNow, let’s simulate this model, under the same assumptions about transmission rates as above.\n\n# define the parameters\ndemog_params <- c(\n    beta_within = 0.004,\n    beta_between = 0.002,\n    recovery = 10,\n    births = 80,\n    age_bands = c(20, 60)\n)\n\n\nja_demog_model <- function (t, x, p, ...) {\n    s <- x[c(\"Sj\", \"Sa\")]    # susceptibles\n    i <- x[c(\"Ij\", \"Ia\")]    # infecteds\n    r <- x[c(\"Rj\", \"Ra\")]    # recovereds\n    n <- s + i + r     # total pop\n\n    beta_within <- p[1]\n    beta_between <- p[2]\n    recovery <- p[3]\n    births <- p[4]       # births into juvenile class & deaths from adult class\n    aging_j <- 1 / p[5]\n    aging_a <- 1 / p[6]\n\n    # juv. force of infection \n    lambda_j <- beta_within * i[1] + beta_between * i[2]\n    \n    # adult. force of infection\n    lambda_a <- beta_between * i[1] + beta_within * i[2]\n    \n    list(c(\n        # dSj/dt    Note: only adults contribute to births\n        (births) - (lambda_j * s[1]) - (aging_j * s[1]),\n        # dSa/dt\n        -(lambda_a * s[2]) + (aging_j * s[1]) - (aging_a * s[2]),\n        # dIj/dt\n        (lambda_j * s[1]) - (recovery * i[1]) - (aging_j * i[1]),\n        # dIa/dt\n        (lambda_a * s[2]) - (recovery * i[2]) + (aging_j * i[1]) - (aging_a * i[2]),\n        # dRj/dt\n        (recovery* i[1]) - (aging_j * r[1]),\n        # dRa/dt\n        (recovery * i[2]) + (aging_j * r[1]) - (aging_a * r[2])\n    ))\n}\n\nNote that in this function, \\(\\mu=\\) births, i.e., death, is just like another age class.\n\n## initial conditions\ndemog_yinit <- c(Sj = 2000, Sa = 3000, Ij = 0, Ia = 1, Rj = 0, Ra = 1000)\n\nsol_demog <- deSolve::ode(\n    y = demog_yinit,\n    times = seq(0, 200, by = 0.1),\n    func = ja_demog_model,\n    parms = demog_params\n)\n\nsol_demog_long <- sol_demog %>%\n    as_tibble() %>%\n    mutate(Nj = Sj + Ij + Rj, Na = Sa + Ia + Ra, N = Nj + Na) %>%\n    pivot_longer(\n        cols = -c(time, N),\n        names_to = c(\"state\", \"group\"),\n        names_sep = 1,\n        values_to = \"value\"\n    ) %>%\n    mutate(\n        state = factor(state, levels = c(\"S\", \"I\", \"R\", \"N\")),\n        group = paste(\"Group\", str_to_upper(group))\n    )\n\n\n7.2.1 Exercise 1: Use this code to plot the number of susceptible, infected, and recovered individuals over time.\n\nggplot(sol_demog_long, aes(x = time, y = value, color = state)) +\n    geom_line(linewidth = 1.5) +\n    facet_wrap(~group, nrow = 2, scales = \"free_y\") +\n    scale_color_manual(\n        values = SIRcolors,\n        labels = c(\"Susceptible\", \"Infected\", \"Recovered\", \"Total\")\n    ) +\n    labs(\n        x = \"Time\",\n        y = \"Number of individuals\",\n        color = \"State\"\n    ) +\n    theme(legend.position = \"bottom\")\n\n\n\n\nNote that now that births are replenishing susceptibles, infection persists. The results of the above are plotted here:\nNow let’s plot the proportion of individuals in each state for the two groups.\n\nsol_demog_long_props <- sol_demog_long %>%\n    filter(state != \"N\") %>%\n    mutate(\n        state_group = paste0(state, str_extract_all(group, \"[^Group ]\")),\n        state_group = factor(state_group, levels = c(\"RA\", \"RJ\", \"IA\", \"IJ\", \"SA\", \"SJ\"))\n    ) %>%\n    group_by(time, state_group) %>%\n    mutate(\n        prop = value / N\n    ) %>%\n    ungroup()\n\n\nggplot(sol_demog_long_props, aes(x = time, y = prop, fill = state_group)) +\n    geom_area() +\n    scale_fill_manual(\n        values = c(Scolors, Icolors, Rcolors),\n        limits = c(\"SA\", \"SJ\", \"IA\", \"IJ\", \"RA\", \"RJ\")\n    ) +\n    labs(\n        x = \"Time\",\n        y = \"Proportion of individuals\",\n        fill = \"State\"\n    ) +\n    theme(legend.position = \"bottom\")\n\n\n\n\nNow let’s plot the equilibrium seroprevalence for each age group.\n\nequil_seroprev <- tail(sol_demog_long) %>%\n    group_by(group) %>%\n    mutate(\n        prop = value / sum(value),\n        group = factor(group, levels = c(\"Group J\", \"Group A\"))\n    ) %>%\n    ungroup() %>%\n    filter(state == \"R\")\n\nggplot(equil_seroprev, aes(x = group, y = prop, fill = group)) +\n    geom_col(position = \"identity\") +\n    scale_fill_manual(\n        values = c(\"purple\", \"orange\"),\n        limits = c(\"Group J\", \"Group A\")\n    ) +\n    labs(\n        x = \"Age group\",\n        y = \"Equilibrium seroprevalence\",\n        fill = \"Age group\"\n    ) +\n    theme(legend.position = \"none\")\n\n\n\n\nTo compute \\(R_0\\), we need to know the stable age distribution (the relative proportion in the juvenile and adult age classes) of the population, which we can find by solving for the disease-free equilibrium: \\(S_J^*=B/\\alpha\\) and \\(S_A^*=B/\\mu\\).\nWith the stable age distribution, we can calculate \\(R_0\\) by constructing the next generation matrix. Details on this method are described in the last section of this worksheet and are not required for completing the exercises in the worksheet. The code below outlines how the next generation matrix is constructed using the \\(\\alpha\\) (aging from juvenile to adult), \\(\\mu\\) death), \\(n\\) (total births), \\(\\gamma\\) (recovery), \\(da\\) (width of age groups in years), and \\(\\beta\\) (transmission) parameters.\n\n# this code can be re-run to set parameter values\nalpha <- demog_params[\"age_bands1\"]\nmu <- demog_params[\"age_bands2\"]\nn <- demog_params[\"births\"] / c(alpha, mu)\n\nbeta_demog <- matrix(c(\n    demog_params[\"beta_within\"],\n    demog_params[\"beta_between\"],\n    demog_params[\"beta_between\"],\n    demog_params[\"beta_within\"]\n    ),\n    nrow = 2,\n    ncol = 2\n)\n\n# this command creates the next generation matrix\nngm <- matrix(\n    c(\n\n        n[1] * (beta_demog[1, 1] / (demog_params[\"recovery\"] + alpha)) +\n            alpha / (demog_params[\"recovery\"] + mu) *\n            n[1] * beta_demog[1, 2] / (demog_params[\"recovery\"] + mu),\n        \n        n[2] * beta_demog[2, 1] / (demog_params[\"recovery\"] + alpha) +\n            alpha / (demog_params[\"recovery\"] + mu) *\n            n[2] * (beta_demog[2, 2] / (demog_params[\"recovery\"] + mu)),\n\n        n[1] * beta_demog[1, 2] / (demog_params[\"recovery\"] + mu),\n\n        n[2] * beta_demog[2, 2] / (demog_params[\"recovery\"] + mu)\n    ),\n    nrow = 2,\n    ncol = 2\n)\n\n# this command outputs the R0 value\nmax(Re(eigen(ngm, only.values=T)$values))\n\n[1] 0.0005905724"
  },
  {
    "objectID": "r-session-02.html#getting-more-realistic-adding-more-age-classes",
    "href": "r-session-02.html#getting-more-realistic-adding-more-age-classes",
    "title": "\n7  R Session 02\n",
    "section": "\n7.3 Getting more realistic: adding more age classes",
    "text": "7.3 Getting more realistic: adding more age classes\nIn the models above, the aging process follows an exponential distribution, which means that whether an individual is 1~year old or 10 years old, the chance of them becoming an adult is the same! To improve on this, we can assume that the time a juvenile must wait before becoming an adult follows a gamma distribution. This is equivalent to saying that the waiting time is a sum of some number of exponential distributions. This suggests that we can achieve such a distribution by adding age classes to the model, so that becoming an adult means passing through some number of stages. We’ll use 30 age classes, and since they don’t have to be of equal duration, we’ll assume that they’re not. Specifically, we’ll have 20 1-yr age classes to take us up to adulthood and break adults into 10 age classes of 5~yr duration each. The last age class covers age 66-80.\nNow, when we had just two age classes, we could write out each of the equations easily enough, but now that we’re going to have 30, we’ll need to be more systematic. In particular, we’ll need to think of \\(\\beta\\) as a matrix of transmission rates. Let’s see how to define such a matrix in R. So that we don’t change too many things all at once, let’s keep the same contact structure as in the juvenile-adult model.\n\n# ages_params[1] <- 0.02  #transmission rate\n# ages_params[2] <- 0.01  #transmission rate\n# gamma_ages <- 10\n# births_ages <- 100\n\nages_params <- c(0.02, 0.01, 10, 100)\n\nages <- c(seq(1, 20, by = 1), seq(25, 65, by = 5), 80) # upper end of age classes\n\nda_ages <- diff(c(0, ages))                  # widths of age classes\n\n# set up a matrix of contact rates between classes -- more contact within juveniles and adults than between\nbeta_ages <- matrix(nrow = 30, ncol = 30)    \nbeta_ages[1:20, 1:20] <- ages_params[1] # transmission rate for juveniles \nbeta_ages[21:30, 21:30] <- ages_params[2] # transmission rate for adults\nbeta_ages[1:20, 21:30] <- ages_params[2]/2 # lower transmission rate between juveniles and adults\nbeta_ages[21:30, 1:20] <- ages_params[2]/2 # lower transmission rate between juveniles and adults\n\n#WAIFW stands for Who Aquires Infection From Whom\nfilled.contour(\n    ages, ages, beta_ages,\n    plot.title = title(\n        main = \"WAIFW matrix\",\n        xlab = \"age\",\n        ylab = \"age\"\n    )\n)\n\n\n\n\nWe’ll assume that, at the time of introduction, all children are susceptible, as are adults over 45, but that individuals aged 20–45 have seen the pathogen before and are immune. The vector yinit expresses these initial conditions.\n\ndemog_yinit_ages <- c(\n    S = c(rep(100, 20), rep(0, 5), rep(200, 5)),\n    I = c(rep(0, 25), 1, rep(0, 4)),\n    R = c(rep(0, 20), rep(1000, 5), rep(0, 5))\n)\n\nNote that we’re starting out with 1 infected individual in the 26th age class.\nThe codes that follow will be a bit easier to follow if we introduce some indexes that will allow us to pick out certain bits of the yinit vector.\n\nsindex <- 1:30\niindex <- 31:60\nrindex <- 61:90\njuvies <- 1:20\nadults <- 21:30\n\nNow, to capture the aging process, it’s convenient to define another matrix to hold the rates of movement between age classes.\n\naging <- diag(-1 / da_ages)\n\naging[row(aging) - col(aging) == 1] <- 1 / head(da_ages, -1)\n\nHave a look at the aging matrix, for example by doing:\n\n# move fast through the 1-year age classes - negatives are moves out, positives are moves in\naging[1:5,1:5] \n\n# don't age between these classes -- e.g. can't age from 1 to 6\naging[1:5,6:10] \n\n# move slowly between the wider age classes\naging[25:30,25:30] \n\n#plot the aging matrix\nfilled.contour(\n    ages, ages, aging,\n    plot.title = title(\n        main = \"Aging matrix\",\n        xlab = \"age\",\n        ylab = \"age\"\n    )\n)\n\n\n7.3.1 Exercise 2: What can you say about its structure? How are the different age groups in contact with each other?\nNow we can put the pieces together to write a simulator for the age-structured SIR dynamics.\n\nmultistage_params <- list(\n    beta_ages = beta_ages,\n    gamma_ages = ages_params[3],\n    births_ages = ages_params[4],\n    aging = aging\n)\n\nja_multistage_model <- function (t, x, p, ...) {\n    s <- x[sindex]                  # susceptibles\n    i <- x[iindex]                  # infecteds\n    r <- x[rindex]                  # recovereds\n    \n    beta_mat <- p[[\"beta_ages\"]]    # transmission rate\n\n    gamma_ages <- p[[\"gamma_ages\"]]   # recovery rate\n    births_ages <- p[[\"births_ages\"]] # birth rate\n    aging <- p[[\"aging\"]]\n\n    lambda <- beta_mat %*% i        # force of infection\n    \n    dsdt <- -lambda * s + aging %*% s\n    didt <- lambda * s + aging %*% i - gamma_ages * i\n    drdt <- aging %*% r + gamma_ages * i \n    dsdt[1] <- dsdt[1] + births_ages\n    \n    list(c(dsdt, didt, drdt))\n\n}\n\nWe can plug this into ode just as we did the simpler models to simulate an epidemic. We’ll then plot the epidemic curve.\n\nsol_ms <- deSolve::ode(\n    y = demog_yinit_ages,\n    times = seq(0, 100, by = 0.1),\n    func = ja_multistage_model,\n    parms = multistage_params\n)\n\ntime_ms <- sol_ms[, 1]\ninfects_ms <- sol_ms[, 1 + iindex]\n\n\nplot(time_ms, apply(infects_ms, 1, sum), type = 'l')\nlines(time_ms, apply(infects_ms[, juvies], 1, sum), col = 'red')\nlines(time_ms, apply(infects_ms[, adults], 1, sum), col = 'blue')\n\n\n\n\nLet’s mimic a situation where we have cross-sectional seroprevalence data (e.g. measures of antibodies that tell you someone is in the R class). In using such data, we’d typically assume that the system was at equilibrium.\n\n7.3.2 Exercise 3: What does the equilibrium age-specific seroprevalence look like in this example?\nUse the code below to display the age-specific seroprevalence (i.e., the seroprevalence for each age group at equilibrium)\n\nequil_ms <- drop(tail(sol_ms, 1))[-1]\nn_ms <- equil_ms[sindex] + equil_ms[iindex] + equil_ms[rindex]\nseroprev_ms <- equil_ms[rindex] / n_ms\nnames(seroprev_ms) <- ages\nbarplot(height = seroprev_ms, width = da_ages)\n\nLet’s also compute \\(R_0\\). To do so, we’ll need the stable age distribution. We can get that by simulating an infection-free population, which we get by setting the initial I to all 0s:\n\nyinit_sonly <- c(\n    S=c(rep(250,30)),\n    I=c(rep(0,30)),\n    R=c(rep(0,30))\n)\n\nsol_sonly <- deSolve::ode(\n    y = yinit_sonly,\n    times = seq(0, 300, by = 1),\n    func = ja_multistage_model,\n    parms = list(\n        beta_ages = beta_ages,\n        gamma_ages = ages_params[3],\n        births_ages = demog_params[\"recovery\"],\n        aging = aging\n    )\n)\n\ntime_sonly <- sol_sonly[, 1]\npop <- apply(sol_sonly[, -1], 1 , sum)\n\nplot(time_sonly, pop, type = 'l')\n\nAlternatively, we can get the stable age distribution by finding the population structure that balances the birth, aging, and death processes. At equilibrium, we have the matrix equation\n\\[\n\\begin{pmatrix}\n    -\\alpha_1 & 0 & 0 & \\cdots & 0\\\\\n    \\alpha_1 & -\\alpha_2 & 0 & \\cdots & 0\\\\\n    0 & \\alpha_2 & -\\alpha_3 & \\cdots & 0\\\\\n    \\vdots &  & \\ddots & \\ddots & \\vdots \\\\\n    0 & \\cdots & & \\alpha_{29} & -\\alpha_{30}\\\\\n  \\end{pmatrix} . \\begin{pmatrix}\n    n_1 \\\\ n_2 \\\\ n_3 \\\\ \\vdots \\\\ n_{30}\n  \\end{pmatrix} + \\begin{pmatrix}\n    B \\\\ 0 \\\\ 0 \\\\ \\vdots \\\\ 0\n  \\end{pmatrix}=\n  \\begin{pmatrix}\n    0 \\\\ 0 \\\\ 0 \\\\ \\vdots \\\\ 0\n  \\end{pmatrix}\n\\]\nTo solve this equation in R, we can do\n\n## get stable age distribution\nn <- solve(\n    aging,\n    -c(multistage_params[[\"births_ages\"]], rep(0, 29))\n)\n\nThe following lines then compute \\(R_0\\) using the next generation matrix method. More details are available in the “Bonus” section at the end of the document. This calculation comes from a recipe described in detail by Diekmann & Heesterbeek, 2000 and Hurford et. al, 2010.\n\nF <- diag(n) %*% multistage_params[[\"beta_ages\"]] +\n    multistage_params[[\"aging\"]] -\n    diag(diag(multistage_params[[\"aging\"]]))\n\nV <- diag(multistage_params[[\"gamma_ages\"]] - diag(multistage_params[[\"aging\"]]))\n\nmax(\n    Re(\n        eigen(solve(V, F), only.values = TRUE)$values\n    )\n)\n\n[1] 6.792003\n\n\n\n7.3.3 Exercise 4:\n\n7.3.3.1 a. Change the juvenile and adult contact rates (ages_params[1] and ages_params[2]) to reflect different transmission within groups. Make the juvenile contact rate 0.02 to reflect higher contact among kids (e.g. in schools).\n\n7.3.3.2 b. Use image or filled.contour to plot the \\(\\beta\\) matrix.\n\n7.3.3.3 c. Compute \\(R_0\\) for your assumptions.\n\n7.3.3.4 d. Simulate and plot the age-structured SIR dynamics under your assumptions and record how the age-specific seroprevalence has changed.\n\n\n\n\nsol_r <- deSolve::ode(\n    y = demog_yinit_ages,\n    times = seq(0,400,by=0.1),\n    func = ja_multistage_model,\n    parms = multistage_params\n)\n\n\nplot(sol_r[, 1], apply(sol_r[, 1 + iindex], 1, sum), type = 'l')\nlines(sol_r[, 1], apply(sol_r[, 1 + iindex[juvies]], 1, sum), col = 'red')\nlines(sol_r[, 1], apply(sol_r[, 1 + iindex[adults]], 1, sum), col = 'blue')\n\n\n\n\n\nequil_r <- drop(tail(sol_r, 1))[-1]\nn_r <- equil_r[sindex] + equil_r[iindex] + equil_r[rindex]\nseroprev_r <- equil_r[rindex] / n_r\nnames(seroprev_r) <- ages\nbarplot(height = seroprev_r, width = da_ages)\n\n\n\n\n\nF <- diag(n) %*% multistage_params[[\"beta_ages\"]] +\n    multistage_params[[\"aging\"]] -\n    diag(diag(multistage_params[[\"aging\"]]))\n\nV <- diag(multistage_params[[\"gamma_ages\"]] - diag(multistage_params[[\"aging\"]]))\n\nmax(\n    Re(\n        eigen(solve(V, F), only.values = TRUE)$values\n    )\n)\n\n[1] 6.792003\n\n# R0 = 6.53\ninfects_r <- sol_r[dim(sol_r)[1],1+iindex]\nsum(ages * infects_r/sum(infects_r))\n\n[1] 6.546368\n\nsum(infects_r[15:23])\n\n[1] 0.6939407"
  },
  {
    "objectID": "r-session-02.html#r0-and-the-mean-age-of-infection",
    "href": "r-session-02.html#r0-and-the-mean-age-of-infection",
    "title": "\n7  R Session 02\n",
    "section": "\n7.4 R0 and the mean age of infection",
    "text": "7.4 R0 and the mean age of infection\nFor simplicity, let’s return to the earlier models with a simple age-class mixing matrix. But this time, we’ll calculate \\(R_0\\), the mean age of infection, and the number of cases between 15-35 years as we increase the rate of contact. Recall from the rubella and CRS example that the risk of severe disease outcomes depends on the risk of infection in reproductive age women. Recall also that increasing vaccination reduces \\(R_E\\) – so here we’ll evalate at several values of \\(R_0\\) as a proxy for the impact of vaccination. We’ll then calculate how the mean age of infection changes, and specifically how the absolute number of cases among individuals between the ages of 15-35 (as a proxy for reproductive age women) changes. To do so, we’ll make a loop and evaluate the code for each of 10 increasing levels of mixing (which whill change R0)\n\n # a vector of scaling factors, we'll reduce the contact rate \n # from the original code by each of the values in this vector\nscale <- seq(0.2, 1, length = 10) \nR0 <- numeric() # somewhere to store results for the mean age\nmean_age <- numeric() # somewhere to store results for the mean age\nsum_cases <- numeric() # somewhere to store results for the mean age\n\n# this loop will run for as many different levels of contact that we specify \n# for the scale variable \n# this is the same code as above, but now we've included a multiplier for the \n# contact matrix\nfor(ii in 1:length(scale)){ \n    beta1 <- 0.007\n    beta2 <- 0.02\n    b3 <- 0.03\n    beta <- matrix(data = beta1, nrow = 30, ncol = 30)\n    beta[1:20,1:20] <- beta2\n    beta[6:16,6:16] <- b3\n    beta_ages <- beta * scale[ii]\n    #filled.contour(beta)\n\n    params <- list(\n        beta_ages = beta_ages,\n        gamma_ages = ages_params[3],\n        aging = aging,\n        births_ages = demog_params[4]\n    )\n\n    sol_R0 <- deSolve::ode(\n        y = demog_yinit_ages,\n        times = seq(0, 400, by = 0.1),\n        func = ja_multistage_model,\n        parms = params\n    )\n\n    equil_R0 <- drop(tail(sol_R0, 1))[-1]\n    n_R0 <- equil_R0[sindex] + equil_R0[iindex] + equil_R0[rindex]\n    seroprev_R0 <- equil_R0[rindex] / n_R0\n    names(seroprev_R0) <- ages\n    # barplot(height=seroprev,width=da)\n\n    ## get stable age distribution\n    n_R0 <- solve(\n        params[[\"aging\"]],\n        -c(params[[\"births_ages\"]], rep(0, 29))\n    )\n    ## get R0\n    F_R0 <- diag(n_R0) %*% params[[\"beta_ages\"]] +\n        params[[\"aging\"]] -\n        diag(diag(params[[\"aging\"]]))\n\n    V_R0 <- diag(params[[\"gamma_ages\"]] -\n        diag(params[[\"aging\"]]))\n\n    R0[ii] <- max(\n        Re(\n            eigen(solve(V_R0, F_R0), only.values = TRUE)$values\n        )\n    )\n    # R0 = 6.53\n    infects_R0 <- sol_R0[dim(sol_R0)[1],1+iindex]\n    mean_age[ii] <- sum(ages * infects_R0 / sum(infects_R0))\n    sum_cases[ii] <- sum(infects_R0[15:23])\n}\n\nNow we can make a table of the results and plot mean age and the sum of cases between 15-35 years of age as a function of \\(R_0\\).\n\ndf <- data.frame(R0 = R0, \"mean age\" = mean_age, \"cases (15-35y)\" = sum_cases)\n\nknitr::kable(df)\n\n\n\nR0\nmean.age\ncases..15.35y.\n\n\n\n1.090445\n34.960759\n4.128340e-01\n\n\n1.550191\n26.366725\n1.477532e+00\n\n\n2.010194\n20.575778\n1.701317e+00\n\n\n2.470308\n10.796283\n-2.151898e+147\n\n\n2.930480\n10.541245\n-2.653441e+147\n\n\n3.390686\n11.776181\n1.262293e+00\n\n\n3.850913\n10.048183\n-1.708649e+147\n\n\n4.311155\n9.100295\n9.290088e-01\n\n\n4.771408\n8.195547\n7.930764e-01\n\n\n5.231668\n7.475129\n6.767692e-01\n\n\n\n\npar(mfrow=c(1,2))\nplot(R0, mean_age, xlab = \"R0\", ylab = \"mean age of infection\")\nplot(R0, sum_cases, xlab = \"R0\", ylab = \"total cases between 15-35y\")\n\n\n\n\n\n\n\n\n7.4.1 Exercise 5: Try the same as you fix \\(R_0\\) but change the birth rate (as if new infants were vaccinated), instead of changing the contact rate.\nFor example, if the birth rate was 100 before, try using a sequence of birth rates ranging from 100 (i.e. no new infants are vaccinated) to 75 (i.e., 25% of new infants are vaccinated). You can use the technique we used above, where we ran the simulation in a loop multiple times, for varying levels of contact, modifying it to run on varying levels of births (e.g., between 75 and 100).\n\n\n\n\ndf <- data.frame(\n    births = births_seq,\n    R0 = R0_b,\n    \"mean age\" = mean_age_b,\n    \"cases (15-35y)\" = sum_cases_b\n)\n\nknitr::kable(df)\n\n\n\nbirths\nR0\nmean.age\ncases..15.35y.\n\n\n\n75.00000\n5.231668\n7.964942\n0.7093049\n\n\n77.77778\n5.231668\n7.683702\n0.6913806\n\n\n80.55556\n5.231668\n7.425096\n0.6730883\n\n\n83.33333\n5.231668\n7.186665\n0.6545678\n\n\n86.11111\n5.231668\n6.966264\n0.6359377\n\n\n88.88889\n5.231668\n6.762021\n0.6172979\n\n\n91.66667\n5.231668\n6.572292\n0.5987331\n\n\n94.44444\n5.231668\n6.395635\n0.5803142\n\n\n97.22222\n5.231668\n6.230778\n0.5621003\n\n\n100.00000\n5.231668\n6.076599\n0.5441408\n\n\n\n\npar(mfrow = c(1, 2))\nplot(births_seq, mean_age_b, xlab = \"births\", ylab = \"mean age of infection\")\nplot(births_seq, sum_cases_b, xlab = \"births\", ylab = \"total cases between 15-35y\")\n\n\n\n#plot(births_seq,R0_b,xlab=\"births\",ylab=\"R0\")"
  },
  {
    "objectID": "r-session-02.html#what-do-real-contact-networks-look-like",
    "href": "r-session-02.html#what-do-real-contact-networks-look-like",
    "title": "\n7  R Session 02\n",
    "section": "\n7.5 What do real contact networks look like?",
    "text": "7.5 What do real contact networks look like?\nThe POLYMOD study Mossong, 2008 was a journal-based look into the contact network in contemporary European society. Let’s have a look what these data tell us about the contact structure.\n\nmoss <- read.csv(\n    url(\"http://www.math.mcmaster.ca/~bolker/eeid/data/mossong.csv\"),\n    as.is = TRUE\n)\n\nage_categories <- moss$contactor[1:30]\nmoss$contactor <- ordered(moss$contactor, levels = age_categories)\nmoss$contactee <- ordered(moss$contactee, levels = age_categories)\n\nSince contacts are symmetric, we’ll need to estimate the symmetric contact matrix.\n\nx1 <- with(\n    moss,\n    tapply(contact.rate, list(contactor, contactee), unique)\n)\n\nxsym <- (x1 + t(x1)) / 2\n\n\nfilled.contour(ages, ages, log10(xsym))\nfilled.contour(\n    ages, ages, log10(xsym),\n    plot.title = title(\n        main = quote(log[10](contact ~ rate)),\n        xlab = \"age\", ylab = \"age\"\n    )\n)\nbarplot(height=apply(x1,1,sum))\nbarplot(height=apply(x1,2,sum))\n\nWhile this matrix tells us how many contacts are made per year by an individual of each age, it doesn’t tell us anything about the probability that a contact results in communication of infection. Let’s assume that each contact has a constant probability \\(q\\) of resulting in a transmission event.\n\nq <- 3e-5\nbeta_ages <- q * xsym\n\nfilled.contour(\n    ages,ages,log10(beta_ages),\n    plot.title = title(\n        main=\"WAIFW matrix based on POLYMOD data\",\n        xlab=\"age\", ylab=\"age\"\n    )\n)\n\n\n\n\nNow let’s simulate the introduction of such a pathogen into a population characterized by this contact structure.\n\nsol_p <- deSolve::ode(\n    y = demog_yinit_ages,\n    times = seq(0, 200, by = 0.5),\n    func = ja_multistage_model,\n    parms = multistage_params\n)\n\ntime <- sol_p[, 1]\ninfects_p <- sol_p[, 1+iindex]\nplot(time, apply(infects_p, 1, sum), type = 'l')\nlines(time, apply(infects_p[, juvies], 1, sum), col = 'red')\nlines(time, apply(infects_p[, adults], 1, sum), col = 'blue')\n\nAs before, we can also look at the equilibrium seroprevalence\n\nequil_p <- drop(tail(sol_p, 1))[-1]\n\nn_p <- equil_p[sindex] + equil_p[iindex] + equil_p[rindex]\n\nseroprev_p <- equil_p[rindex] / n_p\n\nnames(seroprev_p) <- ages\n\nbarplot(height = seroprev_p, width = c(demog_params[5:6]))\n\nand compute the \\(R_0\\) for this infection.\n\nn_p <- solve(\n    multistage_params[[\"aging\"]],\n    -c(multistage_params[[\"births_ages\"]], rep(0, 29))\n)\n\nF_p <- diag(n_p) %*% multistage_params[[\"beta_ages\"]] +\n    multistage_params[[\"aging\"]] -\n    diag(diag(multistage_params[[\"aging\"]]))\n\nV_p <- diag(\n    multistage_params[[\"gamma_ages\"]] -\n        diag(multistage_params[[\"aging\"]])\n    )\n\nmax(\n    Re(\n        eigen(solve(V_p,F_p),only.values=T)$values\n    )\n)\n\nHow does this R0 value compare to the R0 value obtained from Exercise 4?"
  },
  {
    "objectID": "r-session-02.html#bonus-calculating-r0-using-a-next-generation-matrix",
    "href": "r-session-02.html#bonus-calculating-r0-using-a-next-generation-matrix",
    "title": "\n7  R Session 02\n",
    "section": "\n7.6 Bonus: Calculating R0 Using a Next Generation Matrix",
    "text": "7.6 Bonus: Calculating R0 Using a Next Generation Matrix\nThe next generation matrix is a matrix that specifies how many new age-specific infections are generated by a typical infected individual of each age class (in a fully susceptible population). For example, let’s consider an infected adult and ask how many new juvenile infections it generates: this is the product of the number of susceptible juveniles (from the stable age distribution), the per capita transmission rate from adults to juveniles and the average duration of infection, i.e. \\(S_J^* \\times \\beta_{JA} \\times 1/ (\\gamma+\\mu)\\). This forms one element of our next generation matrix. The other elements look very similar, except there are extra terms when we consider an infected juvenile because there is a (very small) chance they may age during the infectious period and therefore cause new infections as an adult:\n\\[\n\\mathrm{NGM} = \\left(\n  \\begin{matrix}\n    \\frac{S_J^* \\beta_{JJ} }{(\\gamma+\\alpha)} +\\frac{\\alpha}{(\\gamma+\\mu)}\\frac{S_J^*\\beta_{JA}}{(\\gamma+\\mu)} &  \n    \\frac{S_J^* \\beta_{JA}}{(\\gamma+\\mu)} \\\\\n    \\frac{S_A^* \\beta_{AJ} }{(\\gamma+\\alpha)} +\\frac{\\alpha}{(\\gamma+\\mu)}\\frac{S_A^*\\beta_{AA}}{(\\gamma+\\mu)} &  \\frac{S_A^* \\beta_{AA}}{(\\gamma+\\mu)}\n  \\end{matrix}\n\\right)\n\\]\n\\(R_0\\) can then be computed as the dominant eigenvalue (i.e., the one with the largest real part) of this matrix. Let’s take an example from a model with 2 age classes, from above. First, let’s define the components of the next generation matrix:\n\nda_ngm <- c(20, 60) # this classifies the two age groups (0-20, 21-60) \nbeta1_ngm = 0.005\nbeta2_ngm = 0.006\nalpha_ngm <- 1/da_ngm[1]\nmu_ngm <- 1/da_ngm[2]\nn_ngm <- demog_params[4] / c(alpha_ngm, mu_ngm)\n\nbeta_ngm <- matrix(\n    c(beta1_ngm + beta2_ngm, beta1_ngm, beta1_ngm, beta1_ngm + beta2_ngm),\n    nrow = 2,\n    ncol = 2\n)\n\ngamma_ngm = 10\n\nThe Next Generation Matrix can be calculated in R as:\n\nngm <- matrix(\n    c(\n        n_ngm[1] * beta_ngm[1,1] / (gamma_ngm+alpha_ngm) +\n            alpha_ngm / (gamma_ngm+mu_ngm) *\n            n[1] *\n            beta_ngm[1,2] / (gamma_ngm+mu_ngm),\n        n_ngm[2] * beta_ngm[2,1] / (gamma_ngm+alpha_ngm) +\n            alpha_ngm / (gamma_ngm+mu_ngm) *\n            n[2] *\n            beta_ngm[2,2] / (gamma_ngm+mu_ngm),\n        n_ngm[1] * beta_ngm[1,2] / (gamma_ngm+mu_ngm),\n        n_ngm[2] * beta_ngm[2,2] / (gamma_ngm+mu_ngm)\n        ),\n    nrow = 2,\n    ncol = 2\n)\n\neigen(ngm)\n\neigen() decomposition\n$values\n[1] 5.748499 1.274209\n\n$vectors\n           [,1]       [,2]\n[1,] -0.1959434 -0.8584007\n[2,] -0.9806152  0.5129797\n\neigen(ngm, only.values = TRUE)\n\n$values\n[1] 5.748499 1.274209\n\n$vectors\nNULL\n\nmax(\n    Re(\n        eigen(ngm, only.values = TRUE)$values\n    )\n)\n\n[1] 5.748499"
  },
  {
    "objectID": "r-session-03.html#estimating-r_0",
    "href": "r-session-03.html#estimating-r_0",
    "title": "\n9  R Session 03\n",
    "section": "\n9.1 Estimating \\(R_0\\)\n",
    "text": "9.1 Estimating \\(R_0\\)\n\nSo far in this class we have focused on the theory of infectious disease. Often, however, we will want to apply this theory to particular situations. One of the key applied problems in epidemic modeling is the estimation of \\(R_0\\) from outbreak data. In this session, we study two methods for estimating \\(R_0\\) from an epidemic curve. As a running example, we will use the data on influenza in a British boarding school.\n\nload(here::here(\"data\", \"R-estimation-data.RData\"))\n\nplot(\n  flu,\n  type = 'b',\n  log = 'y',\n  main = 'Epidemic in a British boarding school',\n  cex.main=0.85,\n  xlab='Day',\n  ylab='Active influenza cases'\n)"
  },
  {
    "objectID": "r-session-03.html#estimating-r_0-from-the-final-outbreak-size",
    "href": "r-session-03.html#estimating-r_0-from-the-final-outbreak-size",
    "title": "\n9  R Session 03\n",
    "section": "\n9.2 Estimating \\(R_0\\) from the final outbreak size",
    "text": "9.2 Estimating \\(R_0\\) from the final outbreak size\nOur first approach is to estimate \\(R_0\\) from the final outbreak size. Although unhelpful at the early stages of an epidemic (before the final epidemic size is observed), this method is nonetheless a useful tool for \\({post hoc}\\) analysis. The method is general and can be motivated by the following argument (Keeling and Rohani 2007): First, we assume that the epidemic is started by a single infectious individual in a completely susceptible population. On average, this individual infects \\(R_0\\) others. The probability a particular individual escaped infection is therefore \\(e^{-R_0/N}\\). If \\(Z\\) individuals have been infected, the probability of an individual escaping infection from all potential sources is \\(e^{-ZR_0/N}\\). It follows that at the end of the epidemic a proportion \\(R(\\infty)=Z/N\\) have been infected and the fraction remaining susceptible is \\(S(\\infty)=e^{-R(\\infty)R_0}\\), which is equal to \\(1-R(\\infty)\\), giving\n\\[\n  \\label{R0-estimator}\n  1 - R(\\infty) - e^{-R(\\infty)R_0} = 0\n\\]\nRearranging, we have the estimator\n\\[\n  \\label{R0-estimator-2}\n  \\hat{R_0} = \\frac{log(1-Z/N)}{-Z/N},\n\\]\nwhich, in this case, evaluates to \\(\\frac{log(1-512/764)}{-512/764} = 1.655\\).\n\n9.2.1 Exercise 1\nThis equation shows the important one-to-one relationship between \\(R_0\\) and the final epidemic size. Plot the relationship between the total epidemic size and \\(R_0\\) for the complete range of values between 0 and 1."
  },
  {
    "objectID": "r-session-03.html#linear-approximation",
    "href": "r-session-03.html#linear-approximation",
    "title": "\n9  R Session 03\n",
    "section": "\n9.3 Linear Approximation",
    "text": "9.3 Linear Approximation\nThe next method we introduce takes advantage of the fact that during the early stages of an outbreak, the number of infected individuals is given approximately as \\(Y(t) \\approx Y_0 e^{((R_0-1)(\\gamma + \\mu)t)}\\). Taking logarithms of both sides, we have \\(log(Y(t)) \\approx log(Y_0) + (R_0-1)(\\gamma + \\mu)t\\), showing that the log of the number of infected individuals is approximately linear in time with a slope that reflects both \\(R_0\\) and the recovery rate.\nThis suggests that a simple linear regression fit to the first several data points on a log-scale, corrected to account for \\(\\gamma\\) and \\(\\mu\\), provides a rough and ready estimate of \\(R_0\\). For flu, we can assume \\(\\mu =0\\) because the epidemic occurred over a time period during which natural mortality is negligible. Further, assuming an infectious period of about 2.5 days, we use \\(\\gamma = (2.5)^{-1} = 0.4\\) for the correction. Fitting to the first four data points, we obtain the slope as follows.\n\nmodel <- lm(log(flu[1:4]) ~ day[1:4], data = flu);  #fit a linear model\nsummary(model)         #summary statistics for fit model\n\n\nCall:\nlm(formula = log(flu[1:4]) ~ day[1:4], data = flu)\n\nResiduals:\n       1        2        3        4 \n 0.03073 -0.08335  0.07450 -0.02188 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)   \n(Intercept) -0.02703    0.10218  -0.265  0.81611   \nday[1:4]     1.09491    0.03731  29.346  0.00116 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.08343 on 2 degrees of freedom\nMultiple R-squared:  0.9977,    Adjusted R-squared:  0.9965 \nF-statistic: 861.2 on 1 and 2 DF,  p-value: 0.001159\n\nslope <- coef(model)[2]  #extract slope parameter\nslope                 #print to screen\n\nday[1:4] \n1.094913 \n\n\nRearranging the linear equation above and denoting the slope coefficient by \\(\\hat \\beta_1\\) we have the estimator \\(\\hat R_0 = \\hat \\beta_1 / \\gamma +1\\) giving \\(\\hat R_0=1.094913/0.4+1 \\approx 3.7\\).\n\n9.3.1 Exercise 2\nOur estimate assumes that boys remained infectious during the natural course of infection. The original report on this epidemic indicates that boys found to have symptoms were immediately confined to bed in the infirmary. The report also indicates that only 1 out of 130 adults at the school exhibited any symptoms. It is reasonable, then, to suppose that transmission in each case ceased once he had been admitted to the infirmary. Supposing admission happened within 24 hours of the onset of symptoms. How does this affect our estimate of \\(R_0\\)? Twelve hours?\n\n9.3.2 Exercise 3\nBiweekly data for outbreaks of measles in three communities in Niamey, Niger are provided in the dataframe \\(\\tt niamey\\). Use this method to obtain estimates of \\(R_0\\) for measles from the first community assuming that the infectious period is approximately two weeks or \\(14/365 \\approx 0.0384\\) years.\n\n9.3.3 Exercise 4\nA defect with this method is that it uses only a small fraction of the information that might be available, i.e., the first few data points. Indeed, there is nothing in the method that tells one how many data points to use–this is a matter of judgment. Further, there is a tradeoff in that as more and more data points are used the precision of the estimate increases, but this comes at a cost of additional bias. Plot the estimate of \\(R_0\\) obtained from \\(n=3, 4, 5, ...\\) data points against the standard error of the slope from the regression analysis to show this tradeoff."
  },
  {
    "objectID": "r-session-03.html#estimating-dynamical-parameters-with-least-squares",
    "href": "r-session-03.html#estimating-dynamical-parameters-with-least-squares",
    "title": "\n9  R Session 03\n",
    "section": "\n9.4 Estimating dynamical parameters with least squares",
    "text": "9.4 Estimating dynamical parameters with least squares\nThe objective of the previous exercise was to estimate \\(R_0\\). Knowing \\(R_0\\) is critical to understanding the dynamics of any epidemic system. It is, however, a composite quantity and is not sufficient to completely describe the epidemic trajectory. For this, we require estimates for all parameters of the model. In this exercise, we introduce a simple approach to model estimation called least squares fitting, sometimes called trajectory matching. The basic idea is that we find the values of the model parameters that minimize the squared differences between model predictions and the observed data. To demonstrate least squares fitting, we consider an outbreak of measles in Niamey, Niger, reported on by Grais et al. 2006 (Grais, R.F., et al. 2006. Estimating transmission intensity for a measles outbreak in Niamey, Niger: lessons for intervention. Transactions of the Royal Society of Tropical Medicine and Hygiene 100:867-873.).\n\nniamey[5,3] <- 0  #replace a \"NA\"\nniamey <- data.frame(\n  biweek = rep(seq(1, 16), 3),\n  site = c(rep(1, 16), rep(2, 16), rep(3, 16)),\n  cases = c(niamey[, 1], niamey[, 2], niamey[, 3])\n) #define \"biweeks\"\n\n\nplot(\n  niamey$biweek,\n  niamey$cases,\n  type='p',\n  col = niamey$site,\n  xlab = 'Biweek',\n  ylab = 'Cases'\n)\n\nlines(niamey$biweek[niamey$site == 1], niamey$cases[niamey$site == 1]) \nlines(niamey$biweek[niamey$site == 2], niamey$cases[niamey$site == 2],col = 2)\nlines(niamey$biweek[niamey$site == 3], niamey$cases[niamey$site == 3],col = 3)"
  },
  {
    "objectID": "r-session-03.html#dynamical-model",
    "href": "r-session-03.html#dynamical-model",
    "title": "\n9  R Session 03\n",
    "section": "\n9.5 Dynamical Model",
    "text": "9.5 Dynamical Model\nFirst, we write a specialized function for simulating the \\(SIR\\) model in a case where the removal rate is ``hard-wired’’ and with no demography.\n\nclosed_sir_model <- function (t, x, params) {  #SIR model equations\n  X <- x[1]\n  Y <- x[2]\n  beta <- params\n  dX <- - beta * X * Y\n  dY <- beta * X * Y -(365 / 13) * Y\n  \n  list(c(dX, dY))\n}"
  },
  {
    "objectID": "r-session-03.html#objective-function",
    "href": "r-session-03.html#objective-function",
    "title": "\n9  R Session 03\n",
    "section": "\n9.6 Objective function",
    "text": "9.6 Objective function\nNow we set up a function that will calculate the sum of the squared differences between the observations and the model at any parameterization (more commonly known as “sum of squared errors”). In general, this is called the objective function because it is the quantity that optimization seeks to minimize.\n\nsse_sir <- function(params0, data, site){  #function to calculate squared errors\n  data <- data[data$site == site, ]    #working dataset, based on site\n  t <- data[, 1] * 14 / 365            #time in biweeks\n  cases <- data[, 3]               #number of cases\n  beta <- exp(params0[1])            #parameter beta\n  X0 <- exp(params0[2])           #initial susceptibles\n  Y0 <- exp(params0[3])           #initial infected        \n  \n  out <- as.data.frame(\n    deSolve::ode(\n      c(X = X0, Y = Y0),\n      times = t,\n      closed_sir_model,\n      beta,\n      hmax = 1/120\n    )\n  )\n\n  sum((out$Y - cases)^2)       #sum of squared errors that is returned to the optim function\n}\n\nNotice that the code for sse_sir makes use of the following modeling trick. We know that \\(\\beta\\), \\(X_0\\), and \\(Y_0\\) must be positive, but our search to optimize these parameters will be over the entire number line. We could constrain the search using a more sophisticated algorithm, but this might introduce other problems (i.e., stability at the boundaries). Instead, we parameterize our objective function (sse_sir) in terms of some alternative variables \\(log(\\beta)\\), \\(log(X_0)\\), and \\(log(Y_0)\\). While these numbers range from \\(-\\infty\\) to \\(\\infty\\) (the range of our search) they map to our model parameters on a range from \\(0\\) to \\(\\infty\\) (the range that is biologically meaningful)."
  },
  {
    "objectID": "r-session-03.html#optimization",
    "href": "r-session-03.html#optimization",
    "title": "\n9  R Session 03\n",
    "section": "\n9.7 Optimization",
    "text": "9.7 Optimization\nOur final step is to use the function optim to find the values of \\(\\beta\\), \\(X_0\\), and \\(Y_0\\) that minimize the sum of squared errors as calculated using our function.\n\nparams0 <- c(-3.2, 7.3, -2.6)  #initial guess\nfit1 <- optim(params0, sse_sir, data = niamey, site = 1) #fit\nexp(fit1$par)  #back-transform parameters\n\n[1] 5.463181e-03 9.110385e+03 2.331841e+00\n\nfit2 <- optim(params0, sse_sir, data = niamey, site = 2) #fit\nexp(fit2$par)  #back-transform parameters\n\n[1] 8.666138e-03 6.276503e+03 2.843753e-01\n\nfit3 <- optim(params0, sse_sir, data = niamey, site = 3) #fit\n\nFinally, we plot these fits against the data.\n\npar(mfrow=c(3,1))   #set up plotting area for multiple panels\nplot(\n  cases ~ biweek,\n  data = subset(niamey, site == 1),\n  type = 'b',\n  col = 'blue',\n  pch = 21\n) #plot site 1\n\nt <- subset(niamey, site == 1)[, 1] * 14 / 365\n\nmod_pred <-as.data.frame(\n  deSolve::ode(\n    c(X = exp(fit1$par[2]),\n    Y = exp(fit1$par[3])),\n    times = t,\n    closed_sir_model,\n    exp(fit1$par[1]),\n    hmax=1/120\n  )\n)\n                              #obtain model predictions\nlines(mod_pred$Y ~ subset(niamey, site == 1)[, 1]) #and plot as a line\n\nplot(\n  cases ~ biweek,\n  data = subset(niamey, site == 2),\n  type = 'b',\n  col = site\n) #site 2\n\nt <- subset(niamey, site == 2)[, 1] * 14 / 365\n\nmod_pred <- as.data.frame(\n  deSolve::ode(\n    c(X = exp(fit2$par[2]), Y = exp(fit2$par[3])),\n    times = t,\n    closed_sir_model,\n    exp(fit2$par[1]),\n    hmax = 1/120\n  )\n)\n\nlines(mod_pred$Y ~ subset(niamey, site == 2)[, 1])\n\nplot(\n  cases ~ biweek,\n  data = subset(niamey, site == 3),\n  type = 'b',\n  col = site\n) #site 3\n\nt <- subset(niamey, site == 3)[, 1] * 14 / 365\n\nmod_pred <-as.data.frame(\n  deSolve::ode(\n    c(X = exp(fit3$par[2]), Y = exp(fit3$par[3])),\n    times = t,\n    closed_sir_model,\n    exp(fit3$par[1]),\n    hmax = 1/120\n  )\n)\n\nlines(mod_pred$Y ~ subset(niamey, site == 3)[, 1])\n\n\n\n\n\n9.7.1 Exercise 5\nTo make things easier, we have assumed the infectious period is known to be 14 days. In terms of years, \\(\\gamma = (365/14)^{-1} \\approx 0.0384\\). Now, modify the code above to estimate \\(\\gamma\\) and \\(\\beta\\) simultaneously.\n\n9.7.2 Exercise 6\nWhat happens if one or both of the other unknowns (\\(X_0\\) and \\(Y_0\\)) is fixed instead of \\(\\gamma\\)?"
  }
]