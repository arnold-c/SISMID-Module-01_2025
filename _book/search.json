[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "SISMID Module 2 Materials (2023)",
    "section": "",
    "text": "Welcome\nHello!\nWelcome to this website that accompanies the 2023 Summer Institute in Modeling for Infectious Diseases (SISMID) Module 2: Mathematical Models of Infectious Diseases. This website contains both the lecture notes, so you can refer back to them at a later date, and the exercises that we will be completing throughout the module."
  },
  {
    "objectID": "index.html#workshop-pre-requisites",
    "href": "index.html#workshop-pre-requisites",
    "title": "SISMID Module 2 Materials (2023)",
    "section": "Workshop Pre-Requisites",
    "text": "Workshop Pre-Requisites\nAs there is a reasonable amount of material to cover, and a relatively short amount of time to cover it in, there are some pre-requisite tasks to get set up ahead of the workshop.\n\n\n\n\n\n\nImportant\n\n\n\nEveryone should refer to the Exercise Requirements page, particularly the R Packages and Data Files sections to ensure you have the neccessary packages and data files installed for the exercises.\n\n\nFirstly, this workshop requires some prior understanding of the R programming languages, as well as a working installation of R. If you do not have any experience, please refer to the Installing R and The Basics of R pages of the Pre-Requisites section.\nIt is also highly recommended that you read the Setting Up A Project page for how to structure your code as you go through the exercises: we provide some guidelines to make your code easier to understand and navigate, both for yourself, and for others.\nPlease set aside about an hour to go through these materials and get set up. You should be able to do this in about 15 minutes if you are already experienced with R, but as with all things computational, it’s worth including some buffer time in case you run into issues. If you are completely new to R, this could take an hour or so, but is certainly worth the time investment: it will be hard to follow some of the exercises if you do not understand what the code is doing."
  },
  {
    "objectID": "index.html#keywords-code-and-other-formatting",
    "href": "index.html#keywords-code-and-other-formatting",
    "title": "SISMID Module 2 Materials (2023)",
    "section": "Keywords, Code, and Other Formatting",
    "text": "Keywords, Code, and Other Formatting\nThroughout the book, you’ll see some keywords, code, and other points that I’ll try to delineate with the following formatting:\n\n\n\n\n\n\nNote\n\n\n\nThis will be a note, and will be used to highlight important points, or to provide additional information.\n\n\n\n\n\n\n\n\nSET\n\n\n\nThis will be an instruction to set certain parameters or values in the R code, or for the interactive plots.\n\n\n\n\n\n\n\n\nInstruction\n\n\n\nThis will be a general instruction.\n\n\n\n\n\n\n\n\nTip\n\n\n\nThis will be used to highlight a useful tip.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThis will provide a warning that you may get an unexpected result if you’re not careful.\n\n\nIt is worth noting that some of these callouts may be collapsible. You can tell a callout is collapsible if there is a little &gt; or ⋁ in the top right corner of the callout i.e.,\n\n\n\n\n\n\nNote\n\n\n\n\n\nThis is an example of a collapsible callout that defaults to being collapsed.\n\n\n\n\ncode will be used to highlight code.\n{package::function()} will be used to denote a specific package and function, e.g., {dplyr::mutate()} denotes the mutate() function from the {dplyr} package.\n\nOften the function() will be listed without the package, as there are library() calls at the top of each page indicating the packages used in that page, and the majority of functions will not cause conflicts, i.e., there are not packages with functions of the same name.\n\nBold will be used to highlight keywords and phrases, e.g., Git or GitHub.\n\nBold will also be highlighted in this way, e.g., commits or pushed being the result of the code git commit or git push\n\nBold-italics will be used to highlight file names, e.g., README.md or LICENSE.\nItalics will be used for emphasis in certain circumstances, e.g., signifying a question from an interactive terminal command."
  },
  {
    "objectID": "index.html#about-the-instructors",
    "href": "index.html#about-the-instructors",
    "title": "SISMID Module 2 Materials (2023)",
    "section": "About the Instructors",
    "text": "About the Instructors\n\n\n\nDr. Micaela Martinez\n\n\nDr. Matinez is the Director of Environmental Health at WE ACT for Environmental Justice.\nDr. Martinez earned her Ph.D. in Ecology & Evolution in 2015 at the University of Michigan, and did her postdoctoral training at Princeton University. Before joining WE ACT, she served as an Assistant Professor at Columbia University Mailman School of Public Health, followed by Emory University, in the Dept. of Biology. Since 2017, Dr. Martinez has been supported by the prestigious NIH Director’s Early Independence Award. Over the past decade, her research has focused on infectious disease ecology, climate change, maternal and infant health, social justice, and environmental impacts on health (including biological rhythms).\n\n\n\nDr. Matt Ferrari\n\n\nDr. Ferrari is the Director of the Center for Infectious Disease Dynamics at The Pennsylvania State University.\nDr Ferrari’s lab does research on both the application of quantitative modeling and analysis to inform public health policy and the basic ecology of parasites and infectious diseases at the Center for Infectious Disease Dynamics at The Pennsylvania State University.\n\n\n\n\n\n\n\n\n\nCallum Arnold\n\n\nCallum is a 3rd Year PhD student in Dr. Ferrari’s lab at the Pennsylvania State University.\nCallum’s work examines how the methods used to define groups and differences among individuals affect the understanding and detection of outbreaks."
  },
  {
    "objectID": "exercise-requirements.html#r-packages",
    "href": "exercise-requirements.html#r-packages",
    "title": "Exercise Requirements",
    "section": "R Packages",
    "text": "R Packages\nIf you use renv to manage package dependencies in your projects, you can visit the GitHub repository for this project and download the renv.lock, .Rprofile, and renv/activate.R files, before running the command renv::restore(). Alternatively, if you already use GitHub, you could clone the project and just run renv::restore().\nIf you would prefer to just install the packages manually to avoid the complications associated with using renv, you can install the packages printed below.\n\nCodeinstall.packages(c(\n    \"tidyverse\",\n    \"deSolve\",\n    \"diagram\",\n    \"gt\",\n    \"ggtext\",\n    \"here\",\n    \"rio\"\n))"
  },
  {
    "objectID": "exercise-requirements.html#data-files",
    "href": "exercise-requirements.html#data-files",
    "title": "Exercise Requirements",
    "section": "Data Files",
    "text": "Data Files\nTo complete the exercises, some data files are required. The exercises should load the datafiles via urls, but if you would prefer to download them to your own machine, your are welcome to do so. To download the files, go to the GitHub repository and download the files in the data/ folder of your repository. You should then uncomment the lines of code that run ...  &lt;- rio::import(here::here(\"data\", ...)), and comment out the lines that include the URLs."
  },
  {
    "objectID": "r-session-01.html#sec-interactive-plots",
    "href": "r-session-01.html#sec-interactive-plots",
    "title": "\n3  R Session 01\n",
    "section": "\n3.1 Interactive Plot",
    "text": "3.1 Interactive Plot\n\nCodeinit_beta = 0.3\ninit_dur_inf = 6.0\ninit_I0 = 0.01\ninit_births = 0.0\ninit_tmax = 200\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodefunction set(input, value) {\n  input.value = value;\n  input.dispatchEvent(new Event(\"input\", {bubbles: true}));\n}\n\n\n\n\n\n\n\n\nCodeviewof reset = Inputs.button([\n  [\"Reset all sliders\", () =&gt; {\n    set(viewof beta, init_beta)\n    set(viewof dur_inf, init_dur_inf)\n    set(viewof I0, init_I0)\n    set(viewof births, init_births)\n    set(viewof tmax, init_tmax)\n  }]\n])\n\nviewof beta = Inputs.range(\n  [0.0, 2.0],\n  {value: init_beta, step: 0.01, label: \"Transmission rate (per day)\"}\n)\n\nviewof dur_inf = Inputs.range(\n  [0.0, 20],\n  {value: init_dur_inf, step: 0.5, label: \"Duration of Infection (days)\"}\n)\n\nviewof I0 = Inputs.range(\n  [0.0, 1.0],\n  {value: init_I0, step: 0.01, label: \"Initial fraction infected\"}\n)\n\nviewof births = Inputs.range(\n  [0, 0.05],\n  {value: init_births, step: 0.001, label: \"Birth rate\"}\n)\n\nviewof tmax = Inputs.range(\n  [200, 600],\n  {value: init_tmax, step: 10.0, label: \"Maximum simulation time (years)\"}\n)\n\nviewof area = Inputs.toggle(\n  {label: \"Cumulative Area plot\", value: false}\n)\n\nmd`${tex`R_0 = ${R0_str}`}`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode{\n  if (births == 0){\n    var finalsize = sir_sol.get(\"R\", sir_sol.numRows()-1)\n    var finalsize_str = finalsize.toLocaleString(undefined, {minimumFractionDigits: 2})\n\n    return md`${tex`\\text{Final size} = ${finalsize_str}`}`\n  } else {\n    return md``\n  }\n}\n\n\n\n\n\n\n\n\n\n\nCodegamma = 1 / dur_inf\ndt = 0.01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodeimport {odeRK4} from '@rreusser/integration@3064'\nimport { aq, op } from '@uwdata/arquero'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodefunction sir(dydt, y, t) {\n  dydt[0] = - beta * y[0] * y[1] + births * (1 - y[0])\n  dydt[1] = beta * y[0] * y[1] - gamma * y[1] - births * y[1]\n  dydt[2] = gamma * y[1] - births * y[2]\n}\n\n\n\n\n\n\n\nCodefunction simulate(f, t0, y0, dt, tmax) {\n  var t = t0\n  var y = y0\n  var i = 0\n\n  var tsim = [t0]\n  var ysim = [y0]\n\n  for (t = t0 + dt; t &lt;= tmax; t += dt) {\n    ysim.push(odeRK4([], ysim[i], f, dt))\n    tsim.push(t)\n    i += 1\n  }\n  \n  return aq.table({\n    Time: tsim,\n    S: ysim.map(d =&gt; d[0]),\n    I: ysim.map(d =&gt; d[1]),\n    R: ysim.map(d =&gt; d[2])\n    })\n}\n\n\n\n\n\n\n\nCodesir_sol = simulate(sir, 0, [1.0-I0, I0, 0.0], dt, tmax)\nsir_sol_long = sir_sol.fold(aq.not('Time'), {as: ['State', 'Fraction']})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodeSIRcolors = [\"#1f77b4\", \"#ff7f0e\", \"#FF3851\"]\n\n\n\n\n\n\n\nCodeR0 = beta / (gamma + births)\nR0_str = R0.toLocaleString(undefined, {minimumFractionDigits: 2})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodefunction calculate_equil(R0){\n  if (births &gt; 0) {\n    var eq_S = 1 / R0\n    var eq_I = births / beta * (R0 - 1)\n    var eq_R = 1 - (eq_S + eq_I)\n\n    const eq_vals = aq.table({\n      State: [\"S\", \"I\", \"R\"],\n      Fraction: [eq_S, eq_I, eq_R]\n    })\n\n    return eq_vals\n  } else {\n    return null\n  }\n}\n\n\n\n\n\n\n\nCodeeq_vals = calculate_equil(R0)\n\n\n\n\n\n\n\n\n\nCodePlot.plot({\n  color: {\n    legend: true,\n    domain: [\"S\", \"I\", \"R\"],\n    range: SIRcolors\n  },\n  style: {fontSize: \"20px\"},\n  marginLeft: 65,\n  marginTop: 40,\n  marginBottom: 55,\n  grid: true,\n  width: 800,\n  height: 670,\n  y: {domain: [0, 1]},\n  marks: [\n    area ?\n      Plot.areaY(sir_sol_long, {x: \"Time\", y: \"Fraction\", fill: \"State\"}) :\n      [\n        R0 &gt;= 1.0 && births &gt; 0 ?\n        Plot.ruleY(\n          eq_vals,\n          {y: \"Fraction\", stroke: \"State\", strokeWidth: 2, strokeDasharray: [10]}\n        ) :\n        null,\n        Plot.lineY(\n          sir_sol_long,\n          {x: \"Time\", y: \"Fraction\", stroke: \"State\", strokeWidth: 6}\n        )\n      ]\n  ]\n})"
  },
  {
    "objectID": "r-session-01.html#closed-population-model-intuition",
    "href": "r-session-01.html#closed-population-model-intuition",
    "title": "\n3  R Session 01\n",
    "section": "\n3.2 Closed Population Model Intuition",
    "text": "3.2 Closed Population Model Intuition\nWe’ll first get develop an intuition for the closed population model. We’ll then extend this intuition to the open population model. When the Birth rate slider in the side panel of the interactive figure is set to 0, we have no births or deaths, so their is no replenishment of the susceptible population i.e., it is a closed population.\n\n\n\n\n\n\nSET\n\n\n\nTransmission rate = 1\nDuration of infection = 4.\n\n\n\n3.2.1 What is \\(R_0\\)?\n\n3.2.2 What is epidemic final size?\n\n3.2.3 Does this make sense given our definition of \\(R_0\\)?\n\n\n\n\n\n\nInstruction\n\n\n\nToggle on the cumulative area button and see what the epidemic final size is (approximately)\n\n\n\n3.2.4 At approximately what time does the epidemic end?\n\n\n\n\n\n\nSET\n\n\n\nDuration of infection = 8 days\nTransmission rate so you get the same \\(R_0\\) in Section 3.2.1\n\n\n\n3.2.5 How does the epidemic final size compare?\n\n3.2.6 At what time (approx) does the epidemic end?\n\n\n\n\n\n\nNote\n\n\n\nSize is determined by \\(R_0\\), duration is determined by recovery rate \\(\\left(\\gamma = \\frac{1}{\\text{duration of infection}}\\right)\\)\n\n\nNow, imagine that we have a drug (or vaccine) available to everyone that either reduced transmission OR shortened the duration of infection.\n\n\n\n\n\n\nSET\n\n\n\nTransmission rate = 1\nDuration of infection = 8 days\n\n\n\n3.2.7 Note the epidemic final size and the time until the epidemic is over.\nNow, imagine everyone has access to the drug (unrealistic) that reduces transmission by \\(P \\%\\)\n\n3.2.8 What happens to the final size and outbreak duration?\nNow, imagine everyone has access to a drug that reduces the duration of infection from 8 to 2 days (75% reduction).\n\n3.2.9 What happens to the final size and outbreak duration?\n\n3.2.10 Which assumption would you prefer and why?\n\n\n\n\n\n\nNote\n\n\n\nThis is the only really open ended question, but should be pretty straightforward discussion"
  },
  {
    "objectID": "r-session-01.html#demographic-model-intuition",
    "href": "r-session-01.html#demographic-model-intuition",
    "title": "\n3  R Session 01\n",
    "section": "\n3.3 Demographic Model Intuition",
    "text": "3.3 Demographic Model Intuition\n\n\n\n\n\n\nSET\n\n\n\nTransmission = 1\nDuration = 8\nBirth rate = .002\n\n\n\n3.3.1 What is \\(R_0\\)?\n\n3.3.2 What is the equilibrium proportion that is susceptible?\n\n3.3.3 If you were to test for antibodies against infection in the population, what proportion would you expect to be positive?\n\n\n\n\n\n\nNote\n\n\n\nAssume a perfectly accurate serological test\n\n\n\n3.3.4 At what time (approximately) does the system reach equilibrium?\n\n\n\n\n\n\nSET\n\n\n\nBirth rate = 0.005\n\n\n\n3.3.5 What is the new \\(R_0\\)?\n\n3.3.6 At what time (approximately) does the system reach equilibrium?\n\n\n\n\n\n\nSET\n\n\n\nTransmission rate so you get the same \\(R_0\\) in Section 3.3.1\n\n\n\n3.3.7 What is the new equilibrium proportion that is susceptible?\n\n3.3.8 What is different about the prevalence of infection (equilibrium proportion that is infected) in the scenarios Section 3.3.1 and Section 3.3.5 i.e. higher birth rate with the same \\(R_0\\)?"
  },
  {
    "objectID": "r-session-01.html#model-building-with-r",
    "href": "r-session-01.html#model-building-with-r",
    "title": "\n3  R Session 01\n",
    "section": "\n3.4 Model Building With R",
    "text": "3.4 Model Building With R\n\n3.4.1 Setting Up A Script\nNow we have some intuition behind how the different parameters affect the dynamics of the SIR system, let’s look at how we can implement this in R. Below is some R code that implements the basic closed-population SIR model. The purpose of the questions in this exercise is to guide you through the code and help you understand how it works so you can modify it to answer your own questions.\n\n\n\n\n\n\n\nInstruction\n\n\n\nCopy the code below into a new R script. This script should live in your SISMID directory, as described previously. Run it to check you get the same figure output as above.\n\n\n\nCodelibrary(tidyverse)\nlibrary(deSolve)\n\ntheme_set(theme_minimal())\n\nsir_model &lt;- function(time, state, params, ... ){\n  transmission &lt;- params[\"transmission\"]\n  recovery &lt;- 1 / params[\"duration\"]\n\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n\n  dSdt &lt;- -transmission * S * I\n  dIdt &lt;- (transmission * S * I) - (recovery * I)\n  dRdt &lt;- recovery * I\n\n  return(list(c(dSdt, dIdt, dRdt)))\n}\n\nsir_params &lt;- c(transmission = 0.3, duration = 6)\nsir_init_states &lt;- c(S = 0.99, I = 0.01, R = 0)\nsim_times &lt;- seq(0, 200, by = 0.1)\n\nsir_sol &lt;- deSolve::ode(\n  y = sir_init_states,\n  times = sim_times,\n  func = sir_model,\n  parms = sir_params\n)\n\n# Turn the output from the ODE solver into a tibble (dataframe)\n# so we can manipulate and plot it easily\nsir_sol_df &lt;- as_tibble(sir_sol) %&gt;%\n  # Convert all columns to numeric (they are currently type\n  # deSolve so will produce warnings when plotting etc)\n  mutate(\n    # Rather than repeatedly type the same function for every\n    # column, use the across() function to apply the function\n    # to a selection of columns\n    across(\n      # The cols argument takes a selection of columns to apply\n      # a function to. Here, we want to apply the as.numeric()\n      # function to all columns, so we use the function\n      # everything() to select all columns.\n      .cols = everything(),\n      .fns = as.numeric\n    )\n  ) %&gt;%\n  # Convert the dataframe from wide to long format, so we have a\n  # column for the time, a column for the state, and a column\n  # for the proportion of the population in that state at that\n  # time\n  pivot_longer(\n    # Don't pivot the time column\n    cols = -time,\n    names_to = \"state\",\n    values_to = \"proportion\"\n  ) %&gt;%\n  # Update the state column to be a factor, so the plot will\n  # show the states in the correct order\n  mutate(state = factor(state, levels = c(\"S\", \"I\", \"R\")))\n\nSIRcolors &lt;- c(S = \"#1f77b4\", I = \"#ff7f0e\", R = \"#FF3851\")\n\nggplot(sir_sol_df, aes(x = time, y = proportion, color = state)) +\n  geom_line(linewidth = 1.5) +\n  scale_color_manual(values = SIRcolors) +\n  labs(\n    x = \"Time\",\n    y = \"Fraction\",\n    color = \"State\"\n  ) +\n  theme(legend.position = \"top\")\n\n\n\n\n\n3.4.2 Commenting the code\nFor this part of the exercise, go through the basic SIR code and add comments to each section of code explaining what it does. To get you started, we’ve added some comments to the creating of the dataframe object sir_sol_df between lines 32-62 in the code block above, as some of the functions used there are a bit more complicated.\n\n\n\n\n\n\nNote\n\n\n\nNormally you would not use nearly as extensive comments. Here, we’ve gone overboard to help you understand what each line does, as some may not be familiar with all the functions used. We’ve also broken up the comments into multiple lines so that it is easier to read on this website. For your code that you view in RStudio (or some other text editor), use one line per sentence of the comment i.e., start a new comment line after each period.\nGenerally, you want to use comments to explain why you are doing something, not what you are doing. Sometimes that is unavoidable (e.g., you had to look up how to do a particular thing in R and need the hints to be able to understand the code), but try to stick to this guideline where possible.\n\n\nAs you’re going through the code, if you don’t understand what a particular function does, try looking up the documentation for it! You can do this by clicking on the function within the website (as described above), or by typing ?function_name into the R console (Google also is your friend here!).\n\n3.4.3 Adding in demographics\nNow we have a better sense of how the code works, let’s add in some demographic structure. To recreate the demographic model from the interactive plot in Section 3.1, we just need to add births and deaths to the system.\nRecall the equations for the demographic model:\n\\[\n\\begin{aligned}\n\\frac{dS}{dt} &= \\mu N - \\beta S I - \\mu S \\\\\n\\frac{dI}{dt} &= \\beta S I - \\gamma I - \\mu I \\\\\n\\frac{dR}{dt} &= \\gamma I - \\mu R\n\\end{aligned}\n\\tag{3.1}\\]\n\n3.4.3.1 Create a new R script called 01_demographic-sir.R and copy the code from S01_basic-sir.R into it.\n\n3.4.3.2 Rename the function sir_model() to demographic_sir_model() in your new script (S01_demographic-sir.R).\n\n3.4.3.3 Adapt the function demographic_sir_model() to match the above equations (Equation 3.1).\n\n\n\n\n\n\nSET\n\n\n\nbirth rate = 0.05\n\n\n\n3.4.3.4 Rename the variables to reflect that we are now working with a demographic model, not the basic SIR model.\n\n3.4.3.5 Plot the results of your demographic model. Does it look like this?\n\n\n\n\n\n\n3.4.3.6 Update the comments in your code to reflect the changes you have made."
  },
  {
    "objectID": "r-session-01.html#exercise-solutions",
    "href": "r-session-01.html#exercise-solutions",
    "title": "\n3  R Session 01\n",
    "section": "\n3.5 Exercise Solutions",
    "text": "3.5 Exercise Solutions\n\n\n\n\n\n\nNote\n\n\n\nHere, we’re using the roxygen2 package to create the comments for the functions we’ve created, i.e., sir_model &lt;- function(...). This provides a consistent framework for commenting functions, and if we wanted, we could use the comments to create documentation for our functions. The main benefit for our purposes is that the framework allows us to quickly understand exactly what the function does, as well as the context it should be used in.\n\n\n\n3.5.1 Section 3.4.2: Commented basic SIR code\n\nCode# Load packages\nlibrary(tidyverse)\nlibrary(deSolve)\n\n# Set the ggplot2 theme\ntheme_set(theme_minimal())\n\n#' Basic SIR model\n#'\n#' A basic SIR model with no demographic structure to be used in deSolve\n#'\n#' @param time deSolve passes the time parameter to the function.\n#' @param state A vector of states.\n#' @param params A vector of parameter values .\n#' @param ... Other arguments passed by deSolve.\n#'\n#' @return A deSolve matrix of states at each time step.\n#' @examples\n#' sir_params &lt;- c(transmission = 0.3, duration = 6)\n#' sir_init_states &lt;- c(S = 0.99, I = 0.01, R = 0)\n#' sim_times &lt;- seq(0, 200, by = 0.1)\n#' \n#' sir_sol &lt;- deSolve::ode(\n#'    y = sir_init_states,\n#'    times = sim_times,\n#'    func = sir_model,\n#'    parms = sir_params\n#' ))\nsir_model &lt;- function(time, state, params, ... ){\n  # Extract parameters for cleaner calculations\n  transmission &lt;- params[\"transmission\"]\n  recovery &lt;- 1 / params[\"duration\"]\n\n  # Extract states for cleaner calculations\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n\n  # Differential equations of the SIR model\n  dSdt &lt;- -transmission * S * I\n  dIdt &lt;- (transmission * S * I) - (recovery * I)\n  dRdt &lt;- recovery * I\n\n  # Return a list whose first element is a vector of the\n  # state derivatives - must be in the same order as the\n  # state vector (S, I, R)\n  return(list(c(dSdt, dIdt, dRdt)))\n}\n\n# Create the parameter, initial state, and time vectors\nsir_params &lt;- c(transmission = 0.3, duration = 6)\nsir_init_states &lt;- c(S = 0.99, I = 0.01, R = 0)\nsim_times &lt;- seq(0, 200, by = 0.1)\n\n# Solve the SIR model with deSolve's ode() function\nsir_sol &lt;- deSolve::ode(\n  y = sir_init_states,\n  times = sim_times,\n  func = sir_model,\n  parms = sir_params\n)\n\n# Turn the output from the ODE solver into a tibble (dataframe)\n# so we can manipulate and plot it easily\nsir_sol_df &lt;- as_tibble(sir_sol) %&gt;%\n  # Convert all columns to numeric (they are currently type\n  # deSolve so will produce warnings when plotting etc)\n  mutate(\n    # Rather than repeatedly type the same function for every\n    # column, use the across() function to apply the function\n    # to a selection of columns\n    across(\n      # The cols argument takes a selection of columns to apply\n      # a function to. Here, we want to apply the as.numeric()\n      # function to all columns, so we use the function\n      # everything() to select all columns.\n      .cols = everything(),\n      .fns = as.numeric\n    )\n  ) %&gt;%\n  # Convert the dataframe from wide to long format, so we have a\n  # column for the time, a column for the state, and a column\n  # for the proportion of the population in that state at that\n  # time\n  pivot_longer(\n    # Don't pivot the time column\n    cols = -time,\n    names_to = \"state\",\n    values_to = \"proportion\"\n  ) %&gt;%\n  # Update the state column to be a factor, so the plot will\n  # show the states in the correct order\n  mutate(state = factor(state, levels = c(\"S\", \"I\", \"R\")))\n\n# Save the colors to a vector\nSIRcolors &lt;- c(S = \"#1f77b4\", I = \"#ff7f0e\", R = \"#FF3851\")\n\n# Plot the results\nggplot(sir_sol_df, aes(x = time, y = proportion, color = state)) +\n  geom_line(linewidth = 1.5) +\n  scale_color_manual(values = SIRcolors) +\n  labs(\n    x = \"Time\",\n    y = \"Fraction\",\n    color = \"State\"\n  ) +\n  theme(legend.position = \"top\")\n\n\n\n3.5.2 Section 3.4.3: Commented demographic SIR code\n\nCode# Load packages\nlibrary(tidyverse)\nlibrary(deSolve)\n\n# Set the ggplot2 theme\ntheme_set(theme_minimal())\n\n#' Demographic SIR model\n#'\n#' An SIR model with births and deaths (constant pop) to be used in deSolve\n#'\n#' @param time deSolve passes the time parameter to the function.\n#' @param state A vector of states.\n#' @param params A vector of parameter values .\n#' @param ... Other arguments passed by deSolve.\n#'\n#' @return A deSolve matrix of states at each time step.\n#' @examples\n#' sir_params &lt;- c(transmission = 0.3, duration = 6, birth_rate = 0.05)\n#' sir_init_states &lt;- c(S = 0.99, I = 0.01, R = 0)\n#' sim_times &lt;- seq(0, 200, by = 0.1)\n#' \n#' sir_sol &lt;- deSolve::ode(\n#'    y = sir_init_states,\n#'    times = sim_times,\n#'    func = sir_demog_model,\n#'    parms = sir_params\n#' ))\nsir_demog_model &lt;- function(time, state, params, ... ){\n  transmission &lt;- params[\"transmission\"]\n  recovery &lt;- 1 / params[\"duration\"]\n  birth_rate &lt;- params[\"birth_rate\"]\n\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n\n  dSdt &lt;- birth_rate -transmission * S * I - (birth_rate * S)\n  dIdt &lt;- (transmission * S * I) - (recovery * I) - (birth_rate * I)\n  dRdt &lt;- (recovery * I) - (birth_rate * R)\n\n  return(list(c(dSdt, dIdt, dRdt)))\n}\n\n# Create the parameter, initial state, and time vector\nsir_demog_params &lt;- c(transmission = 0.3, duration = 6, birth_rate = 0.05)\nsir_init_states &lt;- c(S = 0.99, I = 0.01, R = 0)\nsim_times &lt;- seq(0, 200, by = 0.1)\n\n# Solve the SIR model with deSolve's ode() function\nsir_demog_sol &lt;- deSolve::ode(\n  y = sir_init_states,\n  times = sim_times,\n  func = sir_demog_model,\n  parms = sir_demog_params\n)\n\n# Turn the output from the ODE solver into a tibble (dataframe)\n# so we can manipulate and plot it easily\nsir_demog_sol_df &lt;- as_tibble(sir_demog_sol) %&gt;%\n  # Convert all columns to numeric (they are currently type\n  # deSolve so will produce warnings when plotting etc)\n  mutate(\n    # Rather than repeatedly type the same function for every\n    # column, use the across() function to apply the function\n    # to a selection of columns\n    across(\n      # The cols argument takes a selection of columns to apply\n      # a function to. Here, we want to apply the as.numeric()\n      # function to all columns, so we use the function\n      # everything() to select all columns.\n      .cols = everything(),\n      .fns = as.numeric\n    )\n  ) %&gt;%\n  # Convert the dataframe from wide to long format, so we have a\n  # column for the time, a column for the state, and a column\n  # for the proportion of the population in that state at that\n  # time\n  pivot_longer(\n    # Don't pivot the time column\n    cols = -time,\n    names_to = \"state\",\n    values_to = \"proportion\"\n  ) %&gt;%\n  # Update the state column to be a factor, so the plot will\n  # show the states in the correct order\n  mutate(state = factor(state, levels = c(\"S\", \"I\", \"R\")))\n\n# Save the colors to a vector\nSIRcolors &lt;- c(S = \"#1f77b4\", I = \"#ff7f0e\", R = \"#FF3851\")\n\n# Plot the results\nggplot(sir_demog_sol_df, aes(x = time, y = proportion, color = state)) +\n  geom_line(linewidth = 1.5) +\n  scale_color_manual(values = SIRcolors) +\n  labs(\n    x = \"Time\",\n    y = \"Fraction\",\n    color = \"State\"\n  ) +\n  theme(legend.position = \"top\")"
  },
  {
    "objectID": "r-session-02.html#load-packages",
    "href": "r-session-02.html#load-packages",
    "title": "\n7  R Session 02\n",
    "section": "\n7.1 Load Packages",
    "text": "7.1 Load Packages\n\nCodelibrary(diagram)\nlibrary(deSolve)\nlibrary(tidyverse)\nlibrary(gt)\nlibrary(rio)\n\n\n\nCodetheme_set(theme_minimal())"
  },
  {
    "objectID": "r-session-02.html#a-model-with-2-classes",
    "href": "r-session-02.html#a-model-with-2-classes",
    "title": "\n7  R Session 02\n",
    "section": "\n7.2 A Model With 2 Classes",
    "text": "7.2 A Model With 2 Classes\nWe’ll start with the simplest mechanistic model of two classes we can think of, which has separate classes for two groups \\(a\\) and \\(b\\). These groups could represent different socioeconomic classes, for example.\n\n\n\n\n\nWhich can be written in equations as, \\[\n\\begin{aligned}\n    \\frac{\\dd{S_a}}{\\dd{t}} &= -\\lambda_a\\,S_a \\phantom{-\\gamma\\,I_b}\\\\\n    \\frac{\\dd{S_b}}{\\dd{t}} &= -\\lambda_b\\,S_b \\phantom{-\\gamma\\,I_b}\\\\\n    \\frac{\\dd{I_a}}{\\dd{t}} &= \\phantom{-}\\lambda_a\\,S_a -\\gamma\\,I_a\\\\\n    \\frac{\\dd{I_b}}{\\dd{t}} &= \\phantom{-}\\lambda_b\\,S_b-\\gamma\\,I_b\\\\\n    \\frac{\\dd{R_a}}{\\dd{t}} &= \\phantom{-\\lambda_a\\,S_b}+\\gamma\\,I_a\\\\\n    \\frac{\\dd{R_b}}{\\dd{t}} &= \\phantom{-\\lambda_a\\,S_b}+\\gamma\\,I_b\\\\\n  \\end{aligned}\n\\]\nThe \\(\\lambda\\)s denote the group-specific force of infections:\n\\[\n\\begin{aligned}\n        \\lambda_a &= \\beta_{aa}\\,I_a+\\beta_{ab}\\,I_b\\\\\n        \\lambda_b &= \\beta_{ba}\\,I_a+\\beta_{bb}\\,I_b\n\\end{aligned}\n\\]\nIn this model, each population can infect each other but the infection moves through the populations separately. Let’s simulate such a model. To make things concrete, we’ll assume that the transmission rates \\(\\beta\\) are greater within groups than between them.\n\nCode# Create a named parameter vector that we can index by name in the model\nab_params &lt;- c(\n    beta_within = 0.025,\n    beta_between = 0.005,\n    recovery = 10\n)\n\n\n\nCode# Here we set up the ODE model that matches the equations above\nab_model &lt;- function (t, x, p, ...) {\n    # Unpack the state variables\n    Sa &lt;- x[\"Sa\"]\n    Sb &lt;- x[\"Sb\"]\n    Ia &lt;- x[\"Ia\"]\n    Ib &lt;- x[\"Ib\"]\n    \n    # Unpack the parameters\n    beta_within &lt;- p[\"beta_within\"]\n    beta_between &lt;- p[\"beta_between\"]\n    recovery &lt;- p[\"recovery\"]\n\n    # group A force of infection\n    lambda_a &lt;- beta_within * Ia + beta_between * Ib\n\n    # group B force of infection\n    lambda_b &lt;- beta_within * Ib + beta_between * Ia\n    \n    # The ODEs\n    dSadt &lt;- - lambda_a * Sa\n    dSbdt &lt;- - lambda_b * Sb\n    dIadt &lt;- lambda_a * Sa - recovery * Ia\n    dIbdt &lt;- lambda_b * Sb - recovery * Ib\n    dRadt &lt;- recovery * Ia\n    dRbdt &lt;- recovery * Ib\n\n    # Return the derivatives\n    list(c(\n        dSadt,\n        dSbdt,\n        dIadt,\n        dIbdt,\n        dRadt,\n        dRbdt\n    ))\n}\n\n\n\nCode# initial conditions\nab_yinit &lt;- c(Sa = 1000, Sb = 2000, Ia = 1, Ib = 1, Ra = 0, Rb = 0)\n\n# Run the ODE solver from the deSolve package\nab_sol &lt;- deSolve::ode(\n    y = ab_yinit,\n    times = seq(0, 2, by = 0.001),\n    func = ab_model,\n    parms = ab_params,\n)\n\n\n\nCodeab_df &lt;- ab_sol %&gt;%\n    # Convert the solution to a tibble for manipulation\n    as_tibble() %&gt;%\n    # Create and modify columns\n    mutate(\n        # Convert all columns into type numeric\n        across(everything(), as.numeric),\n        # Create new columns to track pop sizes in each group\n        Na = Sa + Ia + Ra,\n        Nb = Sb + Ib + Rb\n    ) %&gt;%\n    # Go from a wide to long dataframe for ggplot\n    pivot_longer(\n        cols = -time,\n        names_to = c(\"state\", \"group\"),\n        names_sep = 1,\n        values_to = \"value\"\n    ) %&gt;%\n    # Clean pivoted columns for ordered plots\n    mutate(\n        state = factor(state, levels = c(\"S\", \"I\", \"R\", \"N\")),\n        group = paste(\"Group\", str_to_upper(group))\n    )\n\n\n\nCode# Create a vector of colors to be used throughout the ggplots\nSIRcolors &lt;- c(\"#1f77b4\", \"#ff7f0e\", \"#FF3851\", \"#591099\")\n\nggplot(ab_df, aes(x = time, y = value, color = state)) +\n    geom_line(linewidth = 1.5) +\n    facet_wrap(~group, scales = \"free_y\") +\n    scale_color_manual(\n        values = SIRcolors,\n        labels = c(\"Susceptible\", \"Infected\", \"Recovered\", \"Total\")\n    ) +\n    labs(\n        x = \"Time\",\n        y = \"Number of individuals\",\n        color = \"State\"\n    ) +\n    theme(legend.position = \"bottom\")\n\n\n\n\n\nDespite using the same transmission rates, the epidemic in group B is much larger than in group A. Why do you think this is?\n\nNow let’s plot the proportion of individuals in each state for the two groups.\n\nCodeab_df_props &lt;- ab_df %&gt;%\n    # Remove total pop count as we only want the group-specific values\n    filter(state != \"N\") %&gt;%\n    mutate(\n        # Concatenate the state variable and the group letter for each row\n        state_group = paste0(state, str_extract_all(group, \"[^Group ]\")),\n        # Factor new variable for nicer plotting\n        state_group = factor(state_group, levels = c(\"RA\", \"RB\", \"IA\", \"IB\", \"SA\", \"SB\"))\n    ) %&gt;%\n    # Group by time and state_group so we can calculate the relevant proportions over time\n    group_by(time, state_group) %&gt;%\n    mutate(\n        prop = value / sum(ab_yinit)\n    ) %&gt;%\n    ungroup()\n\n\n\nCode# Create new vectors of colors as using 6: one of each for A and J groups\nScolors &lt;- RColorBrewer::brewer.pal(3, \"Blues\")[c(2, 3)]\nIcolors &lt;- RColorBrewer::brewer.pal(3, \"Oranges\")[c(2, 3)]\nRcolors &lt;- RColorBrewer::brewer.pal(3, \"Greens\")[c(2, 3)]\n\nggplot(ab_df_props, aes(x = time, y = prop, fill = state_group)) +\n    geom_area() +\n    scale_fill_manual(\n        values = c(Scolors, Icolors, Rcolors),\n        limits = c(\"SA\", \"SB\", \"IA\", \"IB\", \"RA\", \"RB\"),\n    ) +\n    labs(\n        x = \"Time\",\n        y = \"Proportion of individuals\",\n        fill = \"State\"\n    ) +\n    theme(legend.position = \"bottom\")"
  },
  {
    "objectID": "r-session-02.html#a-model-with-2-age-classes",
    "href": "r-session-02.html#a-model-with-2-age-classes",
    "title": "\n7  R Session 02\n",
    "section": "\n7.3 A Model With 2 Age Classes",
    "text": "7.3 A Model With 2 Age Classes\nNote that age is a special kind of heterogeneity in an epidemic model because individuals necessarily move from one class (younger) to another class (older) in a directional fashion that is independent of the infection and recovery process.\n\n\n\nWe’ll start by introducing age into the model above. So now \\(a\\) becomes juveniles and \\(b\\) becomes adults. And, independent of the disease process, juveniles (of any category) age into adults. Additionally, new juveniles are added through births (always first susceptible) and old individuals are lost to death.\n\n\n\n\n\nWe can do this very simply using the same ingredients that go into the basic SIR model. In that model, the waiting times in the S and I classes are exponential. Let’s assume the same thing about the aging process. We’ll also add in births into the juvenile susceptible class and deaths from the adult classes.\n\\[\n  \\begin{aligned}\n    \\frac{\\dd{S_J}}{\\dd{t}} &= B -\\lambda_J\\,S_J \\phantom{- \\gamma\\,I_A} -\\alpha\\,S_J \\phantom{-\\mu\\,S_A}\\\\\n    \\frac{\\dd{S_A}}{\\dd{t}} &= \\phantom{B} - \\lambda_A\\,S_A \\phantom{- \\gamma\\,I_A} +\\alpha\\,S_J -\\mu\\,S_A\\\\\n    \\frac{\\dd{I_J}}{\\dd{t}} &= \\phantom{B} +\\lambda_J\\,S_J - \\gamma\\,I_J -\\alpha\\,I_J \\phantom{-\\mu\\,S_A}\\\\\n    \\frac{\\dd{I_A}}{\\dd{t}} &= \\phantom{B} +\\lambda_A\\,S_A - \\gamma\\,I_A + \\alpha\\,I_J - \\mu\\,I_A\\\\\n    \\frac{\\dd{R_J}}{\\dd{t}} &= \\phantom{B - \\lambda_J\\,S_A} + \\gamma\\,I_J - \\alpha\\,R_J \\phantom{- \\mu\\,S_A}\\\\\n    \\frac{\\dd{R_A}}{\\dd{t}} &= \\phantom{B - \\lambda_J\\,S_A} + \\gamma\\,I_A + \\alpha\\,R_J -\\mu\\,R_A\\\\\n  \\end{aligned}\n\\]\nNow, let’s simulate this model, under the same assumptions about transmission rates as above.\n\nCode# define the parameters for the demographic model\ndemog_params &lt;- c(\n    beta_within = 0.004,\n    beta_between = 0.002,\n    recovery = 10,\n    births = 100,\n    # Width of age bands in years\n    age_band_j = 20,\n    age_band_a = 60\n)\n\n\n\nCodedemog_model &lt;- function (t, x, p, ...) {\n    # Unpack states\n    Sj &lt;- x[\"Sj\"]\n    Sa &lt;- x[\"Sa\"]\n    Ij &lt;- x[\"Ij\"]\n    Ia &lt;- x[\"Ia\"]\n    Rj &lt;- x[\"Rj\"]\n    Ra &lt;- x[\"Ra\"]\n\n    # Unpack parameters from vector\n    beta_within &lt;- p[\"beta_within\"]\n    beta_between &lt;- p[\"beta_between\"]\n    recovery &lt;- p[\"recovery\"]\n    births &lt;- p[\"births\"]\n    # Calculate rate of aging from each age group\n    aging_j &lt;- 1 / p[\"age_band_j\"]\n    aging_a &lt;- 1 / p[\"age_band_a\"]\n\n    # juv. force of infection\n    lambda_j &lt;- beta_within * Ij + beta_between * Ia\n\n    # adult. force of infection\n    lambda_a &lt;- beta_within * Ia + beta_between * Ij\n\n    # Calculate the ODEs\n    dSjdt &lt;- births - (lambda_j * Sj) - (aging_j * Sj)\n    dSadt &lt;- -(lambda_a * Sa) + (aging_j * Sj) - (aging_a * Sa)\n    dIjdt &lt;- (lambda_j * Sj) - (recovery * Ij) - (aging_j * Ij)\n    dIadt &lt;- (lambda_a * Sa) - (recovery * Ia) + (aging_j * Ij) - (aging_a * Ia)\n    dRjdt &lt;- (recovery * Ij) - (aging_j * Rj)\n    dRadt &lt;- (recovery * Ia) + (aging_j * Rj) - (aging_a * Ra)\n\n    # Return the ODEs\n    list(c(\n        dSjdt,\n        dSadt,\n        dIjdt,\n        dIadt,\n        dRjdt,\n        dRadt\n    ))\n}\n\n\nNote that in this function, \\(\\mu=\\) aging_a \\(=\\) 1 / p[\"age_band_a\"], i.e., death, is just like another age class.\n\nCode# initial conditions\ndemog_yinit &lt;- c(Sj = 2000, Sa = 3000, Ij = 0, Ia = 1, Rj = 0, Ra = 1000)\n\n# Solve the demographic model\ndemog_sol &lt;- deSolve::ode(\n    y = demog_yinit,\n    times = seq(0, 200, by = 0.1),\n    func = demog_model,\n    parms = demog_params\n)\n\ndemog_df &lt;- demog_sol %&gt;%\n    as_tibble() %&gt;%\n    mutate(\n        across(everything(), as.numeric),\n        Nj = Sj + Ij + Rj,\n        Na = Sa + Ia + Ra,\n        # Calculate total population as need for proportional area plots\n        N = Nj + Na\n    ) %&gt;%\n    pivot_longer(\n        cols = -c(time, N),\n        names_to = c(\"state\", \"group\"),\n        names_sep = 1,\n        values_to = \"value\"\n    ) %&gt;%\n    mutate(\n        state = factor(state, levels = c(\"S\", \"I\", \"R\", \"N\")),\n        group = paste(\"Group\", str_to_upper(group))\n    )\n\n\n\n7.3.1 Exercise 1: Use this code to plot the number of susceptible, infected, and recovered individuals over time\n\nCodeggplot(demog_df, aes(x = time, y = value, color = state)) +\n    geom_line(linewidth = 1.5) +\n    facet_wrap(\n        ~group, nrow = 2, scales = \"free_y\",\n        labeller = as_labeller(c(\n            `Group A` = \"Adults\",\n            `Group J` = \"Juveniles\"\n        ))\n    ) +\n    scale_color_manual(\n        values = SIRcolors,\n        labels = c(\"Susceptible\", \"Infected\", \"Recovered\", \"Total\")\n    ) +\n    labs(\n        x = \"Time\",\n        y = \"Number of individuals\",\n        color = \"State\"\n    ) +\n    theme(legend.position = \"bottom\")\n\n\n\n\nNote that now that births are replenishing susceptibles, infection persists. The results of the above are plotted here:\nNow let’s plot the proportion of individuals in each state for the two groups.\n\nCode# Calculate the proportions in each state and group at each time point\ndemog_df_props &lt;- demog_df %&gt;%\n    filter(state != \"N\") %&gt;%\n    mutate(\n        state_group = paste0(state, str_extract_all(group, \"[^Group ]\")),\n        state_group = factor(\n          state_group,\n          levels = c(\"RJ\", \"RA\", \"IJ\", \"IA\", \"SJ\", \"SA\")\n        )\n    ) %&gt;%\n    group_by(time, state_group) %&gt;%\n    mutate(\n        # Calculate the proportion of the total population, not the group pop\n        prop = value / N\n    ) %&gt;%\n    ungroup()\n\n\n\nCodeggplot(demog_df_props, aes(x = time, y = prop, fill = state_group)) +\n    geom_area() +\n    scale_fill_manual(\n        values = c(Scolors, Icolors, Rcolors),\n        limits = c(\"SJ\", \"SA\", \"IJ\", \"IA\", \"RJ\", \"RA\")\n    ) +\n    labs(\n        x = \"Time\",\n        y = \"Proportion of individuals\",\n        fill = \"State\"\n    ) +\n    theme(legend.position = \"bottom\")\n\n\n\n\nNow let’s plot the equilibrium seroprevalence for each age group.\n\nCode# Select the last row (time point) of the data frame\ndemog_equil_seroprev &lt;- tail(demog_df) %&gt;%\n    mutate(\n        # Calculate the proportion of individuals in each state and age group\n        prop = value / sum(value),\n        # Relabel groups for plots\n        group = case_when(group == \"Group J\" ~ \"Juveniles\", TRUE ~ \"Adults\"),\n        group = factor(group, levels = c(\"Juveniles\", \"Adults\")),\n        .by = group\n    ) %&gt;%\n    filter(state == \"R\")\n\n\n\nCode# Create vector of colors to distinguish between age groups\nage_group_colors &lt;- c(\"#2980B9\", \"#154360\")\n\nggplot(demog_equil_seroprev, aes(x = group, y = prop, fill = group)) +\n    geom_col(position = \"identity\") +\n    scale_fill_manual(\n        values = age_group_colors\n    ) +\n    labs(\n        x = \"Age group\",\n        y = \"Equilibrium seroprevalence\",\n        fill = \"Age group\"\n    ) +\n    theme(legend.position = \"none\")\n\n\n\n\nOne thing we are often interested in is the \\(R_0\\) of a system. The details are beyond the scope of this workshop and are not required to complete the exercises in this worksheet, but we have outlined them in Section 7.6.1.1, particularly in Equation 7.3, at the end of this page.\nIn our system, \\(R_0 =\\) 2.66."
  },
  {
    "objectID": "r-session-02.html#getting-more-realistic-adding-more-age-classes",
    "href": "r-session-02.html#getting-more-realistic-adding-more-age-classes",
    "title": "\n7  R Session 02\n",
    "section": "\n7.4 Getting more realistic: adding more age classes",
    "text": "7.4 Getting more realistic: adding more age classes\nIn the models above, the aging process follows an exponential distribution, which means that whether an individual is 1~year old or 10 years old, the chance of them becoming an adult is the same! To improve on this, we can assume that the time a juvenile must wait before becoming an adult follows a gamma distribution. This is equivalent to saying that the waiting time is a sum of some number of exponential distributions. This suggests that we can achieve such a distribution by adding age classes to the model, so that becoming an adult means passing through some number of stages. We’ll use 30 age classes, and since they don’t have to be of equal duration, we’ll assume that they’re not. Specifically, we’ll have 20 1-yr age classes to take us up to adulthood and break adults into 10 age classes of 5~yr duration each. The last age class covers age 66-80.\nNow, when we had just two age classes, we could write out each of the equations easily enough, but now that we’re going to have 30, we’ll need to be more systematic. In particular, we’ll need to think of \\(\\beta\\) as a matrix of transmission rates. Let’s see how to define such a matrix in R. So that we don’t change too many things all at once, let’s keep the same contact structure as in the juvenile-adult model.\n\nCode# Set up the parameters for model that incorporates a more realistic age matrix\nages_params &lt;- c(\n    beta_j = 0.02,\n    beta_a = 0.01,\n    beta_aj = 0.01 / 2,\n    recovery = 10,\n    births = 100\n)\n\n# Create a vector of ages\nages &lt;- c(seq(1, 20, by = 1), seq(25, 65, by = 5), 80)\n\n# Calculate the widths of the age bands\nda_ages &lt;- diff(c(0, ages))                  # widths of age classes\n\n# set up a matrix of contact rates between classes -- more contact within juveniles and adults than between\nages_beta_mat &lt;- matrix(nrow = 30, ncol = 30)\n\n# transmission rate for juveniles\nages_beta_mat[1:20, 1:20] &lt;- ages_params[\"beta_j\"]\n\n# transmission rate for adults\nages_beta_mat[21:30, 21:30] &lt;- ages_params[\"beta_a\"]\n\n# lower transmission rate between juveniles and adults\nages_beta_mat[1:20, 21:30] &lt;- ages_params[\"beta_aj\"]\n\n# lower transmission rate between juveniles and adults\nages_beta_mat[21:30, 1:20] &lt;- ages_params[\"beta_aj\"]\n\n\n\n\nCodeages_beta_mat %&gt;%\n    # Turn into a data.frame so we can use ggplot()\n    as.data.frame.table() %&gt;%\n    mutate(\n        age_contactor = rep(ages, 30),\n        # Repeat each age in ages vector 30 times, and place in a list, then unlist \n        # to be stacked into a single dataframe column\n        age_contactee = unlist(purrr::map(.x = ages, ~rep(.x, 30))),\n    ) %&gt;%\n    ggplot(aes(x = age_contactor, y = age_contactee, z = Freq)) +\n    geom_contour_filled(bins = 8) +\n    scale_fill_brewer(\n        palette = \"Reds\",\n        # Don't drop unused bins as useful for ensuring extremities properly binned\n        drop = FALSE\n    ) +\n    labs(x = \"Age of Contactor\", y = \"Age of Contactee\")\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nYou could also use the filled.contour() base-R function to plot the beta matrix without needing to do any dataframe modifications, but it doesn’t look as nice …\n\nCodefilled.contour(\n    ages, ages, ages_beta_mat,\n    plot.title = title(\n        xlab = \"Age of Contactor\",\n        ylab = \"Age of Contactee\"\n    )\n)\n\n\n\n\n\n\n\nWe’ll assume that, at the time of introduction, all children are susceptible, as are adults over 45, but that individuals aged 20–45 have seen the pathogen before and are immune. The vector yinit expresses these initial conditions.\n\nCode# Create a long vector of initial states with only one\n# initial infection in age 50\ndemog_yinit_ages &lt;- c(\n    S = c(rep(100, 20), rep(0, 5), rep(200, 5)),\n    I = c(rep(0, 25), 1, rep(0, 4)),\n    R = c(rep(0, 20), rep(1000, 5), rep(0, 5))\n)\n\n\nNote that we’re starting out with 1 infected individual in the 26th age class (age 50).\nThe codes that follow will be a bit easier to follow if we introduce some indexes that will allow us to pick out certain bits of the yinit vector.\n\nCode# Create vectors of indices relating to each state (ordered S1-80, I1-80, R1-80)\nsindex &lt;- 1:30\niindex &lt;- 31:60\nrindex &lt;- 61:90\n# Create vectors of indices relating to age group\njuvies &lt;- 1:20\nadults &lt;- 21:30\n\n\nNow, to capture the aging process, it’s convenient to define another matrix to hold the rates of movement between age classes. Generally, this matrix would look like this:\n\\[\n\\begin{pmatrix}\n    -\\alpha_1 & 0 & 0 & \\cdots & 0\\\\\n    \\alpha_1 & -\\alpha_2 & 0 & \\cdots & 0\\\\\n    0 & \\alpha_2 & -\\alpha_3 & \\cdots & 0\\\\\n    \\vdots &  & \\ddots & \\ddots & \\vdots \\\\\n    0 & \\cdots & & \\alpha_{29} & -\\alpha_{30}\\\\\n\\end{pmatrix}\n\\tag{7.1}\\]\n\nCode# Create a diagonal matrix that holds the rates of aging out of each age class\n# The rows represent the age class you're in, the columns represent the age class\n# you're moving to\naging_mat &lt;- diag(-1 / da_ages)\n\n# Fill in the rates of aging into each age class\naging_mat[row(aging_mat) - col(aging_mat) == 1] &lt;- 1 / head(da_ages, -1)\n\n\nHave a look at the aging matrix, for example by doing:\n\nCode# Move fast through the 1-year age classes - negatives are moves out, positives are moves in\n# Cannot move between non-adjacent age classes\naging_mat[1:5, 1:5]\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   -1    0    0    0    0\n[2,]    1   -1    0    0    0\n[3,]    0    1   -1    0    0\n[4,]    0    0    1   -1    0\n[5,]    0    0    0    1   -1\n\n\n\nCode# Move slowly between the wider age classes\naging_mat[25:30, 25:30]\n\n     [,1] [,2] [,3] [,4] [,5]        [,6]\n[1,] -0.2  0.0  0.0  0.0  0.0  0.00000000\n[2,]  0.2 -0.2  0.0  0.0  0.0  0.00000000\n[3,]  0.0  0.2 -0.2  0.0  0.0  0.00000000\n[4,]  0.0  0.0  0.2 -0.2  0.0  0.00000000\n[5,]  0.0  0.0  0.0  0.2 -0.2  0.00000000\n[6,]  0.0  0.0  0.0  0.0  0.2 -0.06666667\n\n\n\nCodeaging_mat %&gt;%\n    as.data.frame.table() %&gt;%\n    mutate(\n        age_recipient = rep(ages, 30),\n        age_source = unlist(purrr::map(.x = ages, ~rep(.x, 30)))\n    ) %&gt;%\n    ggplot(aes(x = age_source, y = age_recipient, z = Freq)) +\n    geom_contour_filled() +\n    scale_fill_brewer(\n        palette = \"RdBu\",\n        drop = FALSE\n    ) +\n    labs(x = \"Source Age Group\", y = \"Recipient Age Group\")\n\n\n\n\n\n7.4.1 Exercise 2: What can you say about its structure? How are the different age groups in contact with each other?\nNow we can put the pieces together to write a simulator for the age-structured SIR dynamics.\n\nCode# Using a list instead of a vector to hold the parameters, as ages_beta_mat and aging \n# are both matrices, so we want to keep them as matrices, rather than flattening\nmultistage_params &lt;- list(\n    beta_mat = ages_beta_mat,\n    recovery = ages_params[\"recovery\"],\n    births = ages_params[\"births\"],\n    aging_mat = aging_mat\n)\n\nmultistage_model &lt;- function (t, x, p, ...) {\n    # Unpack all states from the vector using the relevant indices\n    s &lt;- x[sindex]\n    i &lt;- x[iindex]\n    r &lt;- x[rindex]\n    \n    # Unpack parameters\n    beta_mat &lt;- p[[\"beta_mat\"]]\n    recovery &lt;- p[[\"recovery\"]]\n    births &lt;- p[[\"births\"]]\n    aging_mat &lt;- p[[\"aging_mat\"]]\n\n    # Calculate force of infection using matrix multiplication\n    lambda &lt;- beta_mat %*% i\n    \n    # Calculate the ODEs at every time step\n    # Note that R add element-wise for vectors i.e. lambda * s results\n    # in a vector length 30 (30 age groups), as does aging_mat %*% s,\n    # so v1[i] + v2[i] for i in 1:30\n    dsdt &lt;- -lambda * s + aging_mat %*% s\n    didt &lt;- lambda * s + aging_mat %*% i - recovery * i\n    drdt &lt;- aging_mat %*% r + recovery * i \n    # Add the birth rate to the first age group\n    dsdt[1] &lt;- dsdt[1] + births\n    \n    # Return the ODEs in a list\n    list(c(dsdt, didt, drdt))\n\n}\n\n\nWe can plug this into ode just as we did the simpler models to simulate an epidemic. We’ll then plot the epidemic curve.\n\nCode# Solve the model with a realistic age matrix\nmultistage_sol &lt;- deSolve::ode(\n    y = demog_yinit_ages,\n    times = seq(0, 100, by = 0.1),\n    func = multistage_model,\n    parms = multistage_params\n)\n\n# Extract all infected age groups at all time points into a new vector\nmultistage_infecteds &lt;- multistage_sol[, 1 + iindex]\n\n\n\nCode# Create a dataframe of the sum of infectious individuals in Juv/Adult age groups\n# at each time point\nmultistage_df &lt;- tibble(\n        # Get all times from model run\n        time = multistage_sol[, 1],\n        # At each timepoint, apply the sum function to all juvenile infected individuals\n        Juveniles = apply(multistage_infecteds[, juvies], 1, sum),\n        # At each timepoint, apply the sum function to all adult infected individuals\n        Adults = apply(multistage_infecteds[, adults], 1, sum)\n    ) %&gt;%\n    # Pivot to create a long dataframe that works with ggplot\n    pivot_longer(\n        cols = c(Juveniles, Adults),\n        names_to = \"age_group\",\n        values_to = \"infections\"\n    ) %&gt;%\n    # Turn new pivoted variable into a factor to plot nicely\n    mutate(\n        age_group = factor(age_group, levels = c(\"Juveniles\", \"Adults\"))\n    )\n\n\n\nCodeggplot(multistage_df, aes(x = time, y = infections, color = age_group)) +\n    geom_line(linewidth = 1.5) +\n    scale_color_manual(\n        values = age_group_colors\n    ) +\n    labs(\n        x = \"Time\",\n        y = \"Number of infections\",\n        color = \"Age group\"\n    )\n\n\n\n\nLet’s mimic a situation where we have cross-sectional seroprevalence data (e.g. measures of antibodies that tell you someone is in the R class). In using such data, we’d typically assume that the system was at equilibrium.\n\n7.4.2 Exercise 3: What does the equilibrium age-specific seroprevalence look like in this example?\nUse the code below to display the age-specific seroprevalence (i.e., the seroprevalence for each age group at equilibrium)\n\nCode# Get the last values for all individuals. drop() removes the column name, [-1] removes the time value\nmultistage_equil &lt;- drop(tail(multistage_sol, 1))[-1]\n# Calculate the equilibrium pop sizes of each age group\nmultistage_equil_n &lt;- multistage_equil[sindex] +\n    multistage_equil[iindex] +\n    multistage_equil[rindex]\n\n# Calculate equilibrium seroprevalence for each age group\nmultistage_equil_seroprev &lt;- multistage_equil[rindex] / multistage_equil_n\n\n# Create a dataframe to store equilibrium seroprev for plotting\nmultistage_equil_seroprev_df &lt;- tibble(\n    age = ages,\n    seroprev = multistage_equil_seroprev,\n    width = da_ages\n)\n\n\n\nCodeggplot(multistage_equil_seroprev_df, aes(x = age, y = seroprev, fill = age)) +\n    # Set column width to width of age bands, and justify to start at lower bound\n    geom_col(width = multistage_equil_seroprev_df$width, just = 1.0, color = \"black\") +\n    labs(\n        x = \"Age\",\n        y = \"Seroprevalence\"\n    ) +\n    scale_x_continuous(breaks = seq(0, 80, 10)) +\n    scale_fill_continuous(low = age_group_colors[1], high = age_group_colors[2])\n\n\n\n\n\n\n\n\n\n\nQUESTION\n\n\n\nAt what age does the seroprevalence reach 75%?\n\n\nLet’s also compute \\(R_0\\). And because we’ve added a lot of age structure, with transitions between the age groups, we can’t just copy and paste the previous Next Generation Matrix code (from Section 7.6.1.1). As before, the details of this computation are out of the workshop’s scope, but they are outlined in Section 7.6.1.2. We have created a function to calculate R0 for an age-structured SIR and have added some comments, but read Section 7.6.1.2 for the full details and reasoning.\n\nCode# Calculate the stable disease-free age distribution. Could also simulate without any infections.\nmultistage_stable_n &lt;- solve(\n    aging_mat,\n    c(-1 * multistage_params[[\"births\"]], rep(0, 29))\n)\n\n\n\n\nCode#' Calculate R0\n#'\n#' Calculate the R0 of an SIR model using the next generation matrix approach described in @heffernanPerspectivesBasicReproductive2005\n#'\n#' @param beta_mat A matrix of beta parameter values\n#' @param stable_n_mat A matrix of the stable age distributions\n#' @param aging_mat A matrix of the aging rates between age compartments\n#' @param recovery_rate The recover rate parameter value (of type double)\n#'\n#' @return The R0 value as type double\n#' @examples\n#' calculate_R0(\n#'    beta_mat = multistage_params[[\"beta_mat\"]],\n#'    stable_n_mat = multistage_stable_n,\n#'    aging_mat = multistage_params[[\"aging_mat\"]],\n#'    recovery_rate = multistage_params[[\"recovery\"]]\n#')\ncalculate_R0 &lt;- function(beta_mat, stable_n_mat, aging_mat, recovery_rate) {\n    # evaluate new inf jac pde at dfe\n    f_mat &lt;- beta_mat * stable_n_mat\n\n    # set off-diag of non-inf transition jac pde to neg aging of prev age group\n    # (use aging matrix as already calculated in correct places)\n    v_mat &lt;- -aging_mat\n    # Update the diagonal of non-inf transition jac to add recovery rate\n    diag(v_mat) &lt;- diag(v_mat) + recovery_rate\n\n    ## Alternative method of calculating using age bands directly\n    # v_mat &lt;- diag(recovery_rate + 1 / da_ages)\n    # v_mat[row(v_mat) - col(v_mat) == 1] &lt;- - 1 / head(da_ages, -1)\n    \n    # spectral trace\n    R0 &lt;- max(Re(eigen(solve(v_mat, f_mat), only.values = TRUE)$values))   \n    \n    return(R0)\n}\n\n\n\nCodecalculate_R0(\n    beta_mat = multistage_params[[\"beta_mat\"]],\n    stable_n_mat = multistage_stable_n,\n    aging_mat = multistage_params[[\"aging_mat\"]],\n    recovery_rate = multistage_params[[\"recovery\"]]\n)\n\n[1] 6.991242\n\n\n\n7.4.3 Exercise 4: Updating the contact matrix\n\n\n\n\n\n\nImportant\n\n\n\nYou will need to read and edit the following code carefully so that it runs with your updated parameters. We have highlighted the relevant lines in the code chunks, so hopefully you won’t miss them, though make sure you do copy all the code!\n\n\n\n7.4.3.1 Change the juvenile-juvenile contact rate to be 0.025.\n\nCodeupdate_age_beta_mat &lt;- ages_beta_mat\nupdate_age_beta_mat[1:20, 1:20] &lt;- ?\n\nupdate_age_params &lt;- multistage_params\nupdate_age_params[[\"beta_mat\"]] &lt;- update_age_beta_mat\n\n\n\n7.4.3.2 Simulate and plot the age-structured SIR dynamics under your assumptions and record how the age-specific seroprevalence has changed.\n\nCodeupdate_age_sol &lt;- deSolve::ode(\n    y = demog_yinit_ages,\n    times = seq(0, 400, by = 0.1),\n    func = multistage_model,\n    parms = ?\n)\n\n# Get the time series for each infectious age group\nupdate_age_infecteds &lt;- update_age_sol[, 1 + iindex]\n\n# Get the last values in the time series\nupdate_age_equil &lt;- drop(tail(update_age_sol, 1))[-1]\n\n# Calculate the number of individuals in each age group at the final timepoint\nupdate_age_equil_n &lt;- update_age_equil[ ? ] +\n    update_age_equil[ ? ] +\n    update_age_equil[ ? ]\n\n# Calculate final seroprevalence\n# Hint: You need PREVIOUSLY infected individuals\nupdate_age_equil_seroprev &lt;- update_age_equil[ ? ] / update_age_equil_n\n\nupdate_age_equil_seroprev_df &lt;- tibble(\n    age = ages,\n    seroprev = update_age_equil_seroprev,\n    width = da_ages\n)\n\nggplot(update_age_equil_seroprev_df, aes(x = age, y = seroprev, fill = age)) +\n    # Set column width to width of age bands, and justify to start at lower bound\n    geom_col(width = update_age_equil_seroprev_df$width, just = 1.0, color = \"black\") +\n    labs(\n        x = \"Age\",\n        y = \"Seroprevalence\"\n    ) +\n    scale_x_continuous(breaks = seq(0, 80, 10)) +\n    scale_fill_continuous(low = age_group_colors[1], high = age_group_colors[2])\n\n\n\n\n\n\n\n\nQUESTION\n\n\n\nAt what age does the seroprevalence reach 75%? How does this compare to the answer in Section 7.4.2?\n\n\n\n7.4.3.3 Compute \\(R_0\\) for your assumptions.\nAs described previously, the calculation for \\(R_0\\) is difficult due to all the age categories and transitions. Use the calculate_R0() function we defined earlier to calculate \\(R_0\\) for our updated system.\n\nCodecalculate_R0(\n    beta_mat = ?,\n    stable_n_mat = ?,\n    aging_mat = ?,\n    recovery_rate = ?\n)\n\n\nIf you’ve done everything correctly, you should get \\(R_0 =\\) 7.29. This is higher than previously. Does this match your intuition, given our changes to the beta matrix?\n\n\n\n\n\n\nWarning\n\n\n\nThe following is Aaron’s original code which provides slightly different results.\n\n\n\nCodeF_mat &lt;- diag(update_age_equil_n) %*% update_age_beta_mat +\n    update_age_params[[\"aging_mat\"]] -\n    diag(diag(update_age_params[[\"aging_mat\"]]))\n\nV_mat &lt;- diag(update_age_params[[\"recovery\"]] - diag(update_age_params[[\"aging_mat\"]]))\n\n# R0 approximately 6.53\nmax(Re(eigen(solve(V_mat, F_mat), only.values = TRUE)$values))\n\n[1] 7.034769"
  },
  {
    "objectID": "r-session-02.html#r0-and-the-mean-age-of-infection",
    "href": "r-session-02.html#r0-and-the-mean-age-of-infection",
    "title": "\n7  R Session 02\n",
    "section": "\n7.5 R0 and the Mean Age of Infection",
    "text": "7.5 R0 and the Mean Age of Infection\nTo develop some intuition about the relationship between \\(R_0\\) and the mean age of infection, let’s play with an interactive plot. We will assume that the population is completely susceptible and that the force of infection is constant. We’ll also assume that there is heterogenous mixing i.e. no age structure.\nAs we’ve seen in Matt’s lecture on age structure, we can calculate the mean age of infection using the equation below:\n\\[\nA \\approx \\frac{L}{R_E - 1}\n\\tag{7.2}\\]\nwhere \\(L\\) is the life expectancy \\(\\left(L = \\frac{1}{\\mu}\\right)\\) and \\(R_E\\) is the effective reproductive number (\\(R_E = R_0 * (1 - p)\\) where \\(p\\) is the fraction of individuals vaccinated).\n\n\n\n\n\n\nNote\n\n\n\n\n\nSee Section 7.6.2 for code you can run in R to investigate the relationship between \\(R_0\\), vaccination coverage, life expectancy, and the mean age of infection.\n\n\n\n\n7.5.1 Exercise 5: mean age of infection interactions\n\n7.5.1.1 When you increase \\(R_0\\) from 2.0 to 4.0, what happens to the mean age of infection?\n\n7.5.1.1.1 Is there a linear change? If not, why not?\n\n7.5.1.2 With \\(R_0\\) to 4.0, approximately what level of vaccination coverage is required for a mean age of infection of 40 years?\n\n7.5.1.3 Leaving \\(R_0\\) and vaccination coverage the same, decrease the life expectancy to 50 years. What happens to the mean age of infection?\n\n7.5.1.3.1 If it changed, why do you think it did?\n\n\nCodeinit_R0 = 2.0\ninit_vacc = 0.0\ninit_lifeexp = 75\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodefunction set(input, value) {\n  input.value = value;\n  input.dispatchEvent(new Event(\"input\", {bubbles: true}));\n}\n\n\n\n\n\n\n\n\nCodeviewof reset = Inputs.button([\n  [\"Reset all sliders\", () =&gt; {\n    set(viewof R0, init_R0)\n    set(viewof vacc, init_vacc)\n    set(viewof lifeexp, init_lifeexp)\n  }]\n])\nviewof R0 = Inputs.range(\n    [1.0, 10.0],\n    {value: 2.0, step: 0.01, label: md`${tex`R_0`}`}\n)\n\nviewof vacc = Inputs.range(\n    [0.0, 1.0],\n    {value: 0.0, step: 0.01, label: \"Vaccination coverage\"}\n)\n\nviewof lifeexp = Inputs.range(\n    [50, 100],\n    {value: 75, step: 1, label: \"Life expectancy\"}\n)\n\nmd`${tex`R_E = ${Re_str}`}`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodemd`${tex`\\text{Mean age of infection} = ${Re_mean_age_str}`}`\n\n\n\n\n\n\n\n\n\n\nCodeRe = R0 * (1 - vacc)\nRe_str = Re.toPrecision(4).toLocaleString()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodefunction calc_mean_age(Re, lifeexp) {\n    if(Re &gt;= 1) {\n        var mean_age = (lifeexp / (Re - 1))\n    } else {\n        var mean_age = Infinity\n    }\n    return mean_age\n}\n\n\n\n\n\n\n\nCodeR0_mean_age = calc_mean_age(R0, lifeexp)\nRe_mean_age = calc_mean_age(Re, lifeexp)\nRe_mean_age_str = Re_mean_age.toPrecision(4).toLocaleString()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodeimport { aq, op } from '@uwdata/arquero'\n\n\n\n\n\n\n\nCodefunction calc_mean_age_arr(vacc, lifeexp, R0_min, R0_max, dR0) {\n    var R0_sim = R0_min\n\n    var R0 = []\n    var Re = []\n    var R0_mean_age = []\n    var Re_mean_age = []\n\n    for (R0_sim = R0_min; R0_sim &lt;= R0_max; R0_sim += dR0) {\n        var Re_sim = R0_sim * (1 - vacc)\n        var R0_mean_age_sim = calc_mean_age(R0_sim, lifeexp)\n        var Re_mean_age_sim = calc_mean_age(Re_sim, lifeexp)\n\n        R0.push(R0_sim)\n        Re.push(Re_sim)\n        R0_mean_age.push(R0_mean_age_sim)\n        Re_mean_age.push(Re_mean_age_sim)\n    }\n\n    return {\n        Re: aq.table({\n                R0: R0,\n                mean_age: Re_mean_age\n            }).filter((d) =&gt; d.mean_age &lt;= 100),\n        R0: aq.table({\n                R0: R0,\n                mean_age: R0_mean_age\n            }).filter((d) =&gt; d.mean_age &lt;= 100)\n    }\n}\n\n\n\n\n\n\n\nCodemean_age_arrs = calc_mean_age_arr(vacc, lifeexp, 1.0, 10.0, 0.01)\n\n\n\n\n\n\n\nCodemean_age_dots = [({\n    arrow_start: R0_mean_age &lt;= 100 ? R0_mean_age : 100,\n    arrow_end: Re_mean_age &lt;= 100 ? Re_mean_age : 100,\n    R0: R0.toPrecision(3),\n    Re: Re.toPrecision(3),\n    R0_mean_age,\n    Re_mean_age\n})]\n\n\n\n\n\n\n\n\n\nCode{\n    let R0Color = \"#1f77b4\"\n    let ReColor = \"#ff7f0e\"\n\n    let plot = Plot.plot({\n        color: {\n            legend: true,\n            domain: [\"Unvaccinated\", \"Vaccinated\"],\n            range: [\"#1f77b4\", \"#ff7f0e\"]\n        },\n        style: {fontSize: \"20px\"},\n        marginLeft: 65,\n        marginTop: 40,\n        marginBottom: 55,\n        grid: true,\n        width: 800,\n        height: 670,\n        x: {label: \"R0\", domain: [0, 10]},\n        y: {label: \"Mean Age of Infection\", domain: [0, 100]},\n        marks: [\n            Plot.line(mean_age_arrs.Re, {x: \"R0\", y: \"mean_age\", stroke: ReColor, strokeWidth: 6}),\n            Plot.line(mean_age_arrs.R0, {x: \"R0\", y: \"mean_age\", stroke: R0Color, strokeWidth: 6}),\n            Re_mean_age &lt;= 100 ?\n                [\n                    vacc &gt; 0.00 ? Plot.dot(mean_age_dots, {x: \"R0\", y: \"Re_mean_age\", r: 12, stroke: ReColor, fill:     ReColor,  fillOpacity: 0.6}) : null,\n                    Plot.text(\n                        mean_age_dots,\n                        {x: \"R0\", y: \"Re_mean_age\", text: (d) =&gt; `Re = ${d.Re}`, dx: 55, dy: -25, fontWeight: \"bold\", fill: ReColor}\n                    )\n                ] :\n            null,\n            R0_mean_age &lt;= 100 ?\n                [\n                Plot.dot(mean_age_dots, {x: \"R0\", y: \"R0_mean_age\", r: 12, stroke: R0Color, fill: R0Color, fillOpacity: 0.6}),\n                Plot.text(\n                    mean_age_dots,\n                    {x: \"R0\", y: \"R0_mean_age\", text: (d) =&gt; `R0 = ${d.R0}`, dx: -60, dy: 30, fontWeight: \"bold\", fill: R0Color}\n                )\n                ] :\n            null,\n            Plot.arrow(mean_age_dots, {x1: \"R0\", x2: \"R0\", y1: \"arrow_start\", y2: \"arrow_end\", strokeWidth: 4, headLength: 5, inset: 15}),\n        ]\n    });\n\n  return plot;\n}"
  },
  {
    "objectID": "r-session-02.html#bonus-materials",
    "href": "r-session-02.html#bonus-materials",
    "title": "\n7  R Session 02\n",
    "section": "\n7.6 Bonus Materials",
    "text": "7.6 Bonus Materials\n\n7.6.1 Calculating \\(R_0\\) with the Next Generation Matrix\n\n7.6.1.1 Simple model structure\nTo compute \\(R_0\\), we need to know the stable age distribution (the relative proportion in the juvenile and adult age classes) of the population, which we can find by solving for the disease-free equilibrium: \\(S_J^*=B/\\alpha\\) and \\(S_A^*=B/\\mu\\). With the stable age distribution, we can calculate \\(R_0\\) by constructing the next generation matrix. The code below outlines how the next generation matrix is constructed using the \\(\\alpha\\) (aging from juvenile to adult), \\(\\mu\\) (death), \\(n\\) (total births), \\(\\gamma\\) (recovery), \\(da\\) (width of age groups in years), and \\(\\beta\\) (transmission) parameters.\nThe next generation matrix is a matrix that specifies how many new age-specific infections are generated by a typical infected individual of each age class (in a fully susceptible population). For example, let’s consider an infected adult and ask how many new juvenile infections it generates: this is the product of the number of susceptible juveniles (from the stable age distribution), the per capita transmission rate from adults to juveniles and the average duration of infection, i.e. \\(S_J^* \\times \\beta_{JA} \\times 1/ (\\gamma+\\mu)\\). This forms one element of our next generation matrix. The other elements look very similar, except there are extra terms when we consider an infected juvenile because there is a (very small) chance they may age during the infectious period and therefore cause new infections as an adult:\n\\[\n\\mathrm{NGM} = \\begin{pmatrix}\n        \\frac{S_J^* \\beta_{JJ}}{(\\gamma + \\alpha)} +\n        \\frac{\\alpha}{(\\gamma+\\mu)} \\frac{S_J^* \\beta_{JA}}{(\\gamma + \\mu)} &\n        \\frac{S_J^* \\beta_{JA}}{(\\gamma + \\mu)} \\\\\n        \\frac{S_A^* \\beta_{AJ}}{(\\gamma + \\alpha)} +\n            \\frac{\\alpha}{(\\gamma + \\mu)} \\frac{S_A^*\\beta_{AA}}{(\\gamma+\\mu)} &\n            \\frac{S_A^* \\beta_{AA}}{(\\gamma + \\mu)}\n    \\end{pmatrix}\n\\tag{7.3}\\]\n\\(R_0\\) can then be computed as the dominant eigenvalue (i.e., the one with the largest real part) of this matrix. Let’s take an example from a model with 2 age classes, from above. First, let’s define the components of the next generation matrix:\n\nCodengm_params &lt;- c(\n    beta_within = 0.011,\n    beta_between = 0.005,\n    age_band_j = 20,\n    age_band_a = 60,\n    recovery = 10\n)\n\nalpha_ngm &lt;- 1 / ngm_params[\"age_band_j\"]\nmu_ngm &lt;- 1 / ngm_params[\"age_band_a\"]\nn_ngm &lt;- demog_params[\"births\"] / c(alpha_ngm, mu_ngm)\n\nbeta_ngm &lt;- matrix(c(\n    ngm_params[\"beta_within\"],\n    ngm_params[\"beta_between\"],\n    ngm_params[\"beta_between\"],\n    ngm_params[\"beta_within\"]\n    ),\n    nrow = 2,\n    ncol = 2\n)\n\n\nThe Next Generation Matrix can be calculated in R as:\n\nCodengm &lt;- matrix(\n    c(\n        n_ngm[1] * (beta_ngm[1, 1] / (ngm_params[\"recovery\"] + alpha_ngm)) +\n            alpha_ngm / (ngm_params[\"recovery\"] + mu_ngm) *\n            n_ngm[1] * beta_ngm[1, 2] / (ngm_params[\"recovery\"] + mu_ngm),\n        \n        n_ngm[2] * beta_ngm[2, 1] / (ngm_params[\"recovery\"] + alpha_ngm) +\n            alpha_ngm / (ngm_params[\"recovery\"] + mu_ngm) *\n            n_ngm[2] * (beta_ngm[2, 2] / (ngm_params[\"recovery\"] + mu_ngm)),\n\n        n_ngm[1] * beta_ngm[1, 2] / (ngm_params[\"recovery\"] + mu_ngm),\n\n        n_ngm[2] * beta_ngm[2, 2] / (ngm_params[\"recovery\"] + mu_ngm)\n    ),\n    nrow = 2,\n    ncol = 2\n)\n\n\nWe can then calculate the eigenvalues and eigenvectors of this matrix:\n\nCodeeigen(ngm)\n\neigen() decomposition\n$values\n[1] 7.191869 1.591188\n\n$vectors\n           [,1]       [,2]\n[1,] -0.1958841 -0.8560336\n[2,] -0.9806271  0.5169202\n\n\nWe can also choose to just output the eigenvalues:\n\nCodeeigen(ngm, only.values = TRUE)\n\n$values\n[1] 7.191869 1.591188\n\n$vectors\nNULL\n\n\nFinally, let’s print \\(R_0\\):\n\nCodemax(\n    Re(\n        eigen(ngm, only.values = TRUE)$values\n    )\n)\n\n[1] 7.191869\n\n\n\n7.6.1.2 Age-structured NGM\nMany times it would be impractical to write out the NGM: there are often too many compartments in an age-structured model. In this instance, we want to use a slightly different approach, but the underlying principles are the same: each element of the NGM balances the number of new infections expected to be produced with the rates of individuals coming in and out of that compartment.\n\n7.6.1.2.1 Stable Age Distribution\nThe first thing we need, as before, is the stable age distribution i.e., the disease-free equilibrium. There are two ways we can do this:\n\nSimulate the model without any infections for a sufficiently long time (simple, but less accurate)\nDo the math.\n\n\n7.6.1.2.1.1 Disease-Free Simulation\n\nCode# Set up initial conditions without any infections\nmultistage_sonly_yinit &lt;- c(\n    S = c(rep(250, 30)),\n    I = c(rep(0, 30)),\n    R = c(rep(0, 30))\n)\n\n# Solve disease free sim to get dfe\nmultistage_sonly_sol &lt;- deSolve::ode(\n    y = multistage_sonly_yinit,\n    times = seq(0, 300, by = 1),\n    func = multistage_model,\n    parms = multistage_params\n)\n\n# Calculate population size at each time point and save to dataframe\nmultistage_sonly_pop &lt;- tibble(\n    time = multistage_sonly_sol[, 1],\n    pop = apply(multistage_sonly_sol[, -1], 1 , sum)\n)\n\n\n\nCodeggplot(multistage_sonly_pop, aes(x = time, y = pop)) +\n    geom_area(fill = SIRcolors[4], alpha = 0.6) +\n    labs(\n        x = \"Time\",\n        y = \"Population size\"\n    )\n\n\n\n\n\n7.6.1.2.1.2 Doing the Math\nAlternatively, we can get the stable age distribution by finding the population structure that balances the birth, aging, and death processes. We have already seen the aging matrix in Equation 7.1, and at equilibrium, we have the matrix equation\n\\[\n\\begin{pmatrix}\n    -\\alpha_1 & 0 & 0 & \\cdots & 0\\\\\n    \\alpha_1 & -\\alpha_2 & 0 & \\cdots & 0\\\\\n    0 & \\alpha_2 & -\\alpha_3 & \\cdots & 0\\\\\n    \\vdots &  & \\ddots & \\ddots & \\vdots \\\\\n    0 & \\cdots & & \\alpha_{29} & -\\alpha_{30}\\\\\n\\end{pmatrix} .\n\\begin{pmatrix}\n    n_1 \\\\ n_2 \\\\ n_3 \\\\ \\vdots \\\\ n_{30}\n\\end{pmatrix} +\n\\begin{pmatrix}\n    B \\\\ 0 \\\\ 0 \\\\ \\vdots \\\\ 0\n\\end{pmatrix} =\n\\begin{pmatrix}\n    0 \\\\ 0 \\\\ 0 \\\\ \\vdots \\\\ 0\n\\end{pmatrix}\n\\]\nTo solve this equation in R, we can do\n\nCode# solve(a, b) solves the equation a %*% x = b for x, so rearrange equation above so b is on the RHS of the equation\nmultistage_stable_n &lt;- solve(\n    aging_mat,\n    c(-1 * multistage_params[[\"births\"]], rep(0, 29))\n)\n\nmultistage_stable_n\n\n [1]  100  100  100  100  100  100  100  100  100  100  100  100  100  100  100\n[16]  100  100  100  100  100  500  500  500  500  500  500  500  500  500 1500\n\n\n\nCode# Check the final pop value of the S-only sim is equal to the sum of the stable age distribution calculated above\nround(tail(multistage_sonly_pop$pop, 1)) == sum(multistage_stable_n)\n\n[1] TRUE\n\n\nThe following lines then compute \\(R_0\\) using the next generation matrix method. This calculation comes from a recipe described in detail previously (Diekmann and Heesterbeek 2000; Heesterbeek 2002; Bjørnstad 2018; Heffernan, Smith, and Wahl 2005; Hurford, Cownden, and Day 2009) (we would recommend starting with (Bjørnstad 2018; and Heffernan, Smith, and Wahl 2005)).\n\n\n\n\n\n\nWarning\n\n\n\nThis is Aaron’s original code and gives slightly different results than the calculations below.\n\n\n\nCodeF_mat &lt;- diag(multistage_stable_n) %*% multistage_params[[\"beta_mat\"]] +\n    multistage_params[[\"aging_mat\"]] -\n    diag(diag(multistage_params[[\"aging_mat\"]]))\n\nV_mat &lt;- diag(multistage_params[[\"recovery\"]] - diag(multistage_params[[\"aging_mat\"]]))\n\nmax(\n    Re(\n        eigen(solve(V_mat, F_mat), only.values = TRUE)$values\n    )\n)\n\n[1] 6.792003\n\n\nThe steps below are copied from (Bjørnstad 2018)\n\nIdentify all n infected compartments\nConstruct a n × 1 matrix, \\(\\mathbf{F}\\), that contains expressions for all completely new infections entering each infected compartment\nConstruct a n × 1 matrix, \\(\\mathbf{V^−}\\), that contains expressions for all losses out of each infected compartment\nConstruct a n × 1 matrix, \\(\\mathbf{V^+}\\), that contains expressions for all gains into each infected compartment that does not represent new infections but transfers among infectious classes\nConstruct a n × 1 matrix, \\(\\mathbf{V} = \\mathbf{V^−} − \\mathbf{V^+}\\)\n\nGenerate two n × n Jacobian matrices \\(f\\) and \\(v\\) that are the partial derivatives of \\(\\mathbf{F}\\) and \\(\\mathbf{V}\\) with respect to the \\(n\\) infectious state variables\nEvaluate the matrices at the disease free equilibrium (dfe), and finally\n\n\\(R_0\\) is the spectral trace (greatest non-negative real eigenvalue) of \\(\\mathbf{fv}^{−1}|_{\\text{dfe}}\\).\n\nWorking through these steps looks like this:\n\nOur only infected compartments are the \\(I_i\\) states, for each age group (\\(i \\in [1, 30]\\)) To start, let’s write out our differential equation:\n\n\\[\\begin{equation}\n    \\frac{\\dd{I_i}}{\\dd{t}} = \\lambda_i S_i - \\gamma I_i + \\alpha_{i-1} I_{i-1} - \\alpha_i I_i\n\\end{equation}\\]\n\nWe’ll now calculate \\(\\mathbf{F}\\) and \\(\\mathbf{f}\\)\n\n\n\\[\\begin{align*}\n    \\mathbf{F} &= \\begin{pmatrix}\n        \\lambda_1 S_1 + \\cancelto{0}{\\alpha_0 I_0} \\\\\n        \\vdots \\\\\n        \\lambda_{30} S_{30} + \\alpha_{29} I_{29}\n    \\end{pmatrix} \\\\ \\\\\n    \\mathbf{F} &= \\begin{pmatrix}\n        \\left(\\beta_{1, 1} I_1 + \\cdots + \\beta_{1, 30} I_{30} \\right)S_1 \\\\\n        \\vdots \\\\\n        \\left(\\beta_{30, 1} I_1 + \\cdots + \\beta_{30, 30} I_{30} \\right) S_{30} + \\alpha_{29} I_{29}\n    \\end{pmatrix} \\\\\n    \\mathbf{f} &= \\begin{pmatrix}\n        \\frac{\\partial F_1}{\\partial I_1} & \\cdots & \\frac{\\partial F_1}{\\partial I_{30}} \\\\\n        \\vdots & \\ddots & \\vdots \\\\\n        \\frac{\\partial F_{30}}{\\partial I_1} & \\cdots & \\frac{\\partial F_{30}}{\\partial I_{30}}\n    \\end{pmatrix} & \\frac{\\partial F_1}{\\partial I_1} &= \\frac{\\partial}{\\partial I_1} \\left( \\beta_{1, 1} I_1 + \\cancelto{0}{\\beta_{1, 2} I_2 + \\cdots + \\beta_{1, 30} I_{30}}\\right) S_1 \\\\\n    & & \\frac{\\partial F_1}{\\partial I_1} &= \\beta_{1, 1} S_1 \\\\\n    \\mathbf{f} &= \\begin{pmatrix}\n        \\beta_{1, 1} S_1 & \\cdots & \\beta_{1, 30} S_1 \\\\\n        \\vdots & \\ddots & \\vdots \\\\\n        \\beta_{30, 1} S_{30} & \\cdots & \\beta_{30, 30} S_{30}\n    \\end{pmatrix}\n\\end{align*}\\]\n\nNow let’s calculate \\(\\mathbf{V^-}\\), \\(\\mathbf{V^+}\\), \\(\\mathbf{V}\\), and \\(\\mathbf{v}\\)\n\n\n\\[\\begin{align*}\n    \\mathbf{V^-} &= \\begin{pmatrix}\n        \\gamma I_1 + \\alpha_1 I_1 \\\\\n        \\gamma I_2 + \\alpha_2 I_2 \\\\\n        \\vdots \\\\\n        \\gamma I_{30} + \\alpha_{30} I_{30}\n    \\end{pmatrix} & \\mathbf{V^+} &= \\begin{pmatrix}\n        \\cancelto{0}{\\alpha_0 I_0} \\\\\n        \\alpha_1 I_1 \\\\\n        \\vdots \\\\\n        \\alpha_{29} I_{29}\n    \\end{pmatrix} \\\\ \\\\\n    \\mathbf{V} &= \\mathbf{V^-} - \\mathbf{V^+} = \\begin{pmatrix}\n        \\gamma I_1 + \\alpha_1 I_1 \\\\\n        \\gamma I_2 + \\alpha_2 I_2 - \\alpha_1 I_1\\\\\n        \\vdots \\\\\n        \\gamma I_{30} + \\alpha_{30} I_{30} - \\alpha_{29} I_{29}\n    \\end{pmatrix} \\\\ \\\\\n    \\mathbf{v} &= \\begin{pmatrix}\n        \\pdv{V_1}{I_1} & \\cdots & \\pdv{V_1}{I_{30}} \\\\\n        \\vdots & \\ddots & \\vdots \\\\\n        \\pdv{V_{30}}{I_1} & \\cdots & \\pdv{V_{30}}{I_{30}}\n    \\end{pmatrix} & \\pdv{V_1}{I_1} &= \\pdv{I_1} I_1 \\left( \\gamma + \\alpha_1  \\right)\\\\\n    & & \\pdv{V_1}{I_1} &= \\gamma + \\alpha_1 \\\\ \\\\\n    & & \\pdv{V_2}{I_1} &= \\pdv{I_1} \\left( \\cancelto{0}{I_2 \\left( \\gamma + \\alpha_2  \\right)} - \\alpha_1 I_1 \\right)\\\\\n    & & \\pdv{V_2}{I_1} &= - \\alpha_1 \\\\ \\\\\n    & & \\pdv{V_1}{I_2} &= \\pdv{I_2} \\cancelto{0}{I_1 \\left( \\gamma + \\alpha_1  \\right)} \\\\\n    & & \\pdv{V_1}{I_2} &= 0 \\\\ \\\\\n    \\mathbf{v} &= \\begin{pmatrix}\n        \\gamma + \\alpha_1 & 0 &  \\cdots  & 0\\\\\n        - \\alpha_1 & \\gamma + \\alpha_2 & \\cdots & 0 \\\\\n        \\vdots & \\ddots & \\ddots & \\vdots \\\\\n        0 & \\cdots & - \\alpha_{29} & \\gamma + \\alpha_{30}\n    \\end{pmatrix}\n\\end{align*}\\]\n\nTo evaluate \\(\\mathbf{f}\\) and \\(\\mathbf{v}\\) at the disease-free equilibrium, we can use the results from our previous calculations. \\(\\mathbf{v}\\) doesn’t have any state terms in the equation, so it is already evaluated at \\(\\text{dfe}\\). \\(\\mathbf{f}|_{\\text{dfe}}\\) involves subsituting \\(S_i\\) for the equilibrium population distribution that balances the births and aging processes.\n\nThis translates to the function we defined earlier\n\n7.6.2 Mean age of infection R code\nNow let’s look at how we can investigate our the relationships between the mean age of infection and \\(R_0\\) and the vaccination coverage using R. Unlike the interactive plot that simply uses Equation 7.2 to calculate the mean age of infection, we will use a more realistic age-structured model.\nLet’s return to the earlier models with an age-class mixing matrix. But this time, we’ll calculate \\(R_0\\), the mean age of infection, and the number of cases that occur in individuals between 15-35 years as we increase the contact rate.\nRecall from the rubella and congenital rubella syndrome (CRS) example that the risk of severe disease outcomes depends on the risk of infection in reproductive age women (here we’ll use individuals between 15 and 35 years as a proxy; in reality we would want to account for the differential rate of reproduction at different ages, including those above 35 years). Recall also that increasing vaccination reduces \\(R_E\\) – for simplicity here, so we don’t have to add vaccination into the code, we’ll simply change \\(R_0\\) because we already know that will give us outcomes that are dynamically equivalent to increasing the proportion of children born who are vaccinated. We’ll then calculate how the mean age of infection changes, and specifically how the absolute number of cases among individuals between the ages of 15-35 (as a proxy for reproductive age women) changes. To do so, we’ll make a loop and evaluate the code for each of 10 decreaing levels of mixing (which will reduce \\(R_0\\) and we can interpret as analogous to the reduction in \\(R_E\\) that would result from increasing vaccination).\n\n\n\n\n\n\nNote about map()\n\n\n\n\n\nAs you may have noticed previously, we often use the map_*() series of functions. We’ll use that again here (map_dfr()). The full reasons are too complicated to get into here, but broadly speaking, the map_*() functions provide us guarantees over the output of our loops. If it runs, we know that something didn’t get silently skipped, and that out output vector/list/dataframe is the same length as the inputs. The same can not be said for for() loops, and the base apply functions are more awkward to work with as they don’t have a consistent syntax across the family of functions.\nTo learn more, read this section of our R primer.\n\n\n\n\nCode# Create vector of scalings to reduce R0\nscale_contact &lt;- seq(1, .2, length = 10)\n\n# Create a new transmission matrix\nbeta_low &lt;- 0.007\nbeta_medium &lt;- 0.02\nbeta_high &lt;- 0.03\n\nbeta_mat &lt;- matrix(beta_low, nrow = 30, ncol = 30)\nbeta_mat[1:20, 1:20] &lt;- beta_medium\nbeta_mat[6:16, 6:16] &lt;- beta_high\n\nscaled_params &lt;- multistage_params\n\n\n\nCode# Create a dataframe where each row relates to a different R0 value\nR0_mean_age_contacts_df &lt;- map_dfr(\n    # Apply the function to each item in the vector of R0 scaling factors\n    .x = scale_contact,\n    .f = function(.x) {\n        # Scale contacts\n        scaled_beta_mat &lt;- beta_mat * .x\n\n        # Set up parameters\n        scaled_params[[\"beta_mat\"]] &lt;- scaled_beta_mat\n\n        # Solve the model\n        sol &lt;- deSolve::ode(\n            y = demog_yinit_ages,\n            times = seq(0, 400, by = 0.1),\n            func = multistage_model,\n            parms = scaled_params\n        )\n\n        # Get stable age distribution\n        stable_n &lt;- solve(\n            scaled_params[[\"aging_mat\"]],\n            -c(scaled_params[[\"births\"]], rep(0, 29))\n        )\n\n        R0 &lt;- calculate_R0(\n            beta_mat = scaled_params[[\"beta_mat\"]],\n            stable_n_mat = stable_n,\n            aging_mat = scaled_params[[\"aging_mat\"]],\n            recovery = scaled_params[[\"recovery\"]]\n        )\n\n        # Get final number of infected individuals for each I class\n        infecteds &lt;- sol[dim(sol)[1], 1 + iindex]\n\n        # Calculate mean age of infection\n        mean_age &lt;- sum(ages * infecteds / sum(infecteds))\n\n        # Calculate sum of cases between 15-35 years \n        # recall, from the figures above, that that this is the equilibrium prevalence\n        # of infection in these age classes, or the average numbef of individuals that are infected \n        # at any given time in these age classes. Note that we're not differentiating between \n        # individuals who can and cannot get pregnant here. So we're making an implicit assumption that\n        # there no difference in the risk of rubella infection in these groups so that if prevalence goes\n        # up in one group, it goes up in the other.\n        sum_cases &lt;- sum(infecteds[15:23])\n\n        # Return a dataframe with the values\n        return(tibble(R0, mean_age, sum_cases))\n    }\n)\n\n\nNow we can make a table of the results and plot mean age and the sum of cases between 15-35 years of age as a function of \\(R_0\\).\n\nCode# Create a table from the dataframe\ngt(R0_mean_age_contacts_df) %&gt;%\n    fmt_number(\n        columns = everything(),\n        decimals = 2\n    ) %&gt;%\n    # Relabel the column headers\n    cols_label(\n        R0 = md(\"**R0**\"),\n        mean_age = md(\"**Mean age of&lt;br&gt;infection**\"),\n        sum_cases = md(\"**Total cases between&lt;br&gt;15-35 years**\")\n    ) %&gt;%\n    # Apply style to the table with gray alternating rows\n    opt_stylize(style = 1, color = 'gray') %&gt;%\n    # Increate space between columns\n    opt_horizontal_padding(scale = 3) %&gt;%\n    cols_align(\"center\")\n\n\n\n\n\n\nR0\n      Mean age ofinfection\n      Total cases between15-35 years\n    \n\n\n6.85\n6.08\n0.54\n\n\n6.24\n6.61\n0.66\n\n\n5.63\n7.28\n0.81\n\n\n5.02\n8.15\n0.98\n\n\n4.41\n9.30\n1.20\n\n\n3.81\n10.87\n1.45\n\n\n3.20\n13.11\n1.74\n\n\n2.59\n16.40\n2.01\n\n\n1.98\n21.50\n2.11\n\n\n1.37\n29.72\n1.48\n\n\n\n\n\n\n\nCodeR0_mean_age_contacts_df %&gt;%\n    # Convert to long data frame for facet plotting\n    pivot_longer(-R0, names_to = \"metric\", values_to = \"value\") %&gt;%\n    ggplot(aes(x = R0, y = value)) +\n    geom_line(color = \"slategray4\") +\n    geom_point(shape = 21, size = 5, fill = \"slategray4\", alpha = 0.8) +\n    facet_wrap(\n        ~metric,\n        scales = \"free_y\",\n        labeller = as_labeller(c(\n            mean_age = \"Mean Age of Infection\",\n            sum_cases = \"Total cases between 15-35 years\"\n        ))\n    ) +\n    labs(\n        x = \"R0\",\n        y = \"Value\"\n    )\n\n\n\n\n\n7.6.3 What do real contact networks look like?\nThe POLYMOD study (Mossong et al. 2008) was a journal-based look into the contact network in contemporary European society. Let’s have a look what these data tell us about the contact structure.\n\nCodemossong_cont_net &lt;- rio::import(\"https://raw.githubusercontent.com/arnold-c/SISMID-Module-02_2023/main/data/mossong-matrix.csv\")\n# mossong_cont_net &lt;- rio::import(here::here(\"data\", \"mossong-matrix.csv\"))\n\nmossong_ages &lt;- unique(mossong_cont_net$contactor)\nmossong_cont_net$contactor &lt;- ordered(mossong_cont_net$contactor, levels = mossong_ages)\nmossong_cont_net$contactee &lt;- ordered(mossong_cont_net$contactee, levels = mossong_ages)\n\n\nSince contacts are symmetric, we’ll need to estimate the symmetric contact matrix.\n\nCodemossong_mat &lt;- mossong_cont_net %&gt;%\n    pivot_wider(\n        names_from = contactor,\n        values_from = contact.rate\n    ) %&gt;%\n    select(-contactee) %&gt;%\n    as.matrix()\n\nrownames(mossong_mat) &lt;- mossong_ages\n\n# Create a symmetrical contact matrix\nmossong_mat_sym &lt;- (mossong_mat + t(mossong_mat)) / 2\n\n\nHere we’ll use the filled.contour function to visualize the contact matrix, to show you an alternative way of visualizing contact matrices. Notices that we are using the raw matrix object, not a long dataframe, as previously.\n\nCodefilled.contour(\n    ages, ages, log10(mossong_mat),\n    plot.title = title(\n        main = \"Log10 of Raw Contact Rate\",\n        xlab = \"Age of Contactor\",\n        ylab = \"Age of Contactee\"\n    )\n)\n\n\n\n\n\nCodefilled.contour(\n    ages, ages, log10(mossong_mat_sym),\n    plot.title = title(\n        main = \"Log10 of Symmetrical Contact Rate\",\n        xlab = \"Age of Contactor\",\n        ylab = \"Age of Contactee\"\n    )\n)\n\n\n\n\n\nCodemossong_cont_sums &lt;- tibble(\n        age = factor(mossong_ages, levels = mossong_ages),\n        contactees = rowSums(mossong_mat),\n        contactors = colSums(mossong_mat)\n    ) %&gt;%\n    pivot_longer(-age, names_to = \"type\", values_to = \"total_contacts\") \n\n\n\nCodeggplot(\n        mossong_cont_sums,\n        aes(x = age, y = total_contacts, color = type, fill = type, group = type)\n    ) +\n    geom_path(linewidth = 1) +\n    geom_point(\n        position = \"identity\",\n        alpha = 0.8,\n        shape = 21,\n        size = 4\n    ) +\n    scale_color_manual(\n        values = c(\"slategray4\", \"navy\"),\n        labels = c(\"Contactees\", \"Contactors\"),\n        aesthetics = c(\"color\", \"fill\")\n    ) +\n    guides(color = \"none\") +\n    labs(\n        x = \"Age\",\n        y = \"Total contacts\",\n        fill = \"Type of contact\"\n    ) +\n    theme(legend.position = \"bottom\")\n\n\n\n\nWhile this matrix tells us how many contacts are made per year by an individual of each age, it doesn’t tell us anything about the probability that a contact results in communication of infection. Let’s assume that each contact has a constant probability \\(q\\) of resulting in a transmission event.\n\nCodeq &lt;- 3e-5\nmossong_beta_mat &lt;- q * mossong_mat_sym\n\n\n\nCodefilled.contour(\n    ages, ages, log10(mossong_beta_mat),\n    plot.title = title(\n        main = \"WAIFW matrix based on POLYMOD data\",\n        xlab = \"Age\",\n        ylab = \"Age\"\n    )\n)\n\n\n\n\nNow let’s simulate the introduction of such a pathogen into a population characterized by this contact structure.\n\nCode# Update the parameters with the POLYMOD-based beta matrix\nmossong_params &lt;- multistage_params\nmossong_params[[\"beta_mat\"]] &lt;- mossong_beta_mat\n\n# Solve the model with the updated parameters\nmossong_sol &lt;- deSolve::ode(\n    y = demog_yinit_ages,\n    times = seq(0, 200, by = 0.5),\n    func = multistage_model,\n    parms = mossong_params\n)\n\n# Extract the timeseries of infectious individuals\nmossong_infecteds &lt;- mossong_sol[, 1 + iindex]\n\n# Convert infectious individual timeseries to dataframe for plotting\nmossong_infecteds_df &lt;- tibble(\n        time = mossong_sol[, 1],\n        Juveniles = apply(mossong_infecteds[, juvies], 1, sum),\n        Adults = apply(mossong_infecteds[, adults], 1, sum)\n    ) %&gt;%\n    pivot_longer(\n        cols = c(Juveniles, Adults),\n        names_to = \"age_group\",\n        values_to = \"infections\"\n    ) %&gt;%\n    mutate(\n        age_group = factor(age_group, levels = c(\"Juveniles\", \"Adults\"))\n    )\n\n\n\nCodeggplot(mossong_infecteds_df, aes(x = time, y = infections, color = age_group)) +\n    geom_line(linewidth = 1.5) +\n    scale_color_manual(\n        values = age_group_colors\n    ) +\n    labs(\n        x = \"Time\",\n        y = \"Number of infections\",\n        color = \"Age group\"\n    )\n\n\n\n\nAs before, we can also look at the equilibrium seroprevalence\n\nCode# Get last time point\nmossong_equil &lt;- drop(tail(mossong_sol, 1))[-1]\n\n# Calculate number of individuals in each age group at end of simulation\nmossong_equil_n &lt;- mossong_equil[sindex] +\n    mossong_equil[iindex] +\n    mossong_equil[rindex]\n\n# Calculate equilibrium seroprevalence\nmossong_equil_seroprev &lt;- mossong_equil[rindex] / mossong_equil_n\n\n# Convert to dataframe for plotting\nmossong_equil_seroprev_df &lt;- tibble(\n    # We can reuse the ages vectors from before as they are the same\n    # as the POLYMOD data\n    age = ages,\n    seroprev = mossong_equil_seroprev,\n    width = da_ages\n)\n\n\n\nCodeggplot(mossong_equil_seroprev_df, aes(x = age, y = seroprev, fill = age)) +\n    geom_col(width = mossong_equil_seroprev_df$width, just = 1.0, color = \"black\") +\n    labs(\n        x = \"Age\",\n        y = \"Seroprevalence\"\n    ) +\n    scale_x_continuous(breaks = seq(0, 80, 10)) +\n    scale_fill_continuous(low = age_group_colors[1], high = age_group_colors[2])\n\n\n\n\nand compute the \\(R_0\\) for this infection.\n\nCodemossong_stable_n &lt;- solve(\n    mossong_params[[\"aging_mat\"]],\n    -c(mossong_params[[\"births\"]], rep(0, 29))\n)\n\ncalculate_R0(\n    beta_mat = mossong_params[[\"beta_mat\"]],\n    stable_n_mat = mossong_stable_n,\n    aging_mat = mossong_params[[\"aging_mat\"]],\n    recovery = mossong_params[[\"recovery\"]]\n)\n\n[1] 7.058675\n\n\n\n\n\n\n\n\nQUESTION\n\n\n\nHow does this R0 value compare to the R0 value obtained from Section 7.4.2?\n\n\n\n\n\n\n\n\nBjørnstad, Ottar N. 2018. “Advanced: The Next-Generation Matrix.” In Epidemics: Models and Data Using R, 51. Use R! Cham: Springer International Publishing. https://doi.org/10.1007/978-3-319-97487-3.\n\n\nDiekmann, O., and J. A. P. Heesterbeek. 2000. Mathematical Epidemiology of Infectious Diseases: Model Building, Analysis and Interpretation. Wiley Series in Mathematical & Computational Biology. Wiley. https://books.google.ca/books?id=5VjSaAf35pMC.\n\n\nHeesterbeek, J. A. P. 2002. “A Brief History of R0 and a Recipe for Its Calculation.” Acta Biotheoretica 50 (3): 189–204. https://doi.org/10.1023/A:1016599411804.\n\n\nHeffernan, J. M, R. J Smith, and L. M Wahl. 2005. “Perspectives on the Basic Reproductive Ratio.” J R Soc Interface 2 (4): 281–93. https://doi.org/10.1098/rsif.2005.0042.\n\n\nHurford, Amy, Daniel Cownden, and Troy Day. 2009. “Next-Generation Tools for Evolutionary Invasion Analyses.” Journal of The Royal Society Interface 7 (45): 561–71. https://doi.org/10.1098/rsif.2009.0448.\n\n\nKing, Aaron A, and Helen J Wearing. 2011. “Age Structured Models.” In. https://ms.mcmaster.ca/~bolker/eeid/2011_eco/waifw.pdf.\n\n\nMossong, Joël, Niel Hens, Mark Jit, Philippe Beutels, Kari Auranen, Rafael Mikolajczyk, Marco Massari, et al. 2008. “Social Contacts and Mixing Patterns Relevant to the Spread of Infectious Diseases.” PLOS Medicine 5 (3): e74. https://doi.org/10.1371/journal.pmed.0050074."
  },
  {
    "objectID": "r-session-03.html#setup",
    "href": "r-session-03.html#setup",
    "title": "\n9  R Session 03\n",
    "section": "\n9.1 Setup",
    "text": "9.1 Setup\n\nCodelibrary(here)\nlibrary(rio)\nlibrary(deSolve)\nlibrary(tidyverse)\nlibrary(ggtext)\nlibrary(gt)\n\n\n\nCodetheme_set(theme_minimal())\n\n\n\nCode# Loads the datasets: flu, measles, niamey, plauge\nflu &lt;- rio::import(\"https://raw.githubusercontent.com/arnold-c/SISMID-Module-02_2023/main/data/flu.csv\")\nniamey &lt;- rio::import(\"https://raw.githubusercontent.com/arnold-c/SISMID-Module-02_2023/main/data/niamey.csv\")\n# flu &lt;- rio::import(here::here(\"data\", \"flu.csv\"))\n# niamey &lt;- rio::import(here::here(\"data\", \"niamey.csv\"))"
  },
  {
    "objectID": "r-session-03.html#estimating-r_0-problem-background",
    "href": "r-session-03.html#estimating-r_0-problem-background",
    "title": "\n9  R Session 03\n",
    "section": "\n9.2 Estimating \\(R_0\\) Problem Background",
    "text": "9.2 Estimating \\(R_0\\) Problem Background\nSo far in this class we have focused on the theory of infectious disease. Often, however, we will want to apply this theory to particular situations. One of the key applied problems in epidemic modeling is the estimation of \\(R_0\\) from outbreak data. In this session, we study two methods for estimating \\(R_0\\) from an epidemic curve. As a running example, we will use the data on influenza in a British boarding school.\n\nCodeggplot(flu, aes(x = day, y = flu)) +\n    geom_line(color = \"slategray4\") +\n    geom_point(shape = 21, size = 5, fill = \"slategray4\", alpha = 0.8) +\n    labs(x = \"Day\", y = \"Active Influenza Cases\")"
  },
  {
    "objectID": "r-session-03.html#estimating-r_0-from-the-final-outbreak-size",
    "href": "r-session-03.html#estimating-r_0-from-the-final-outbreak-size",
    "title": "\n9  R Session 03\n",
    "section": "\n9.3 Estimating \\(R_0\\) From The Final Outbreak Size",
    "text": "9.3 Estimating \\(R_0\\) From The Final Outbreak Size\nOur first approach is to estimate \\(R_0\\) from the final outbreak size. Although unhelpful at the early stages of an epidemic (before the final epidemic size is observed), this method is nonetheless a useful tool for post hoc analysis. The method is general and can be motivated by the argument listed in (Keeling and Rohani 2008):\nFirst, we assume that the epidemic is started by a single infectious individual in a completely susceptible population. On average, this individual infects \\(R_0\\) others. The probability a particular individual escaped infection is therefore \\(e^{-R_0 / N}\\).\nIf \\(Z\\) individuals have been infected, the probability of an individual escaping infection from all potential sources is \\(e^{-Z R_0 / N}\\). It follows that at the end of the epidemic a proportion \\(R(\\infty) = Z / N\\) have been infected and the fraction remaining susceptible is \\(S(\\infty) = e^{-R(\\infty) R_0}\\), which is equal to \\(2 - R(\\infty)\\).\n\n\n\n\n\n\nNote\n\n\n\n\n\n\\(S(\\infty) = e^{-R(\\infty) R_0}\\) can be calculated by acknowledging that at equilibrium (\\(t = \\infty\\)), \\(S(\\infty) = 1 - R(\\infty) = Z / N\\), so substituting \\(R(\\infty)\\) into \\(1 - e^{-Z R_0 / N}\\) gives the desired result.\nIt could also be calculated by dividing \\(\\frac{\\dd{S}}{\\dd{t}}\\) by \\(\\frac{\\dd{R}}{\\dd{t}}\\):\n\\[\\begin{aligned}\n\\frac{\\dd{S}}{\\dd{R}} &= - \\frac{\\beta S}{\\gamma} \\\\\n&= - R_0 S\n\\end{aligned}\\]\nwhich is a separable differential equation, so can be integrated as follows:\n\\[\\begin{aligned}\n- \\int_{0}^{t} \\frac{1}{R_0 S} \\dd{S} &= \\int_{0}^{t} \\dd{R} \\\\\n- \\frac{1}{R_0} \\left(\\ln{S(t)} - \\ln{S(0)} \\right) &= R(t) - \\cancelto{0}{R(0)} \\\\\n\\ln{S(t)} &= \\ln{S(0)} - R_0 R(t) \\\\\nS(t) &= S(0) e^{-R_0 R(t)}\n\n\\end{aligned}\\]\n\n\n\nPutting this together, we get:\n\\[\n1 - R(\\infty) - e^{-R(\\infty) R_0} = 0\n\\]\nRearranging, we have the estimator\n\\[\n  \\hat{R_0} = \\frac{\\ln(1 - Z / N)}{-Z / N},\n\\]\nwhich, in this case, evaluates to \\(\\frac{\\ln(1 - 512 / 764)}{-512 / 764} = 1.655\\).\n\n9.3.1 Exercise 1\nThis equation shows the important one-to-one relationship between \\(R_0\\) and the final epidemic size. Plot the relationship between the total epidemic size and \\(R_0\\) for the complete range of values between 0 and 1."
  },
  {
    "objectID": "r-session-03.html#linear-approximation",
    "href": "r-session-03.html#linear-approximation",
    "title": "\n9  R Session 03\n",
    "section": "\n9.4 Linear Approximation",
    "text": "9.4 Linear Approximation\nThe next method we introduce takes advantage of the fact that during the early stages of an outbreak, the number of infected individuals is given approximately as \\(I(t) \\approx I_0 e^{((R_0 - 1)(\\gamma + \\mu)t)}\\). Taking logarithms of both sides, we have \\(\\ln(I(t)) \\approx \\ln(I_0) + (R_0 - 1)(\\gamma + \\mu)t\\), showing that the log of the number of infected individuals is approximately linear in time with a slope that reflects both \\(R_0\\) and the recovery rate.\nThis suggests that a simple linear regression fit to the first several data points on a log-scale, corrected to account for \\(\\gamma\\) and \\(\\mu\\), provides a rough and ready estimate of \\(R_0\\). For flu, we can assume \\(\\mu =0\\) because the epidemic occurred over a time period during which natural mortality is negligible. Further, assuming an infectious period of about 2.5 days, we use \\(\\gamma = (2.5)^{-1} = 0.4\\) for the correction. Fitting to the first four data points, we obtain the slope as follows.\n\nCode# Fit a linear model\nlinear_model &lt;- lm(log(flu[1:4]) ~ day[1:4], data = flu)\n\n# Summary statistics for fit model\nsummary(linear_model)\n\n\nCall:\nlm(formula = log(flu[1:4]) ~ day[1:4], data = flu)\n\nResiduals:\n       1        2        3        4 \n 0.03073 -0.08335  0.07450 -0.02188 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)   \n(Intercept) -0.02703    0.10218  -0.265  0.81611   \nday[1:4]     1.09491    0.03731  29.346  0.00116 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.08343 on 2 degrees of freedom\nMultiple R-squared:  0.9977,    Adjusted R-squared:  0.9965 \nF-statistic: 861.2 on 1 and 2 DF,  p-value: 0.001159\n\nCode# Extract slope parameter\ncoef(linear_model)[2]\n\nday[1:4] \n1.094913 \n\n\nRearranging the linear equation above and denoting the slope coefficient by \\(\\hat \\beta_1\\) we have the estimator \\(\\hat R_0 = \\hat \\beta_1 / \\gamma + 1\\) giving \\(\\hat R_0 = 1.094913 / 0.4 + 1 \\approx 3.7\\).\n\n9.4.1 Exercise 2\nOur estimate assumes that boys remained infectious during the natural course of infection. The original report on this epidemic indicates that boys found to have symptoms were immediately confined to bed in the infirmary. The report also indicates that only 1 out of 130 adults at the school exhibited any symptoms. It is reasonable, then, to suppose that transmission in each case ceased once he had been admitted to the infirmary. Supposing admission happened within 24 hours of the onset of symptoms. How does this affect our estimate of \\(R_0\\)? Twelve hours?\n\n9.4.2 Exercise 3\nBiweekly data for outbreaks of measles in three communities in Niamey, Niger are provided in the dataframe niamey. Use this method to obtain estimates of \\(R_0\\) for measles from the first community assuming that the infectious period is approximately two weeks or \\(\\frac{14}{365} \\approx 0.0384\\) years.\n\n9.4.3 Exercise 4\nA defect with this method is that it uses only a small fraction of the information that might be available, i.e., the first few data points. Indeed, there is nothing in the method that tells one how many data points to use–this is a matter of judgment. Further, there is a tradeoff in that as more and more data points are used the precision of the estimate increases, but this comes at a cost of additional bias. Plot the estimate of \\(R_0\\) obtained from \\(n=3, 4, 5, ...\\) data points against the standard error of the slope from the regression analysis to show this tradeoff."
  },
  {
    "objectID": "r-session-03.html#estimating-dynamical-parameters-with-least-squares",
    "href": "r-session-03.html#estimating-dynamical-parameters-with-least-squares",
    "title": "\n9  R Session 03\n",
    "section": "\n9.5 Estimating dynamical parameters with least squares",
    "text": "9.5 Estimating dynamical parameters with least squares\nThe objective of the previous exercise was to estimate \\(R_0\\). Knowing \\(R_0\\) is critical to understanding the dynamics of any epidemic system. It is, however, a composite quantity and is not sufficient to completely describe the epidemic trajectory. For this, we require estimates for all parameters of the model. In this exercise, we introduce a simple approach to model estimation called least squares fitting, sometimes called trajectory matching. The basic idea is that we find the values of the model parameters that minimize the squared differences between model predictions and the observed data. To demonstrate least squares fitting, we consider an outbreak of measles in Niamey, Niger, reported on by (Grais et al. 2006).\n\nCode# Replace an \"NA\"\nniamey[5, 3] &lt;- 0 \n\nniamey_df &lt;- niamey %&gt;%\n    # Rename columns to remove automatic \"V1\" etc columns names\n    rename_with(., ~paste0(\"Site_\", str_remove(.x, \"V\"))) %&gt;%\n    # Add a column for the biweekly time period\n    mutate(biweek = 1:16) %&gt;%\n    # Convert to long format for plotting\n    pivot_longer(\n        cols = contains(\"Site\"),\n        names_to = \"site\",\n        values_to = \"cases\"\n    )\n\n\n\nCode# Create a vector of colors for each site in the Niamey dataset\nniamey_site_colors &lt;- RColorBrewer::brewer.pal(3, \"Dark2\")\n# Assign names to the colors\nnames(niamey_site_colors) &lt;- unique(niamey_df$site)\n\n# Create a vector of labels for each site for nicer plotting legends\nniamey_site_labels &lt;- str_replace_all(names(niamey_site_colors), \"_\", \" \")\nnames(niamey_site_labels) &lt;- names(niamey_site_colors)\n\n\n\nCodeggplot(\n        niamey_df,\n        aes(x = biweek, y = cases, color = site, fill = site, group = site)\n    ) +\n    geom_line() +\n    geom_point(shape = 21, size = 5, alpha = 0.8) +\n    scale_color_manual(\n        values = niamey_site_colors,\n        aesthetics = c(\"color\", \"fill\"),\n        labels = niamey_site_labels\n    ) + \n    guides(color = \"none\") +\n    labs(x = \"Biweek\", y = \"Number of Cases\", fill = \"Site Number\") +\n    theme(legend.position = \"bottom\")"
  },
  {
    "objectID": "r-session-03.html#dynamical-model",
    "href": "r-session-03.html#dynamical-model",
    "title": "\n9  R Session 03\n",
    "section": "\n9.6 Dynamical Model",
    "text": "9.6 Dynamical Model\nFirst, we write a specialized function for simulating the SIR model in a case where the removal rate is “hard-wired” and with no demography.\n\nCode#' Basic SIR model\n#'\n#' A basic SIR model with no demographic structure to be used in deSolve\n#'\n#' @param time deSolve passes the time parameter to the function.\n#' @param state A vector of states.\n#' @param params The beta parameter\n#' @param ... Other arguments passed by deSolve.\n#'\n#' @return A deSolve matrix of states at each time step.\n#' @examples\n#' sir_params &lt;- 0.0005\n#' sir_init_states &lt;- c(S = 5000, I = 1, R = 0)\n#' sim_times &lt;- seq(0, 16 / 365, by = 0.1 / 365)\n#' \n#' sir_sol &lt;- deSolve::ode(\n#'    y = sir_init_states,\n#'    times = sim_times,\n#'    func = closed_sir_model,\n#'    parms = sir_params\n#' ))\nclosed_sir_model &lt;- function (time, state , params, ...) {\n    # Unpack states\n    S &lt;- state[\"S\"]\n    I &lt;- state[\"I\"]\n    \n    # Unpack parameters\n    beta &lt;- params\n    dur_inf &lt;- 14 / 365\n    gamma &lt;- 1 / dur_inf\n\n    # Calculate the ODEs\n    dSdt &lt;- - beta * S * I\n    dIdt &lt;- beta * S * I - (gamma * I)\n\n    # Return the ODEs\n    return(list(c(dSdt, dIdt)))\n}"
  },
  {
    "objectID": "r-session-03.html#interactive-optimization",
    "href": "r-session-03.html#interactive-optimization",
    "title": "\n9  R Session 03\n",
    "section": "\n9.7 Interactive Optimization",
    "text": "9.7 Interactive Optimization\n\nCodefiltered_niamey_data = aq.table(niamey_data)\n    .filter(aq.escape(d =&gt; d.site == site_select))\n\n\n\n\n\n\n\nCodereset_S = 10000\nreset_I = 20\nreset_beta = 5.00\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodefunction set(input, value) {\n  input.value = value;\n  input.dispatchEvent(new Event(\"input\", {bubbles: true}));\n}\n\n\n\n\n\n\n\nCodefunction sse(obs, preds) {\n\n    if(obs.length == preds.length) {\n        var squared_errs = obs.map((e, i) =&gt; (e - preds[i])**2 )\n        return squared_errs.reduce((a, b) =&gt; a + b, 0)\n    } else {\n        return(\"lengths are not the same\")\n    }\n}\n\n\n\n\n\n\n\n\nCodeviewof reset = Inputs.button([\n  [\"Reset all sliders\", () =&gt; {\n    set(viewof S0, reset_S)\n    set(viewof I0, reset_I)\n    set(viewof beta_input, reset_beta)\n  }]\n])\nviewof S0 = Inputs.range(\n    [500, 15000],\n    {value: reset_S, step: 50, label: md`${tex`S(0)`}`}\n)\n\nviewof I0 = Inputs.range(\n    [0.001, 50],\n    {value: reset_I, step: 0.001, label: md`${tex`I(0)`}`}\n)\n\nviewof beta_input = Inputs.range(\n    [1, 100],\n    {value: reset_beta, step: 0.01, label: md`${tex`\\beta (\\times 10^{-3})`}`}\n)\n\nviewof site_select = Inputs.select(\n    [\"Site 1\", \"Site 2\", \"Site 3\"],\n    {label: \"Select a site:\"}\n)\n\nbeta = (beta_input / 365) * 10 ** (-3)\n\nmd`${tex`R_0 = ${R0_str}`}`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodedur_inf = 14\ngamma = 1 / dur_inf\nR0 = beta * (S0 + I0)/ gamma\n\nR0_str = R0.toPrecision(2).toLocaleString()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodedt = 0.01\ntmax = 16 * 14\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodeimport {odeRK4} from '@rreusser/integration@3064'\nimport { aq, op } from '@uwdata/arquero'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodefunction sir(dydt, y, t) {\n    dydt[0] = - beta * y[0] * y[1] \n    dydt[1] = beta * y[0] * y[1] - gamma * y[1]\n    dydt[2] = gamma * y[1]\n}\n\n\n\n\n\n\n\nCodefunction simulate(f, t0, y0, dt, tmax) {\n    var t = t0\n    var y = y0\n    var i = 0\n\n    var tsim = [t0]\n    var ysim = [y0]\n\n    for (t = t0 + dt; t &lt;= tmax; t += dt) {\n        ysim.push(odeRK4([], ysim[i], f, dt))\n        tsim.push(t)\n        i += 1\n    }\n\n    var biweek = tsim.map(d =&gt; d / 14)\n    \n    return aq.table({\n        tday: tsim,\n        Biweek: biweek,\n        \"Number of Individuals\": ysim.map(d =&gt; d[1]),\n    })\n}\n\n\n\n\n\n\n\nCodesir_sol = simulate(sir, 0, [S0, I0, 0.0], dt, tmax)\n\n\n\n\n\n\n\nCodesiteColors = [\"#1b9e77\", \"#d95f02\", \"#7570b3\"]\n\n\n\n\n\n\n\nCodetimes = Array.from({length: 17}, (_, i) =&gt; i * 14).slice(1)\ntindex = times.map((e, i) =&gt; e * (1 / dt))\n\npreds = tindex.map((i) =&gt; sir_sol.array(\"Number of Individuals\")[i])\n\nsim_sse = [({\n    sse: sse(\n            filtered_niamey_data.array(\"Number of Individuals\"),\n            preds\n        ).toPrecision(4),\n    Biweek: 2,\n    \"Number of Individuals\": Math.max(\n        ...sir_sol.array(\"Number of Individuals\"),\n        ...filtered_niamey_data.array(\"Number of Individuals\")\n    ) * 0.9\n})]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodePlot.plot({\n    color: {\n        legend: true,\n        domain: [\"Site 1\", \"Site 2\", \"Site 3\"],\n        range: siteColors,\n    },\n    style: {fontSize: \"20px\"},\n    marginLeft: 75,\n    marginTop: 40,\n    marginBottom: 55,\n    grid: true,\n    width: 800,\n    height: 670,\n    marks: [\n        Plot.lineY(\n            sir_sol,\n            {x: \"Biweek\", y: \"Number of Individuals\", stroke: \"#4d4d4dff\", strokeWidth: 6, strokeOpacity: 0.8}\n        ),\n        Plot.dot(\n            filtered_niamey_data,\n            {x: \"Biweek\", y: \"Number of Individuals\", stroke: \"site\", fill: \"site\", fillOpacity: 0.6, r: 12}\n        ),\n        Plot.lineY(\n            filtered_niamey_data,\n            {x: \"Biweek\", y: \"Number of Individuals\", stroke: \"site\"}\n        ),\n        Plot.text(\n            sim_sse,\n            {x: \"Biweek\", y: \"Number of Individuals\", text: (d) =&gt; `SSE = ${d.sse}`, dx: 0, dy: 0, fontWeight: \"bold\"}\n        )\n    ]\n})"
  },
  {
    "objectID": "r-session-03.html#objective-function",
    "href": "r-session-03.html#objective-function",
    "title": "\n9  R Session 03\n",
    "section": "\n9.8 Objective Function",
    "text": "9.8 Objective Function\nNow we set up a function that will calculate the sum of the squared differences between the observations and the model at any parameterization (more commonly known as “sum of squared errors”). In general, this is called the objective function because it is the quantity that optimization seeks to minimize.\n\nCode#' Calculate the Sum of Squared Errors\n#'\n#' A function to take in biweekly incidence data, and SIR parameters, and\n#' calculate the SSE\n#'\n#' @param params A vector of parameter values\n#' @param data A dataframe containing biweekly incidence data in the case column\n#'\n#' @return The SSE of type double\n#' @examples\nsse_sir &lt;- function(params, data){\n    # Convert biweekly time series into annual time scale\n    # Daily time scale has requires beta values to be too small - doesn't \n    # optimize well\n    t &lt;- data$biweek * 14 / 365\n    \n    # Extract the number of actual cases\n    cases &lt;- data$cases\n\n    # Note the parameters are updated throughout the optimization process by\n    # the optim() function\n    # Unpack the transmission parameter and exponentiate to fit on ln scale\n    beta &lt;- exp(params[[\"beta\"]])\n\n    # Unpack the initial states and exponentiate to fit on normal scale\n    S_init &lt;- exp(params[[\"S_init\"]])\n    I_init &lt;- exp(params[[\"I_init\"]])\n    \n    # Fit SIR model to the parameters\n    sol &lt;- deSolve::ode(\n            y = c(S = S_init, I = I_init),\n            times = t,\n            func = closed_sir_model,\n            parms = beta,\n            hmax = 1/120\n        ) \n\n    # Calculate sum of squared errors that is returned to the optim() function\n    sum((sol[, 3] - cases)^2)\n}\n\n\nNotice that the code for sse_sir() makes use of the following modeling trick. We know that \\(\\beta\\), \\(S_0\\), and \\(I_0\\) must be positive, but our search to optimize these parameters will be over the entire number line. We could constrain the search using a more sophisticated algorithm, but this might introduce other problems (i.e., stability at the boundaries). Instead, we parameterize our objective function (sse_sir) in terms of some alternative variables \\(\\ln(\\beta)\\), \\(\\ln(S_0)\\), and \\(\\ln(I_0)\\). While these numbers range from \\(-\\infty\\) to \\(\\infty\\) (the range of our search) they map to our model parameters on a range from \\(0\\) to \\(\\infty\\) (the range that is biologically meaningful)."
  },
  {
    "objectID": "r-session-03.html#optimization",
    "href": "r-session-03.html#optimization",
    "title": "\n9  R Session 03\n",
    "section": "\n9.9 Optimization",
    "text": "9.9 Optimization\nOur final step is to use the function optim to find the values of \\(\\beta\\), \\(S_0\\), and \\(I_0\\) that minimize the sum of squared errors as calculated using our function.\nFinally, we plot these fits against the data.\n\nCode# Initial guess\nsse_optim_params &lt;- c(beta = log(0.05), S_init = log(5000), I_init = log(1))\n\n# Create a dataframe of optimized parameters\nniamey_optims &lt;- niamey_df %&gt;%\n    # Create a nested dataframe i.e. one row for each site, and the data column\n    # now is a list column that contains a separate dataframe of times and\n    # cases for each site\n    nest(data = -site) %&gt;%\n    mutate(\n        # Map the optim() function call to each of the separate dataframes\n        # stored in the nested data column we just created\n        fit = map(data, ~optim(sse_optim_params, sse_sir, data = .x)),\n        # Map the exp() function to each of the model fits just created, and\n        # output to a dataframe instead of a list (like in map()), for easier\n        # use in the plottinge predictions later\n        map_dfr(fit, ~exp(.x$par))\n    )\n\n\n\nCodeniamey_optims %&gt;%\n    select(-c(data, fit)) %&gt;%\n    mutate(site = str_replace_all(site, \"_\", \" \")) %&gt;%\n    gt() %&gt;%\n    fmt_number(columns = -site, decimals = 3) %&gt;%\n    fmt_scientific(columns = beta) %&gt;%\n    # Relabel the column headers\n    cols_label(\n        site = md(\"**Site**\"), \n        beta = md(\"**Beta**\"),\n        S_init = md(\"**Initial S**\"),\n        I_init = md(\"**Initial I**\")\n    ) %&gt;%\n    # Apply style to the table with gray alternating rows\n    opt_stylize(style = 1, color = 'gray') %&gt;%\n    # Increate space between columns\n    opt_horizontal_padding(scale = 3) %&gt;%\n    cols_align(\"center\")\n\n\n\n\n\n\nSite\n      Beta\n      Initial S\n      Initial I\n    \n\n\nSite 1\n5.89 × 10−3\n\n8,165.425\n2.151\n\n\nSite 2\n9.36 × 10−3\n\n5,649.151\n0.248\n\n\nSite 3\n7.65 × 10−2\n\n784.189\n0.001\n\n\n\n\n\n\n\nCodeniamey_predictions &lt;- niamey_optims %&gt;%\n    mutate(\n        # For each of the different site's nested dataframes, fit the SIR model\n        # with the optimal parameters to get best fit predictions\n        predictions = pmap(\n            .l = list(\n                S_init = S_init,\n                I_init = I_init,\n                beta = beta,\n                time_data = data\n            ),\n            .f = function(S_init, I_init, beta, time_data)  {\n                site_times &lt;- time_data$biweek * 14 / 365\n\n                # Return a dataframe of model solutions\n                as_tibble(ode(\n                    y = c(S = S_init, I = I_init),\n                    times = site_times,\n                    func = closed_sir_model,\n                    parms = beta,\n                    hmax = 1/120\n                )) %&gt;%\n                # Make sure all values are numeric for plotting purposes\n                mutate(across(everything(), as.numeric))\n            }\n            )\n    ) %&gt;%\n    unnest(c(data, predictions))\n\n\n\nCode# Create a dataframe to store the positions of the text labels\nniamey_preds_labels &lt;- tibble(\n    site = c(\"Site_3\", \"Site_2\"),\n    x_label = c(7, 6.5),\n    x_arrow_just = c(-0.5, -0.5),\n    x_arrow_end = c(8.8, 7.75),\n    y_label = c(120, 600),\n    y_arrow_just = c(-15, -70),\n    y_arrow_end = c(29, 290),\n    commentary = c(\"**Observed\", \"**Predicted\"),\n    color = c(\"grey20\", niamey_site_colors[\"Site_2\"])\n)\n\nggplot(niamey_predictions, aes(x = biweek, group = site)) +\n    # Plot the actual data in color\n    geom_line(aes(y = cases, color = site)) +\n    geom_point(aes(y = cases, color = site), size = 4, alpha = 0.8) +\n    # Plot the best-fit model predictions in black\n    geom_line(aes(y = I), color = \"black\") +\n    scale_color_manual(\n        values = niamey_site_colors, aesthetics = c(\"color\", \"fill\")\n    ) +\n    # Place each site on it's own subplot and change labels\n    facet_wrap(\n        ~site, ncol = 1, scales = \"free_y\",\n        labeller = as_labeller(niamey_site_labels)\n    ) +\n    labs(x = \"Biweek\", y = \"Number of Case\") +\n    theme(legend.position = \"none\") +\n    ggtext::geom_textbox(\n        data = niamey_preds_labels,\n        aes(\n            label = paste0(\n                \"&lt;span style = \\\"color:\",\n                color,\n                \"\\\"&gt;\",\n                commentary,\n                \" Cases**\",\n                \"&lt;/span&gt;\"\n            ),\n            x = x_label, y = y_label\n        ),\n        size = 4, fill = NA, box.colour = NA\n    ) +\n    geom_curve(\n        data = niamey_preds_labels,\n        aes(\n            x = x_label + x_arrow_just, xend = x_arrow_end,\n            y = y_label + y_arrow_just, yend = y_arrow_end\n        ),\n        linewidth = 0.75,\n        arrow = arrow(length = unit(0.2, \"cm\")),\n        curvature = list(0.25),\n        color = \"grey20\"\n    )\n\n\n\n\n\n9.9.1 Exercise 5\nTo make things easier, we have assumed the infectious period is known to be 14 days. In terms of years, \\(\\text{D} = \\frac{14}{365} \\approx 0.0384\\), and the recovery rate is the inverse i.e., \\(\\gamma = \\frac{14}{365}\\). Now, modify the code above to estimate \\(\\gamma\\) and \\(\\beta\\) simultaneously.\n\n9.9.2 Exercise 6\nWhat happens if one or both of the other unknowns (\\(S_0\\) and \\(I_0\\)) is fixed instead of \\(\\gamma\\)?\n\n\n\n\n\n\nGrais, R. F., M. J. Ferrari, C. Dubray, O. N. Bjørnstad, B. T. Grenfell, A. Djibo, F. Fermon, and P. J. Guerin. 2006. “Estimating Transmission Intensity for a Measles Epidemic in Niamey, Niger: Lessons for Intervention.” Transactions of The Royal Society of Tropical Medicine and Hygiene 100 (9): 867–73. https://doi.org/10.1016/j.trstmh.2005.10.014.\n\n\nKeeling, Matthew James, and Pejman Rohani. 2008. “Introduction to Simple Epidemic Models.” In Modeling Infectious Diseases in Humans and Animals, 21–22. Princeton: Princeton University Press."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Bjørnstad, Ottar N. 2018. “Advanced: The Next-Generation\nMatrix.” In Epidemics: Models and\nData Using R, 51. Use R!\nCham: Springer International Publishing. https://doi.org/10.1007/978-3-319-97487-3.\n\n\nDiekmann, O., and J. A. P. Heesterbeek. 2000. Mathematical\nEpidemiology of Infectious Diseases: Model Building,\nAnalysis and Interpretation. Wiley Series in Mathematical &\nComputational Biology. Wiley. https://books.google.ca/books?id=5VjSaAf35pMC.\n\n\nGrais, R. F., M. J. Ferrari, C. Dubray, O. N. Bjørnstad, B. T. Grenfell,\nA. Djibo, F. Fermon, and P. J. Guerin. 2006. “Estimating\nTransmission Intensity for a Measles Epidemic in Niamey,\nNiger: Lessons for Intervention.” Transactions\nof The Royal Society of Tropical Medicine and Hygiene 100 (9):\n867–73. https://doi.org/10.1016/j.trstmh.2005.10.014.\n\n\nHeesterbeek, J. A. P. 2002. “A Brief History of\nR0 and a Recipe for Its\nCalculation.” Acta Biotheoretica 50 (3):\n189–204. https://doi.org/10.1023/A:1016599411804.\n\n\nHeffernan, J. M, R. J Smith, and L. M Wahl. 2005. “Perspectives on\nthe Basic Reproductive Ratio.” J R Soc Interface 2 (4):\n281–93. https://doi.org/10.1098/rsif.2005.0042.\n\n\nHurford, Amy, Daniel Cownden, and Troy Day. 2009. “Next-Generation\nTools for Evolutionary Invasion Analyses.” Journal of The\nRoyal Society Interface 7 (45): 561–71. https://doi.org/10.1098/rsif.2009.0448.\n\n\nKeeling, Matthew James, and Pejman Rohani. 2008. “Introduction to\nSimple Epidemic Models.” In Modeling Infectious Diseases in\nHumans and Animals, 21–22. Princeton: Princeton\nUniversity Press.\n\n\nKing, Aaron A, and Helen J Wearing. 2011. “Age Structured\nModels.” In. https://ms.mcmaster.ca/~bolker/eeid/2011_eco/waifw.pdf.\n\n\nMossong, Joël, Niel Hens, Mark Jit, Philippe Beutels, Kari Auranen,\nRafael Mikolajczyk, Marco Massari, et al. 2008. “Social\nContacts and Mixing Patterns Relevant to the\nSpread of Infectious Diseases.”\nPLOS Medicine 5 (3): e74. https://doi.org/10.1371/journal.pmed.0050074."
  },
  {
    "objectID": "index.html#tips-about-the-website",
    "href": "index.html#tips-about-the-website",
    "title": "SISMID Module 2 Materials (2023)",
    "section": "Tips About the Website",
    "text": "Tips About the Website\nThere are a number of useful features throughout this website to help you.\nFirstly, in sections where there is R code showing, clicking on the text ▶ Code above the code block will hide the code if open (the default), or show the code if hidden.\nSecondly, in the top right corner of each code block, there is a button that looks like a clipboard. Clicking this button will copy the code to your clipboard, so you can paste it into your own R session.\nFinally, within the code blocks (and, in fact, in the regular text like this section), functions (e.g. list(), pivot_longer()) that come from a package (i.e., ones we didn’t write) show up in a different color. In most cases, you can hover your cursor over them (on the part next the the parentheses e.g., ode() from the line deSolve::ode()), and if they become underlined, you can click on them to go to the documentation for that function. This is like searching for the documentation from your R console using ?ode."
  },
  {
    "objectID": "project-management.html#other-resources",
    "href": "project-management.html#other-resources",
    "title": "Setting Up A Project",
    "section": "Other Resources",
    "text": "Other Resources\n\nGit\nGit is an essential component of reproducible computation research, although it is very much out of the scope of this workshop. Think of it as a more powerful version of tracked changes for your code, merged with some of the collaborative abilities of Google Docs. If you would like to learn more about what it is, and how you could add it to your workflow, Callum created a small online book to accompany a Git and GitHub workshop he developed for Penn State. The link can be found here, and this will be continuously updated to add more complicated workflows and troubleshooting tips.\nJenny Bryan and co put togther a fantastic resource about using Git with R here. It has more of a focus on R and the use of R-specific tools and packages to help with Git (e.g. the {usethis} package), but is still plenty general for anyone to learn about Git and best practices."
  },
  {
    "objectID": "project-management.html#project-structure",
    "href": "project-management.html#project-structure",
    "title": "Setting Up A Project",
    "section": "Project Structure",
    "text": "Project Structure\nThere are many ways to structure a project, but we would recommend that each project has its own folder (directory), and all your project directories sit in a single place. For example, you could have a directory called Repos that holds all of your projects. That way, when you want to find a specific project, it’s easy and in one place.\n\n\n\n\n\n\nImportant\n\n\n\nIt is crucial that this folder does not live in a cloud-synced folder e.g., in OneDrive. Cloud accounts have an unfortunate habit of creating sync errors and often rename files to circumvent issues with merging differing copies. This will ruin any chance you have of using Git in the future, which is highly recommended, as Git relies on the file names being the same.\n\n\nA suggested layout could look like this (where ${HOME} denotes your home directory, i.e., ~/ on MacOS/Linux, and C:/ on Windows):\n${HOME}/\n└── Documents/\n    └── Repos/\n        └── Proj/\n            ├── data/\n            ├── figs/\n            ├── funs/\n            ├── out/\n            └── src/\n                ├── cleaning.R\n                └── analysis.R\n\ndata/\nAn important idea is that you should treat your data as read-only. You and your team have likely worked hard to collect the data and it’s easy to make a changes along the way that you either forget about, or need to reverse. As most projects span a long time between the data collection and analysis stages, it can be very difficult and time-consuming to try and reverse engineer exactly what changes have been made if the data files are directly edited. Therefore, to save yourself effort and help make your work reproducible, once the data is collected it should not be edited; all the work should happen in your code, allowing it to be easily checked.\n\n\n\n\n\n\nTip\n\n\n\nWhen you are reading in data files in your cleaning and analysis scripts, it is good practice to use relative paths. This means that if you share your code with others, everything should still work for them. If you use explicit paths e.g. read_csv(\"/Users/callumarnold/Documents/Repos/SISMID_2023/data/niamey.csv\") then this won’t work for your collaborators, as they don’t have the same computer set up as you!\nA package we recommend using in R is the {here} package, which would turn the above code into read_csv(here::here(\"data\", \"niamey.csv\")). Not only is this easier to read, but it leverages the principle that our projects are self-contained in their own folders and uses file paths that are relative to the root of the project, so it works regardless of where people install the project folder to.\n\n\n\n\nsrc/\nIt is common practice to keep your scripts (source code) in a folder named src/. Following this practice will make it easier for others to navigate your code, helping create a reproducible work environment. The files in here may be scripts to clean the data (remember, we are treating data as read-only), and others to produce the analysis. In our workshop, it would be a good idea to have a different file for each exercise e.g., r-session-01.R\n\n\nOther subdirectories\n\nfuns/: this contains the functions you write and might want to reference. The idea is to create functions so that can give code a meaningful name. It also helps if you need to repeat a code chunk multiple times, especially if you need to edit it at some point, as you can just call the function rather than typing it out each time.\nout/: this contains files that are produced from the original data e.g. cleaned data files. You can then call them in your analysis scripts.\nfigs/: this contains figures that may be generated from your scripts."
  },
  {
    "objectID": "project-management.html#project-structure-1",
    "href": "project-management.html#project-structure-1",
    "title": "Setting Up A Project",
    "section": "Project Structure",
    "text": "Project Structure\n\nCallum wrote a short blog post about reproducible work that can be found here. The section about Jupyter notebooks are unlikely to be relevant to R users, but the rest is still useful."
  },
  {
    "objectID": "project-management.html#naming-files",
    "href": "project-management.html#naming-files",
    "title": "Setting Up A Project",
    "section": "Naming Files",
    "text": "Naming Files\nPart of structuring a project is having creating file names that are easy to read; both for you and the computer. On that note, get rid of any spaces in your file and folder names! They make it much trickier to work with when you want to use them in code, whether that’s using bash/zsh for moving files quickly or using Git via the command line, or loading them in analysis scripts.\nJenny Bryan (of University of British Columbia and RStudio/Posit) has great slides here on the topic, but in summary:\n\nKISS (Keep It Simple Stupid): use simple and consistent file names\n\nIt needs to be machine readable\nIt needs to be human readable\nIt needs to order well in a directory (e.g., left-pad numbers)\n\nNo special characters and no spaces!\nUse YYYY-MM-DD date format\n\nFile systems will automatically order them sensibly\nUnambiguous, which is particularly important with international collaborators\n\nUse - to delimit words and _ to delimit sections\n\ni.e. 2019-01-19_my-data.csv\n\nLeft-pad numbers\n\ni.e. 01_my-data.csv vs 1_my-data.csv\nIf you don’t, file orders get messed up when you get to double-digits"
  }
]