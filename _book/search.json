[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "SISMID Module 2 Materials (2023)",
    "section": "",
    "text": "Welcome"
  },
  {
    "objectID": "r-session-01.html#sec-interactive-plots",
    "href": "r-session-01.html#sec-interactive-plots",
    "title": "\n3  R Session 01\n",
    "section": "\n3.1 Interactive Plot",
    "text": "3.1 Interactive Plot\n\n\nCodeviewof beta = Inputs.range(\n  [0.0, 2.0],\n  {value: 0.3, step: 0.01, label: \"Transmission rate (per day)\"}\n)\n\nviewof dur_inf = Inputs.range(\n  [0.0, 20],\n  {value: 6.0, step: 0.5, label: \"Duration of Infection (days)\"}\n)\n\nviewof I0 = Inputs.range(\n  [0.0, 1.0],\n  {value: 0.01, step: 0.01, label: \"Initial fraction infected\"}\n)\n\nviewof births = Inputs.range(\n  [0, 0.05],\n  {value: 0, step: 0.001, label: \"Birth rate\"}\n)\n\nviewof tmax = Inputs.range(\n  [200, 600],\n  {value: 1.0, step: 10.0, label: \"Maximum simulation time (years)\"}\n)\n\nviewof area = Inputs.toggle(\n  {label: \"Cumulative Area plot\", value: false}\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodegamma = 1 / dur_inf\ndt = 0.01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodeimport {odeRK4} from '@rreusser/integration@3064'\nimport { aq, op } from '@uwdata/arquero'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodefunction sir(dydt, y, t) {\n  dydt[0] = - beta * y[0] * y[1] + births * (1 - y[0])\n  dydt[1] = beta * y[0] * y[1] - gamma * y[1] - births * y[1]\n  dydt[2] = gamma * y[1] - births * y[2]\n}\n\n\n\n\n\n\n\nCodefunction simulate(f, t0, y0, dt, tmax) {\n  var t = t0\n  var y = y0\n  var i = 0\n\n  var tsim = [t0]\n  var ysim = [y0]\n\n  for (t = t0 + dt; t &lt;= tmax; t += dt) {\n    ysim.push(odeRK4([], ysim[i], f, dt))\n    tsim.push(t)\n    i += 1\n  }\n  \n  return aq.table({\n    Time: tsim,\n    S: ysim.map(d =&gt; d[0]),\n    I: ysim.map(d =&gt; d[1]),\n    R: ysim.map(d =&gt; d[2])\n    })\n}\n\n\n\n\n\n\n\nCodesir_sol = simulate(sir, 0, [1.0-I0, I0, 0.0], dt, tmax)\nsir_sol_long = sir_sol.fold(aq.not('Time'), {as: ['State', 'Fraction']})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodeSIRcolors = [\"#1f77b4\", \"#ff7f0e\", \"#FF3851\"]\n\n\n\n\n\n\n\nCodeR0 = beta / (gamma + births)\nR0_str = R0.toLocaleString(undefined, {minimumFractionDigits: 2})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodefunction calculate_equil(R0){\n  if (births &gt; 0) {\n    var eq_S = 1 / R0\n    var eq_I = births / beta * (R0 - 1)\n    var eq_R = 1 - (eq_S + eq_I)\n\n    const eq_vals = aq.table({\n      State: [\"S\", \"I\", \"R\"],\n      Fraction: [eq_S, eq_I, eq_R]\n    })\n\n    return eq_vals\n  } else {\n    return null\n  }\n}\n\n\n\n\n\n\n\nCodeeq_vals = calculate_equil(R0)\n\n\n\n\n\n\n\nCodePlot.plot({\n  color: {\n    legend: true,\n    domain: [\"S\", \"I\", \"R\"],\n    range: SIRcolors\n  },\n  style: {fontSize: \"20px\"},\n  marginLeft: 65,\n  marginTop: 40,\n  marginBottom: 55,\n  grid: true,\n  width: 1000,\n  height: 800,\n  y: {domain: [0, 1]},\n  marks: [\n    area ?\n      Plot.areaY(sir_sol_long, {x: \"Time\", y: \"Fraction\", fill: \"State\"}) :\n      [\n        R0 &gt;= 1.0 && births &gt; 0 ?\n        Plot.ruleY(\n          eq_vals,\n          {y: \"Fraction\", stroke: \"State\", strokeWidth: 2, strokeDasharray: [10]}\n        ) :\n        null,\n        Plot.lineY(\n          sir_sol_long,\n          {x: \"Time\", y: \"Fraction\", stroke: \"State\", strokeWidth: 6}\n        )\n      ]\n  ]\n})\n\n\n\n\n\n\n\nCodemd`${tex`R_0 = ${R0_str}`}`\n\n\n\n\n\n\n\nCode{\n  if (births == 0){\n    var finalsize = sir_sol.get(\"R\", sir_sol.numRows()-1)\n    var finalsize_str = finalsize.toLocaleString(undefined, {minimumFractionDigits: 2})\n\n    return md`${tex`\\text{Final size} = ${finalsize_str}`}`\n  } else {\n    return md``\n  }\n}"
  },
  {
    "objectID": "r-session-01.html#closed-population-model-intuition",
    "href": "r-session-01.html#closed-population-model-intuition",
    "title": "\n3  R Session 01\n",
    "section": "\n3.2 Closed Population Model Intuition",
    "text": "3.2 Closed Population Model Intuition\n\n\n\n\n\n\nSET\n\n\n\nTransmission rate = 1\nDuration of infection = 4.\n\n\n\n3.2.1 What is \\(R_0\\)?\n\n3.2.2 What is epidemic final size?\n\n3.2.3 Does this make sense given our definition of \\(R_0\\)?\n\n\n\n\n\n\nToggle on the cumulative area button and see what the epidemic final size is (approximately)\n\n\n\n\n3.2.4 At approximately what time does the epidemic end?\n\n\n\n\n\n\nSET\n\n\n\nDuration of infection = 8 days\nTransmission rate so you get the same \\(R_0\\) in Section 3.2.1\n\n\n\n3.2.5 How does the epidemic final size compare?\n\n3.2.6 At what time (approx) does the epidemic end?\n\n\n\n\n\n\nNote\n\n\n\nSize is determined by \\(R_0\\), duration is determined by recovery rate \\(\\left(\\gamma = \\frac{1}{\\text{duration of infection}}\\right)\\)\n\n\nNow, imagine that we have a drug (or vaccine) available to everyone that either reduced transmission OR shortened the duration of infection.\n\n\n\n\n\n\nSET\n\n\n\nTransmission rate = 1\nDuration of infection = 8 days\n\n\n\n3.2.7 Note the epidemic final size and the time until the epidemic is over.\n\n\n\n\n\n\nNow, imagine everyone has access to the drug (unrealistic) that reduces transmission by \\(P \\%\\)\n\n\n\n\n3.2.8 What happens to the final size and outbreak duration?\nNow, imagine everyone has access to a drug that reduces the duration of infection from 8 to 2 days (75% reduction).\n\n3.2.9 What happens to the final size and outbreak duration?\n\nWhich would you prefer and why? (This is the only really open ended question, but should be pretty straightforward discussion)"
  },
  {
    "objectID": "r-session-01.html#demographic-model-intuition",
    "href": "r-session-01.html#demographic-model-intuition",
    "title": "\n3  R Session 01\n",
    "section": "\n3.3 Demographic Model Intuition",
    "text": "3.3 Demographic Model Intuition\n\n\n\n\n\n\nSET\n\n\n\nTransmission = 1\nDuration = 8\nBirth rate = .002\n\n\n\n3.3.1 What is \\(R_0\\)?\n\n3.3.2 What is the equilibrium proportion that is susceptible?\n\n3.3.3 If you were to test for antibodies against infection in the population, what proportion would you expect to be positive?\n\n\n\n\n\n\nNote\n\n\n\nAssume a perfectly accurate serological test\n\n\n\n3.3.4 At what time (approximately) does the system reach equilibrium?\n\n\n\n\n\n\nSET\n\n\n\nBirth rate = 0.005\n\n\n\n3.3.5 What is the new \\(R_0\\)?\n\n3.3.6 At what time (approximately) does the system reach equilibrium?\n\n\n\n\n\n\nSET\n\n\n\nTransmission rate so you get the same \\(R_0\\) in Section 3.3.1\n\n\n\n3.3.7 What is the new equilibrium proportion that is susceptible?\n\n3.3.8 What is different about the prevalence of infection (equilibrium proportion that is infected) in the scenarios Section 3.3.1 and Section 3.3.5 i.e. higher birth rate with the same \\(R_0\\)?"
  },
  {
    "objectID": "r-session-01.html#model-building-with-r",
    "href": "r-session-01.html#model-building-with-r",
    "title": "\n3  R Session 01\n",
    "section": "\n3.4 Model Building With R",
    "text": "3.4 Model Building With R\n\n3.4.1 Setting Up A Script\nNow we have some intuition behind how the different parameters affect the dynamics of the SIR system, let’s look at how we can implement this in R. Below is some R code that implements the basic closed-population SIR model. The purpose of the questions in this exercise is to guide you through the code and help you understand how it works so you can modify it to answer your own questions.\n\n\n\n\n\n\n\nTip\n\n\n\nThere are a number of useful features throughout this website to help you.\nFirstly, clicking on the text Click to toggle the code does what it says on the tin - clicking the button will hide the code if open (the default), or show the code if hidden.\nSecondly, in the top right corner of each code block, there is a button that looks like a clipboard. Clicking this button will copy the code to your clipboard, so you can paste it into your own R session.\nFinally, within the code blocks (and, in fact, in the regular text like this section), functions (e.g. list(), pivot_longer()) that come from a package (i.e., ones we didn’t write) show up in a different color. In most cases, you can hover your cursor over them (on the part next the the parentheses e.g., ode() from the line deSolve::ode()), and if they become underlined, you can click on them to go to the documentation for that function. This is like searching for the documentation from your R console using ?ode.\n\n\n\nCodelibrary(tidyverse)\nlibrary(deSolve)\n\ntheme_set(theme_minimal())\n\nsir_model &lt;- function(time, state, params, ... ){\n  transmission &lt;- params[\"transmission\"]\n  recovery &lt;- 1 / params[\"duration\"]\n\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n\n  dSdt &lt;- -transmission * S * I\n  dIdt &lt;- (transmission * S * I) - (recovery * I)\n  dRdt &lt;- (recovery * I)\n\n  return(list(c(dSdt, dIdt, dRdt)))\n}\n\nsir_params &lt;- c(transmission = 0.3, duration = 6)\nsir_init_states &lt;- c(S = 0.99, I = 0.01, R = 0)\nsim_times &lt;- seq(0, 200, by = 0.1)\n\nsir_sol &lt;- deSolve::ode(\n  y = sir_init_states,\n  times = sim_times,\n  func = sir_model,\n  parms = sir_params\n)\n\n# Turn the output from the ODE solver into a tibble (dataframe)\n# so we can manipulate and plot it easily\nsir_sol_df &lt;- as_tibble(sir_sol) %&gt;%\n  # Convert all columns to numeric (they are currently type\n  # deSolve so will produce warnings when plotting etc)\n  mutate(\n    # Rather than repeatedly type the same function for every\n    # column, use the across() function to apply the function\n    # to a selection of columns\n    across(\n      # The cols argument takes a selection of columns to apply\n      # a function to. Here, we want to apply the as.numeric()\n      # function to all columns, so we use the function\n      # everything() to select all columns.\n      .cols = everything(),\n      .fns = as.numeric\n    )\n  ) %&gt;%\n  # Convert the dataframe from wide to long format, so we have a\n  # column for the time, a column for the state, and a column\n  # for the proportion of the population in that state at that\n  # time\n  pivot_longer(\n    # Don't pivot the time column\n    cols = -time,\n    names_to = \"state\",\n    values_to = \"proportion\"\n  ) %&gt;%\n  # Update the state column to be a factor, so the plot will\n  # show the states in the correct order\n  mutate(state = factor(state, levels = c(\"S\", \"I\", \"R\")))\n\nSIRcolors &lt;- c(S = \"#1f77b4\", I = \"#ff7f0e\", R = \"#FF3851\")\n\nggplot(sir_sol_df, aes(x = time, y = proportion, color = state)) +\n  geom_line(linewidth = 1.5) +\n  scale_color_manual(values = SIRcolors) +\n  labs(\n    x = \"Time\",\n    y = \"Fraction\",\n    color = \"State\"\n  ) +\n  theme(legend.position = \"top\")\n\n\n\n\n\n\n\n\n\n\nCopy the code above into a new R script. This script should live in your SISMID directory, as described previously. Run it to check you get the same figure output as above.\n\n\n\n\n3.4.2 Commenting the code\nFor this part of the exercise, go through the basic SIR code and add comments to each section of code explaining what it does. To get you started, we’ve added some comments to the creating of the dataframe object sir_sol_df at line 32 in the code block above, as some of the functions used there are a bit more complicated.\n\n\n\n\n\n\nNote\n\n\n\nNormally you would not use nearly as extensive comments. Here, I’ve gone overboard to help you understand what each line does, as some may not be familiar with all the functions used. I’ve also broken up the comments into multiple lines so that it is easier to read on this website. For your code that you view in RStudio (or some other text editor), use one line per sentence of the comment i.e., start a new comment line after each period.\nGenerally, you want to use comments to explain why you are doing something, not what you are doing. Sometimes that is unavoidable (e.g., you had to look up how to do a particular thing in R and need the hints to be able to understand the code), but try to stick to this guideline where possible.\n\n\nAs you’re going through the code, if you don’t understand what a particular function does, try looking up the documentation for it! You can do this by clicking on the function within the website (as described above), or by typing ?function_name into the R console (Google also is your friend here!).\n\n3.4.3 Adding in demographics\nNow we have a better sense of how the code works, let’s add in some demographic structure. To recreate the demographic model from the interactive plot in Section 3.1, we just need to add births and deaths to the system.\nRecall the equations for the demographic model:\n\\[\n\\begin{aligned}\n\\frac{dS}{dt} &= \\mu N - \\beta S I - \\mu S \\\\\n\\frac{dI}{dt} &= \\beta S I - \\gamma I - \\mu I \\\\\n\\frac{dR}{dt} &= \\gamma I - \\mu R\n\\end{aligned}\n\\tag{3.1}\\]\n\n3.4.3.1 Create a new R script called 01_demographic-sir.R and copy the code from S01_basic-sir.R into it.\n\n3.4.3.2 Rename the function sir_model() to demographic_sir_model() in your new script (S01_demographic-sir.R).\n\n3.4.3.3 Adapt the function demographic_sir_model() to match the above equations (Equation 3.1).\n::: {.callout-note title=“SET”} birth rate = 0.05 :::\n\n3.4.3.4 Rename the variables to reflect that we are now working with a demographic model, not the basic SIR model.\n\n3.4.3.5 Plot the results of your demographic model. Does it look like this?\n\n\n\n\n\n\n3.4.3.6 Update the comments in your code to reflect the changes you have made."
  },
  {
    "objectID": "r-session-01.html#appendix",
    "href": "r-session-01.html#appendix",
    "title": "\n3  R Session 01\n",
    "section": "\n3.5 Appendix",
    "text": "3.5 Appendix\n\n3.5.1 Commented basic SIR code\n\nCodelibrary(tidyverse)\nlibrary(deSolve)\n\ntheme_set(theme_minimal())\n\n\n#' Basic SIR model\n#'\n#' A basic SIR model with no demographic structure to be used in deSolve\n#'\n#' @param time deSolve passes the time parameter to the function.\n#' @param state A vector of states.\n#' @param params A vector of parameter values .\n#' @param ... Other arguments passed by deSolve.\n#'\n#' @return A deSolve matrix of states at each time step.\n#' @examples\n#' sir_params &lt;- c(transmission = 0.3, duration = 6)\n#' sir_init_states &lt;- c(S = 0.99, I = 0.01, R = 0)\n#' sim_times &lt;- seq(0, 200, by = 0.1)\n#' \n#' sir_sol &lt;- deSolve::ode(\n#'    y = sir_init_states,\n#'    times = sim_times,\n#'    func = sir_model,\n#'    parms = sir_params\n#' ))\nsir_model &lt;- function(time, state, params, ... ){\n  transmission &lt;- params[\"transmission\"]\n  recovery &lt;- 1 / params[\"duration\"]\n\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n\n  dSdt &lt;- -transmission * S * I\n  dIdt &lt;- (transmission * S * I) - (recovery * I)\n  dRdt &lt;- (recovery * I)\n\n  return(list(c(dSdt, dIdt, dRdt)))\n}\n\nsir_params &lt;- c(transmission = 0.3, duration = 6)\nsir_init_states &lt;- c(S = 0.99, I = 0.01, R = 0)\nsim_times &lt;- seq(0, 200, by = 0.1)\n\nsir_sol &lt;- deSolve::ode(\n  y = sir_init_states,\n  times = sim_times,\n  func = sir_model,\n  parms = sir_params\n)\n\nsir_sol_df &lt;- as_tibble(sir_sol) %&gt;%\n  mutate(\n    across(\n      everything(),\n      as.numeric\n    )\n  ) %&gt;%\n  pivot_longer(\n    cols = -time,\n    names_to = \"state\",\n    values_to = \"proportion\"\n  ) %&gt;%\n  mutate(state = factor(state, levels = c(\"S\", \"I\", \"R\")))\n\nSIRcolors &lt;- c(S = \"#1f77b4\", I = \"#ff7f0e\", R = \"#FF3851\")\n\nggplot(sir_sol_df, aes(x = time, y = proportion, color = state)) +\n  geom_line(linewidth = 1.5) +\n  scale_color_manual(values = SIRcolors) +\n  labs(\n    x = \"Time\",\n    y = \"Fraction\",\n    color = \"State\"\n  ) +\n  theme(legend.position = \"top\")\n\n\n\n3.5.2 Commented demographic SIR code\n\nCodelibrary(tidyverse)\nlibrary(deSolve)\n\ntheme_set(theme_minimal())\n\n#' Demographic SIR model\n#'\n#' An SIR model with births and deaths (constant pop) to be used in deSolve\n#'\n#' @param time deSolve passes the time parameter to the function.\n#' @param state A vector of states.\n#' @param params A vector of parameter values .\n#' @param ... Other arguments passed by deSolve.\n#'\n#' @return A deSolve matrix of states at each time step.\n#' @examples\n#' sir_params &lt;- c(transmission = 0.3, duration = 6, birth_rate = 0.05)\n#' sir_init_states &lt;- c(S = 0.99, I = 0.01, R = 0)\n#' sim_times &lt;- seq(0, 200, by = 0.1)\n#' \n#' sir_sol &lt;- deSolve::ode(\n#'    y = sir_init_states,\n#'    times = sim_times,\n#'    func = sir_demog_model,\n#'    parms = sir_params\n#' ))\nsir_demog_model &lt;- function(time, state, params, ... ){\n  transmission &lt;- params[\"transmission\"]\n  recovery &lt;- 1 / params[\"duration\"]\n  birth_rate &lt;- params[\"birth_rate\"]\n\n  S &lt;- state[\"S\"]\n  I &lt;- state[\"I\"]\n  R &lt;- state[\"R\"]\n\n  dSdt &lt;- -transmission * S * I + (birth_rate * (1 - S))\n  dIdt &lt;- (transmission * S * I) - (recovery * I) - (birth_rate * I)\n  dRdt &lt;- (recovery * I) - (birth_rate * R)\n\n  return(list(c(dSdt, dIdt, dRdt)))\n}\n\nsir_demog_params &lt;- c(transmission = 0.3, duration = 6, birth_rate = 0.05)\nsir_init_states &lt;- c(S = 0.99, I = 0.01, R = 0)\nsim_times &lt;- seq(0, 200, by = 0.1)\n\nsir_demog_sol &lt;- deSolve::ode(\n  y = sir_init_states,\n  times = sim_times,\n  func = sir_demog_model,\n  parms = sir_demog_params\n)\n\nsir_demog_sol_df &lt;- as_tibble(sir_demog_sol) %&gt;%\n  mutate(\n    across(\n      everything(),\n      as.numeric\n    )\n  ) %&gt;%\n  pivot_longer(\n    cols = -time,\n    names_to = \"state\",\n    values_to = \"proportion\"\n  ) %&gt;%\n  mutate(state = factor(state, levels = c(\"S\", \"I\", \"R\")))\n\nggplot(sir_demog_sol_df, aes(x = time, y = proportion, color = state)) +\n  geom_line(linewidth = 1.5) +\n  scale_color_manual(values = SIRcolors) +\n  labs(\n    x = \"Time\",\n    y = \"Fraction\",\n    color = \"State\"\n  ) +\n  theme(legend.position = \"top\")"
  },
  {
    "objectID": "r-session-02.html#a-model-with-2-classes",
    "href": "r-session-02.html#a-model-with-2-classes",
    "title": "\n7  R Session 02\n",
    "section": "\n7.1 A Model With 2 Classes",
    "text": "7.1 A Model With 2 Classes\nWe’ll start with the simplest mechanistic model of two classes we can think of, which has separate classes for two groups \\(a\\) and \\(b\\). These groups could represent different socioeconomic classes, for example.\n\n\n\n\n\nWhich can be written in equations as, \\[\n\\begin{aligned}\n    \\frac{dS_a}{dt} &= -\\lambda_a\\,S_a \\phantom{-\\gamma\\,I_b}\\\\\n    \\frac{dS_b}{dt} &= -\\lambda_b\\,S_b \\phantom{-\\gamma\\,I_b}\\\\\n    \\frac{dI_a}{dt} &= \\phantom{-}\\lambda_a\\,S_a -\\gamma\\,I_a\\\\\n    \\frac{dI_b}{dt} &= \\phantom{-}\\lambda_b\\,S_b-\\gamma\\,I_b\\\\\n    \\frac{dR_a}{dt} &= \\phantom{-\\lambda_a\\,S_b}+\\gamma\\,I_a\\\\\n    \\frac{dR_b}{dt} &= \\phantom{-\\lambda_a\\,S_b}+\\gamma\\,I_b\\\\\n  \\end{aligned}\n\\]\nThe \\(\\lambda\\)s denote the group-specific force of infections:\n\\[\n\\begin{aligned}\n        \\lambda_a &= \\beta_{aa}\\,I_a+\\beta_{ab}\\,I_b\\\\\n        \\lambda_b &= \\beta_{ba}\\,I_a+\\beta_{bb}\\,I_b\n\\end{aligned}\n\\]\nIn this model, each population can infect each other but the infection moves through the populations separately. Let’s simulate such a model. To make things concrete, we’ll assume that the transmission rates \\(\\beta\\) are greater within groups than between them.\n\nCodeba_params &lt;- c(0.005, 0.02, 10)\n\n\n\nCode# Here we set up the ODE model that matches the equations above\nba_model &lt;- function (t, x, p, ...) {     \n    s &lt;- x[c(\"Sb\",\"Sa\")]                  # susceptibles\n    i &lt;- x[c(\"Ib\",\"Ia\")]                  # infecteds\n    r &lt;- x[c(\"Rb\",\"Ra\")]                  # recovereds\n    n &lt;- s + i + r                        # total pop\n    \n    beta1 &lt;- p[1]\n    beta2 &lt;- p[2]\n    gamma &lt;- p[3]\n\n    lambda_b &lt;- (beta1 + beta2) * i[1] + beta1 * i[2]      # group B force of infection\n    lambda_a &lt;- beta1 * i[1] + (beta1 + beta2) * i[2]      # group A force of infection\n    \n    list(\n        c(                               # these are the rates from the 6 equations above\n            -lambda_b * s[1],\n            -lambda_a * s[2],\n            lambda_b * s[1] - gamma * i[1],\n            lambda_a * s[2] - gamma * i[2],\n            gamma * i[1],\n            gamma * i[2]\n        )\n    )\n}\n\n\n\nCode## initial conditions\nba_yinit &lt;- c(Sb = 2000, Sa = 1000, Ib = 1, Ia = 1, Rb = 0, Ra = 0) # set starting conditions\n\nsol_ba &lt;- deSolve::ode(                          # run the ode solver on the model above\n    y = ba_yinit,\n    times = seq(0, 2, by = 0.001),\n    func = ba_model,\n    parms = ba_params,\n)\n\n\n\nCode# this code will plot the resulting time series\nplot(sol_ba, mfcol = c(2, 3))\n\n\n\nCodedim(sol_ba)\n\n[1] 2001    7\n\nCodehead(sol_ba)\n\n      time       Sb        Sa       Ib       Ia         Rb         Ra\n[1,] 0.000 2000.000 1000.0000 1.000000 1.000000 0.00000000 0.00000000\n[2,] 0.001 1999.939  999.9696 1.051116 1.020278 0.01025390 0.01010097\n[3,] 0.002 1999.874  999.9385 1.104524 1.041124 0.02103022 0.02040752\n[4,] 0.003 1999.807  999.9065 1.160326 1.062560 0.03235235 0.03092542\n[5,] 0.004 1999.737  999.8737 1.218624 1.084606 0.04424501 0.04166074\n[6,] 0.005 1999.664  999.8401 1.279526 1.107283 0.05673359 0.05261966\n\nCodeplot(sol_ba, log = 'y', mfcol = c(2, 3))\n\n\n\n\n\nCodeplot(sol_ba, mfcol = c(2, 3))\n\n\n\nCodepar(mfcol = c(1,1))\n\n\nThe results of the above are plotted below:\n\nCode# plot the proportion of individuals in each state for the two groups\ntime &lt;- sol_ba[, 1]                         # time\ny &lt;- sol_ba[, -1]                           # all other variables\nn &lt;- apply(y, 1, sum)                     # population size\nprop &lt;- y / n                             # fractions\n\nsubsampled.prop &lt;- prop[seq(1, length(time), by = 10),]\nsubsampled.time &lt;- time[seq(1, length(time), by = 10)]\nbarplot(\n    t(subsampled.prop),\n    names.arg=subsampled.time,\n    xlab='time',main='Group structure',\n    space = 0,\n    col = c(\n        rgb(0.5, 1, 0.5),\n        rgb(0, 1, 0),\n        rgb(1, 0.5, 0.5),\n        rgb(1, 0, 0),\n        rgb(0.5, 0.5, 1),\n        rgb(0, 0, 1)\n    ),\n    legend = colnames(prop),\n    args.legend = list(bg = \"white\")\n)"
  },
  {
    "objectID": "r-session-02.html#a-model-with-2-age-classes",
    "href": "r-session-02.html#a-model-with-2-age-classes",
    "title": "\n7  R Session 02\n",
    "section": "\n7.2 A Model With 2 Age Classes",
    "text": "7.2 A Model With 2 Age Classes\nNote that age is a special kind of heterogeneity in an epidemic model because individuals necessarily move from one class (younger) to another class (older) in a directional fashion that is independent of the infection and recovery process.\n\n\n\nWe’ll start by introducing age into the model above. So now \\(a\\) becomes juveniles and \\(b\\) becomes adults. And, independent of the disease process, juveniles (of any category) age into adults. Additionally, new juveniles are added through births (always first susceptible) and old individuals are lost to death.\n\n\n\n\n\nWe can do this very simply using the same ingredients that go into the basic SIR model. In that model, the waiting times in the S and I classes are exponential. Let’s assume the same thing about the aging process. We’ll also add in births into the juvenile susceptible class and deaths from the adult classes.\n\\[\n  \\begin{aligned}\n    \\frac{dS_J}{dt} &= B -\\lambda_J\\,S_J \\phantom{- \\gamma\\,I_A} -\\alpha\\,S_J \\phantom{-\\mu\\,S_A}\\\\\n    \\frac{dS_A}{dt} &= \\phantom{B} - \\lambda_A\\,S_A \\phantom{- \\gamma\\,I_A} +\\alpha\\,S_J -\\mu\\,S_A\\\\\n    \\frac{dI_J}{dt} &= \\phantom{B} +\\lambda_J\\,S_J - \\gamma\\,I_J -\\alpha\\,I_J \\phantom{-\\mu\\,S_A}\\\\\n    \\frac{dI_A}{dt} &= \\phantom{B} +\\lambda_A\\,S_A - \\gamma\\,I_A + \\alpha\\,I_J - \\mu\\,I_A\\\\\n    \\frac{dR_J}{dt} &= \\phantom{B - \\lambda_J\\,S_A} + \\gamma\\,I_J - \\alpha\\,R_J \\phantom{- \\mu\\,S_A}\\\\\n    \\frac{dR_A}{dt} &= \\phantom{B - \\lambda_J\\,S_A} + \\gamma\\,I_A + \\alpha\\,R_J -\\mu\\,R_A\\\\\n  \\end{aligned}\n\\]\nNow, let’s simulate this model, under the same assumptions about transmission rates as above.\n\nCode# define the parameters\ndemog_params &lt;- c(0.002, 0.002, 10, 100, 20, 60)\n\n\n\nCodeja_demog_model &lt;- function (t, x, p, ...) {\n    s &lt;- x[c(\"Sj\",\"Sa\")]                  # susceptibles\n    i &lt;- x[c(\"Ij\",\"Ia\")]                  # infecteds\n    r &lt;- x[c(\"Rj\",\"Ra\")]                  # recovereds\n    n &lt;- s + i + r                        # total pop\n\n    beta1_demog &lt;- p[1]\n    beta2_demog &lt;- p[2]\n    demog_params[3] &lt;- p[3]\n    births_demog &lt;- p[4]\n    alpha &lt;- 1 / c(p[5], p[6]) # alpha = 1/da\n\n    lambda_j &lt;- (beta1_demog + beta2_demog) * i[1] +\n        beta1_demog * i[2]      # juv. force of infection \n    lambda_a &lt;- beta1_demog * i[1] +\n        (beta1_demog + beta2_demog) * i[2]      # adult. force of infection\n    \n    list(\n        c(\n            -lambda_j * s[1] -alpha[1] * s[1] + births_demog,\n            -lambda_a * s[2] + alpha[1] * s[1] - alpha[2] * s[2],\n            lambda_j * s[1] - demog_params[3] * i[1] - alpha[1] * i[1],\n            lambda_a * s[2] - demog_params[3] * i[2] + alpha[1] * i[1] - alpha[2] * i[2],demog_params[3] * i[1] - alpha[1] * r[1],\n            demog_params[3] * i[2] + alpha[1] * r[1] - alpha[2] * r[2]\n        )\n    )\n}\n\n\nNote that in this function, \\(\\mu=\\) alpha[2], i.e., death, is just like another age class.\n\nCode## initial conditions\ndemog_yinit &lt;- c(Sj = 2000, Sa = 3000, Ij = 0, Ia = 1, Rj = 0, Ra = 1000)\n\nsol_demog &lt;- deSolve::ode(\n    y = demog_yinit,\n    times = seq(0, 200, by = 0.1),\n    func = ja_demog_model,\n    parms = demog_params\n)\n\n\n\n7.2.1 Exercise 1: Use this code to plot the number of susceptible, infected, and recovered individuals over time.\n\nCodeplot(sol_demog, mfcol = c(2, 3))\n\n\n\nCodedim(sol_demog)\n\n[1] 2001    7\n\nCodehead(sol_demog)\n\n     time       Sj       Sa        Ij       Ia        Rj        Ra\n[1,]  0.0 2000.000 3000.000 0.0000000 1.000000 0.0000000 1000.0000\n[2,]  0.1 1999.378 3003.493 0.4177484 1.352520 0.2039670  999.4835\n[3,]  0.2 1998.175 3006.051 0.9535749 2.096184 0.8716958  999.5051\n[4,]  0.3 1996.047 3006.972 1.7614151 3.444930 2.1911836 1000.5532\n[5,]  0.4 1992.393 3005.091 3.0702863 5.782232 4.5364895 1003.4091\n[6,]  0.5 1986.189 2998.473 5.2419033 9.755376 8.5688796 1009.3604\n\nCodeplot(sol_demog, log = 'y', mfcol = c(2, 3))\n\n\n\n\n\nCodeplot(sol_demog, mfcol = c(2, 3))\n\n\n\nCodepar(mfcol = c(1, 1))\n\n\nNote that now that births are replenishing susceptibles infection persists. The results of the above are plotted here :\n\nCode#plot the relative proportion of individuals in each category\npar(mfrow = c(1, 2))\ntime &lt;- sol_demog[, 1]                         # time\ny &lt;- sol_demog[, -1]                           # all other variables\nn &lt;- apply(y, 1, sum)                     # population size\nprop &lt;- y / n                             # fractions\nsubsampled.prop &lt;- prop[seq(1, length(time), by = 10),]\nsubsampled.time &lt;- time[seq(1, length(time), by = 10)]\n\nbarplot(\n    t(subsampled.prop),\n    names.arg = subsampled.time,\n    xlab = 'time',\n    main = 'Age structure',\n    space = 0,\n    col = c(\n        rgb(0.5, 1, 0.5),\n        rgb(0, 1, 0),\n        rgb(1, 0.5, 0.5),\n        rgb(1, 0, 0),\n        rgb(0.5, 0.5, 1),\n        rgb(0, 0, 1)\n    ),\n    legend = colnames(prop),\n    args.legend = list(bg = \"white\"),\n    border = NA\n)\n\nequil &lt;- drop(tail(sol_demog, 1))[-1]\n\nn &lt;- equil[c(\"Sj\", \"Sa\")] +\n    equil[c(\"Ij\", \"Ia\")] +\n    equil[c(\"Rj\", \"Ra\")]\n\nseroprev &lt;- equil[c(\"Rj\", \"Ra\")] / n # get the proportion in the R class at equilibrium\nnames(seroprev) &lt;- c(\"J\", \"A\")                \n\n# plot the proportion of each age class \n# that has been previously infected (is in the R class) \n# and would thus be expected to have antibodies (i.e. seropositive)\nbarplot(height = seroprev, width = c(demog_params[5:6]), ylab = \"seroprevalence\")  \n\n\n\n\n\nCodepar(mfrow = c(1, 1))\n\n\nTo compute \\(R_0\\), we need to know the stable age distribution (the relative proportion in the juvenile and adult age classes) of the population, which we can find by solving for the disease-free equilibrium: \\(S_J^*=B/\\alpha\\) and \\(S_A^*=B/\\mu\\).\nWith the stable age distribution, we can calculate \\(R_0\\) by constructing the next generation matrix. Details on this method are described in the last section of this worksheet and are not required for completing the exercises in the worksheet. The code below outlines how the next generation matrix is constructed using the \\(\\alpha\\) (aging from juvenile to adult), \\(\\mu\\) death), \\(n\\) (total births), \\(\\gamma\\) (recovery), \\(da\\) (width of age groups in years), and \\(\\beta\\) (transmission) parameters.\n\nCode# this code can be re-run to set parameter values\nalpha &lt;- 1 / demog_params[5]\nmu &lt;- 1 / demog_params[6]\nn &lt;- demog_params[4] / c(alpha, mu)\n\nbeta_demog &lt;- matrix(c(\n    demog_params[1] + ba_params[2],\n    demog_params[1],\n    demog_params[1],\n    demog_params[1] + ba_params[2]\n    ),\n    nrow = 2,\n    ncol = 2\n)\n\n# this command craetes the next generation matrix\nngm &lt;- matrix(\n    c(\n        n[1] * beta_demog[1, 1] / (demog_params[3] + alpha) +\n            alpha / (demog_params[3] + mu) * n[1] * beta_demog[1, 2] / (demog_params[3] + mu),\n        n[2] *beta_demog[2, 1] / (demog_params[3] + alpha) +\n            alpha / (demog_params[3] + mu) * n[2] * beta_demog[2, 2] / (demog_params[3] + mu),\n        n[1] * beta_demog[1, 2] / (demog_params[3] + mu),\n        n[2] * beta_demog[2, 2] / (demog_params[3] + mu)\n    ),\n    nrow = 2,\n    ncol = 2\n)\n\n# this command outputs the R0 value\nmax(Re(eigen(ngm,only.values=T)$values))\n\n[1] 13.23485"
  },
  {
    "objectID": "r-session-02.html#getting-more-realistic-adding-more-age-classes",
    "href": "r-session-02.html#getting-more-realistic-adding-more-age-classes",
    "title": "\n7  R Session 02\n",
    "section": "\n7.3 Getting more realistic: adding more age classes",
    "text": "7.3 Getting more realistic: adding more age classes\nIn the models above, the aging process follows an exponential distribution, which means that whether an individual is 1~year old or 10 years old, the chance of them becoming an adult is the same! To improve on this, we can assume that the time a juvenile must wait before becoming an adult follows a gamma distribution. This is equivalent to saying that the waiting time is a sum of some number of exponential distributions. This suggests that we can achieve such a distribution by adding age classes to the model, so that becoming an adult means passing through some number of stages. We’ll use 30 age classes, and since they don’t have to be of equal duration, we’ll assume that they’re not. Specifically, we’ll have 20 1-yr age classes to take us up to adulthood and break adults into 10 age classes of 5~yr duration each. The last age class covers age 66-80.\nNow, when we had just two age classes, we could write out each of the equations easily enough, but now that we’re going to have 30, we’ll need to be more systematic. In particular, we’ll need to think of \\(\\beta\\) as a matrix of transmission rates. Let’s see how to define such a matrix in R. So that we don’t change too many things all at once, let’s keep the same contact structure as in the juvenile-adult model.\n\nCode# ages_params[1] &lt;- 0.02  #transmission rate\n# ages_params[2] &lt;- 0.01  #transmission rate\n# gamma_ages &lt;- 10\n# births_ages &lt;- 100\n\nages_params &lt;- c(0.02, 0.01, 10, 100)\n\nages &lt;- c(seq(1, 20, by = 1), seq(25, 65, by = 5), 80) # upper end of age classes\n\nda_ages &lt;- diff(c(0, ages))                  # widths of age classes\n\n# set up a matrix of contact rates between classes -- more contact within juveniles and adults than between\nbeta_ages &lt;- matrix(nrow = 30, ncol = 30)    \nbeta_ages[1:20, 1:20] &lt;- ages_params[1] # transmission rate for juveniles \nbeta_ages[21:30, 21:30] &lt;- ages_params[2] # transmission rate for adults\nbeta_ages[1:20, 21:30] &lt;- ages_params[2]/2 # lower transmission rate between juveniles and adults\nbeta_ages[21:30, 1:20] &lt;- ages_params[2]/2 # lower transmission rate between juveniles and adults\n\n#WAIFW stands for Who Aquires Infection From Whom\nfilled.contour(\n    ages, ages, beta_ages,\n    plot.title = title(\n        main = \"WAIFW matrix\",\n        xlab = \"age\",\n        ylab = \"age\"\n    )\n)\n\n\n\n\nWe’ll assume that, at the time of introduction, all children are susceptible, as are adults over 45, but that individuals aged 20–45 have seen the pathogen before and are immune. The vector yinit expresses these initial conditions.\n\nCodedemog_yinit_ages &lt;- c(\n    S = c(rep(100, 20), rep(0, 5), rep(200, 5)),\n    I = c(rep(0, 25), 1, rep(0, 4)),\n    R = c(rep(0, 20), rep(1000, 5), rep(0, 5))\n)\n\n\nNote that we’re starting out with 1 infected individual in the 26th age class.\nThe codes that follow will be a bit easier to follow if we introduce some indexes that will allow us to pick out certain bits of the yinit vector.\n\nCodesindex &lt;- 1:30\niindex &lt;- 31:60\nrindex &lt;- 61:90\njuvies &lt;- 1:20\nadults &lt;- 21:30\n\n\nNow, to capture the aging process, it’s convenient to define another matrix to hold the rates of movement between age classes.\n\nCodeaging &lt;- diag(-1 / da_ages)\n\naging[row(aging) - col(aging) == 1] &lt;- 1 / head(da_ages, -1)\n\n\nHave a look at the aging matrix, for example by doing:\n\nCode# move fast through the 1-year age classes - negatives are moves out, positives are moves in\naging[1:5,1:5] \n\n# don't age between these classes -- e.g. can't age from 1 to 6\naging[1:5,6:10] \n\n# move slowly between the wider age classes\naging[25:30,25:30] \n\n#plot the aging matrix\nfilled.contour(\n    ages, ages, aging,\n    plot.title = title(\n        main = \"Aging matrix\",\n        xlab = \"age\",\n        ylab = \"age\"\n    )\n)\n\n\n\n7.3.1 Exercise 2: What can you say about its structure? How are the different age groups in contact with each other?\nNow we can put the pieces together to write a simulator for the age-structured SIR dynamics.\n\nCodemultistage_params &lt;- list(\n    beta_ages = beta_ages,\n    gamma_ages = ages_params[3],\n    births_ages = ages_params[4],\n    aging = aging\n)\n\nja_multistage_model &lt;- function (t, x, p, ...) {\n    s &lt;- x[sindex]                  # susceptibles\n    i &lt;- x[iindex]                  # infecteds\n    r &lt;- x[rindex]                  # recovereds\n    \n    beta_mat &lt;- p[[\"beta_ages\"]]    # transmission rate\n\n    gamma_ages &lt;- p[[\"gamma_ages\"]]   # recovery rate\n    births_ages &lt;- p[[\"births_ages\"]] # birth rate\n    aging &lt;- p[[\"aging\"]]\n\n    lambda &lt;- beta_mat %*% i        # force of infection\n    \n    dsdt &lt;- -lambda * s + aging %*% s\n    didt &lt;- lambda * s + aging %*% i - gamma_ages * i\n    drdt &lt;- aging %*% r + gamma_ages * i \n    dsdt[1] &lt;- dsdt[1] + births_ages\n    \n    list(c(dsdt, didt, drdt))\n\n}\n\n\nWe can plug this into ode just as we did the simpler models to simulate an epidemic. We’ll then plot the epidemic curve.\n\nCodesol_ms &lt;- deSolve::ode(\n    y = demog_yinit_ages,\n    times = seq(0, 100, by = 0.1),\n    func = ja_multistage_model,\n    parms = multistage_params\n)\n\ntime_ms &lt;- sol_ms[, 1]\ninfects_ms &lt;- sol_ms[, 1 + iindex]\n\n\n\nCodeplot(time_ms, apply(infects_ms, 1, sum), type = 'l')\nlines(time_ms, apply(infects_ms[, juvies], 1, sum), col = 'red')\nlines(time_ms, apply(infects_ms[, adults], 1, sum), col = 'blue')\n\n\n\n\nLet’s mimic a situation where we have cross-sectional seroprevalence data (e.g. measures of antibodies that tell you someone is in the R class). In using such data, we’d typically assume that the system was at equilibrium.\n\n7.3.2 Exercise 3: What does the equilibrium age-specific seroprevalence look like in this example?\nUse the code below to display the age-specific seroprevalence (i.e., the seroprevalence for each age group at equilibrium)\n\nCodeequil_ms &lt;- drop(tail(sol_ms, 1))[-1]\nn_ms &lt;- equil_ms[sindex] + equil_ms[iindex] + equil_ms[rindex]\nseroprev_ms &lt;- equil_ms[rindex] / n_ms\nnames(seroprev_ms) &lt;- ages\nbarplot(height = seroprev_ms, width = da_ages)\n\n\nLet’s also compute \\(R_0\\). To do so, we’ll need the stable age distribution. We can get that by simulating an infection-free population, which we get by setting the initial I to all 0s:\n\nCodeyinit_sonly &lt;- c(\n    S=c(rep(250,30)),\n    I=c(rep(0,30)),\n    R=c(rep(0,30))\n)\n\nsol_sonly &lt;- deSolve::ode(\n    y = yinit_sonly,\n    times = seq(0, 300, by = 1),\n    func = ja_multistage_model,\n    parms = list(\n        beta_ages = beta_ages,\n        gamma_ages = ages_params[3],\n        births_ages = demog_params[3],\n        aging = aging\n    )\n)\n\ntime_sonly &lt;- sol_sonly[, 1]\npop &lt;- apply(sol_sonly[, -1], 1 , sum)\n\nplot(time_sonly, pop, type = 'l')\n\n\nAlternatively, we can get the stable age distribution by finding the population structure that balances the birth, aging, and death processes. At equilibrium, we have the matrix equation\n\\[\n\\begin{pmatrix}\n    -\\alpha_1 & 0 & 0 & \\cdots & 0\\\\\n    \\alpha_1 & -\\alpha_2 & 0 & \\cdots & 0\\\\\n    0 & \\alpha_2 & -\\alpha_3 & \\cdots & 0\\\\\n    \\vdots &  & \\ddots & \\ddots & \\vdots \\\\\n    0 & \\cdots & & \\alpha_{29} & -\\alpha_{30}\\\\\n  \\end{pmatrix} . \\begin{pmatrix}\n    n_1 \\\\ n_2 \\\\ n_3 \\\\ \\vdots \\\\ n_{30}\n  \\end{pmatrix} + \\begin{pmatrix}\n    B \\\\ 0 \\\\ 0 \\\\ \\vdots \\\\ 0\n  \\end{pmatrix}=\n  \\begin{pmatrix}\n    0 \\\\ 0 \\\\ 0 \\\\ \\vdots \\\\ 0\n  \\end{pmatrix}\n\\]\nTo solve this equation in R, we can do\n\nCode## get stable age distribution\nn &lt;- solve(\n    aging,\n    -c(multistage_params[[\"births_ages\"]], rep(0, 29))\n)\n\n\nThe following lines then compute \\(R_0\\) using the next generation matrix method. More details are available in the “Bonus” section at the end of the document. This calculation comes from a recipe described in detail by Diekmann & Heesterbeek, 2000 and Hurford et. al, 2010.\n\nCodeF &lt;- diag(n) %*% multistage_params[[\"beta_ages\"]] +\n    multistage_params[[\"aging\"]] -\n    diag(diag(multistage_params[[\"aging\"]]))\n\nV &lt;- diag(multistage_params[[\"gamma_ages\"]] - diag(multistage_params[[\"aging\"]]))\n\nmax(\n    Re(\n        eigen(solve(V, F), only.values = TRUE)$values\n    )\n)\n\n[1] 6.792003\n\n\n\n7.3.3 Exercise 4:\n\n7.3.3.1 a. Change the juvenile and adult contact rates (ages_params[1] and ages_params[2]) to reflect different transmission within groups. Make the juvenile contact rate 0.02 to reflect higher contact among kids (e.g. in schools).\n\n7.3.3.2 b. Use image or filled.contour to plot the \\(\\beta\\) matrix.\n\n7.3.3.3 c. Compute \\(R_0\\) for your assumptions.\n\n7.3.3.4 d. Simulate and plot the age-structured SIR dynamics under your assumptions and record how the age-specific seroprevalence has changed.\n\nCodesol_r &lt;- deSolve::ode(\n    y = demog_yinit_ages,\n    times = seq(0,400,by=0.1),\n    func = ja_multistage_model,\n    parms = multistage_params\n)\n\n\n\nCodeplot(sol_r[, 1], apply(sol_r[, 1 + iindex], 1, sum), type = 'l')\nlines(sol_r[, 1], apply(sol_r[, 1 + iindex[juvies]], 1, sum), col = 'red')\nlines(sol_r[, 1], apply(sol_r[, 1 + iindex[adults]], 1, sum), col = 'blue')\n\n\n\n\n\nCodeequil_r &lt;- drop(tail(sol_r, 1))[-1]\nn_r &lt;- equil_r[sindex] + equil_r[iindex] + equil_r[rindex]\nseroprev_r &lt;- equil_r[rindex] / n_r\nnames(seroprev_r) &lt;- ages\nbarplot(height = seroprev_r, width = da_ages)\n\n\n\n\n\nCodeF &lt;- diag(n) %*% multistage_params[[\"beta_ages\"]] +\n    multistage_params[[\"aging\"]] -\n    diag(diag(multistage_params[[\"aging\"]]))\n\nV &lt;- diag(multistage_params[[\"gamma_ages\"]] - diag(multistage_params[[\"aging\"]]))\n\nmax(\n    Re(\n        eigen(solve(V, F), only.values = TRUE)$values\n    )\n)\n\n[1] 6.792003\n\nCode# R0 = 6.53\ninfects_r &lt;- sol_r[dim(sol_r)[1],1+iindex]\nsum(ages * infects_r/sum(infects_r))\n\n[1] 6.546368\n\nCodesum(infects_r[15:23])\n\n[1] 0.6939407"
  },
  {
    "objectID": "r-session-02.html#r0-and-the-mean-age-of-infection",
    "href": "r-session-02.html#r0-and-the-mean-age-of-infection",
    "title": "\n7  R Session 02\n",
    "section": "\n7.4 R0 and the mean age of infection",
    "text": "7.4 R0 and the mean age of infection\nFor simplicity, let’s return to the earlier models with a simple age-class mixing matrix. But this time, we’ll calculate \\(R_0\\), the mean age of infection, and the number of cases between 15-35 years as we increase the rate of contact. Recall from the rubella and CRS example that the risk of severe disease outcomes depends on the risk of infection in reproductive age women. Recall also that increasing vaccination reduces \\(R_E\\) – so here we’ll evalate at several values of \\(R_0\\) as a proxy for the impact of vaccination. We’ll then calculate how the mean age of infection changes, and specifically how the absolute number of cases among individuals between the ages of 15-35 (as a proxy for reproductive age women) changes. To do so, we’ll make a loop and evaluate the code for each of 10 increasing levels of mixing (which whill change R0)\n\nCode # a vector of scaling factors, we'll reduce the contact rate \n # from the original code by each of the values in this vector\nscale &lt;- seq(0.2, 1, length = 10) \nR0 &lt;- numeric() # somewhere to store results for the mean age\nmean_age &lt;- numeric() # somewhere to store results for the mean age\nsum_cases &lt;- numeric() # somewhere to store results for the mean age\n\n# this loop will run for as many different levels of contact that we specify \n# for the scale variable \n# this is the same code as above, but now we've included a multiplier for the \n# contact matrix\nfor(ii in 1:length(scale)){ \n    beta1 &lt;- 0.007\n    beta2 &lt;- 0.02\n    b3 &lt;- 0.03\n    beta &lt;- matrix(data = beta1, nrow = 30, ncol = 30)\n    beta[1:20,1:20] &lt;- beta2\n    beta[6:16,6:16] &lt;- b3\n    beta_ages &lt;- beta * scale[ii]\n    #filled.contour(beta)\n\n    params &lt;- list(\n        beta_ages = beta_ages,\n        gamma_ages = ages_params[3],\n        aging = aging,\n        births_ages = demog_params[4]\n    )\n\n    sol_R0 &lt;- deSolve::ode(\n        y = demog_yinit_ages,\n        times = seq(0, 400, by = 0.1),\n        func = ja_multistage_model,\n        parms = params\n    )\n\n    equil_R0 &lt;- drop(tail(sol_R0, 1))[-1]\n    n_R0 &lt;- equil_R0[sindex] + equil_R0[iindex] + equil_R0[rindex]\n    seroprev_R0 &lt;- equil_R0[rindex] / n_R0\n    names(seroprev_R0) &lt;- ages\n    # barplot(height=seroprev,width=da)\n\n    ## get stable age distribution\n    n_R0 &lt;- solve(\n        params[[\"aging\"]],\n        -c(params[[\"births_ages\"]], rep(0, 29))\n    )\n    ## get R0\n    F_R0 &lt;- diag(n_R0) %*% params[[\"beta_ages\"]] +\n        params[[\"aging\"]] -\n        diag(diag(params[[\"aging\"]]))\n\n    V_R0 &lt;- diag(params[[\"gamma_ages\"]] -\n        diag(params[[\"aging\"]]))\n\n    R0[ii] &lt;- max(\n        Re(\n            eigen(solve(V_R0, F_R0), only.values = TRUE)$values\n        )\n    )\n    # R0 = 6.53\n    infects_R0 &lt;- sol_R0[dim(sol_R0)[1],1+iindex]\n    mean_age[ii] &lt;- sum(ages * infects_R0 / sum(infects_R0))\n    sum_cases[ii] &lt;- sum(infects_R0[15:23])\n}\n\n\nNow we can make a table of the results and plot mean age and the sum of cases between 15-35 years of age as a function of \\(R_0\\).\n\nCodedf &lt;- data.frame(R0 = R0, \"mean age\" = mean_age, \"cases (15-35y)\" = sum_cases)\n\nknitr::kable(df)\n\n\n\nR0\nmean.age\ncases..15.35y.\n\n\n\n1.349005\n29.720681\n1.4792882\n\n\n1.923933\n21.497318\n2.1148202\n\n\n2.499068\n16.404292\n2.0147559\n\n\n3.074291\n13.105915\n1.7387261\n\n\n3.649562\n10.871071\n1.4511558\n\n\n4.224859\n9.295660\n1.1960211\n\n\n4.800174\n8.145710\n0.9815663\n\n\n5.375501\n7.279760\n0.8051295\n\n\n5.950836\n6.609149\n0.6612108\n\n\n6.526177\n6.076599\n0.5441408\n\n\n\n\nCodepar(mfrow=c(1,2))\nplot(R0, mean_age, xlab = \"R0\", ylab = \"mean age of infection\")\nplot(R0, sum_cases, xlab = \"R0\", ylab = \"total cases between 15-35y\")\n\n\n\n\n\n7.4.1 Exercise 5: Try the same as you fix \\(R_0\\) but change the birth rate (as if new infants were vaccinated), instead of changing the contact rate.\nFor example, if the birth rate was 100 before, try using a sequence of birth rates ranging from 100 (i.e. no new infants are vaccinated) to 75 (i.e., 25% of new infants are vaccinated). You can use the technique we used above, where we ran the simulation in a loop multiple times, for varying levels of contact, modifying it to run on varying levels of births (e.g., between 75 and 100).\n\nCodedf &lt;- data.frame(\n    births = births_seq,\n    R0 = R0_b,\n    \"mean age\" = mean_age_b,\n    \"cases (15-35y)\" = sum_cases_b\n)\n\nknitr::kable(df)\n\n\n\nbirths\nR0\nmean.age\ncases..15.35y.\n\n\n\n75.00000\n6.526177\n7.964942\n0.7093049\n\n\n77.77778\n6.526177\n7.683702\n0.6913806\n\n\n80.55556\n6.526177\n7.425096\n0.6730883\n\n\n83.33333\n6.526177\n7.186665\n0.6545678\n\n\n86.11111\n6.526177\n6.966264\n0.6359377\n\n\n88.88889\n6.526177\n6.762021\n0.6172979\n\n\n91.66667\n6.526177\n6.572292\n0.5987331\n\n\n94.44444\n6.526177\n6.395635\n0.5803142\n\n\n97.22222\n6.526177\n6.230778\n0.5621003\n\n\n100.00000\n6.526177\n6.076599\n0.5441408\n\n\n\n\nCodepar(mfrow = c(1, 2))\nplot(births_seq, mean_age_b, xlab = \"births\", ylab = \"mean age of infection\")\nplot(births_seq, sum_cases_b, xlab = \"births\", ylab = \"total cases between 15-35y\")\n\n\n\nCode#plot(births_seq,R0_b,xlab=\"births\",ylab=\"R0\")"
  },
  {
    "objectID": "r-session-02.html#what-do-real-contact-networks-look-like",
    "href": "r-session-02.html#what-do-real-contact-networks-look-like",
    "title": "\n7  R Session 02\n",
    "section": "\n7.5 What do real contact networks look like?",
    "text": "7.5 What do real contact networks look like?\nThe POLYMOD study Mossong, 2008 was a journal-based look into the contact network in contemporary European society. Let’s have a look what these data tell us about the contact structure.\n\nCodemoss &lt;- read.csv(\n    url(\"http://www.math.mcmaster.ca/~bolker/eeid/data/mossong.csv\"),\n    as.is = TRUE\n)\n\nage_categories &lt;- moss$contactor[1:30]\nmoss$contactor &lt;- ordered(moss$contactor, levels = age_categories)\nmoss$contactee &lt;- ordered(moss$contactee, levels = age_categories)\n\n\nSince contacts are symmetric, we’ll need to estimate the symmetric contact matrix.\n\nCodex1 &lt;- with(\n    moss,\n    tapply(contact.rate, list(contactor, contactee), unique)\n)\n\nxsym &lt;- (x1 + t(x1)) / 2\n\n\n\nCodefilled.contour(ages, ages, log10(xsym))\nCodefilled.contour(\n    ages, ages, log10(xsym),\n    plot.title = title(\n        main = quote(log[10](contact ~ rate)),\n        xlab = \"age\", ylab = \"age\"\n    )\n)\nCodebarplot(height=apply(x1,1,sum))\nCodebarplot(height=apply(x1,2,sum))\n\n\nWhile this matrix tells us how many contacts are made per year by an individual of each age, it doesn’t tell us anything about the probability that a contact results in communication of infection. Let’s assume that each contact has a constant probability \\(q\\) of resulting in a transmission event.\n\nCodeq &lt;- 3e-5\nbeta_ages &lt;- q * xsym\n\nfilled.contour(\n    ages,ages,log10(beta_ages),\n    plot.title = title(\n        main=\"WAIFW matrix based on POLYMOD data\",\n        xlab=\"age\", ylab=\"age\"\n    )\n)\n\n\n\n\nNow let’s simulate the introduction of such a pathogen into a population characterized by this contact structure.\n\nCodesol_p &lt;- deSolve::ode(\n    y = demog_yinit_ages,\n    times = seq(0, 200, by = 0.5),\n    func = ja_multistage_model,\n    parms = multistage_params\n)\n\ntime &lt;- sol_p[, 1]\ninfects_p &lt;- sol_p[, 1+iindex]\nplot(time, apply(infects_p, 1, sum), type = 'l')\nlines(time, apply(infects_p[, juvies], 1, sum), col = 'red')\nlines(time, apply(infects_p[, adults], 1, sum), col = 'blue')\n\n\nAs before, we can also look at the equilibrium seroprevalence\n\nCodeequil_p &lt;- drop(tail(sol_p, 1))[-1]\n\nn_p &lt;- equil_p[sindex] + equil_p[iindex] + equil_p[rindex]\n\nseroprev_p &lt;- equil_p[rindex] / n_p\n\nnames(seroprev_p) &lt;- ages\n\nbarplot(height = seroprev_p, width = c(demog_params[5:6]))\n\n\nand compute the \\(R_0\\) for this infection.\n\nCoden_p &lt;- solve(\n    multistage_params[[\"aging\"]],\n    -c(multistage_params[[\"births_ages\"]], rep(0, 29))\n)\n\nF_p &lt;- diag(n_p) %*% multistage_params[[\"beta_ages\"]] +\n    multistage_params[[\"aging\"]] -\n    diag(diag(multistage_params[[\"aging\"]]))\n\nV_p &lt;- diag(\n    multistage_params[[\"gamma_ages\"]] -\n        diag(multistage_params[[\"aging\"]])\n    )\n\nmax(\n    Re(\n        eigen(solve(V_p,F_p),only.values=T)$values\n    )\n)\n\n\nHow does this R0 value compare to the R0 value obtained from Exercise 4?"
  },
  {
    "objectID": "r-session-02.html#bonus-calculating-r0-using-a-next-generation-matrix",
    "href": "r-session-02.html#bonus-calculating-r0-using-a-next-generation-matrix",
    "title": "\n7  R Session 02\n",
    "section": "\n7.6 Bonus: Calculating R0 Using a Next Generation Matrix",
    "text": "7.6 Bonus: Calculating R0 Using a Next Generation Matrix\nThe next generation matrix is a matrix that specifies how many new age-specific infections are generated by a typical infected individual of each age class (in a fully susceptible population). For example, let’s consider an infected adult and ask how many new juvenile infections it generates: this is the product of the number of susceptible juveniles (from the stable age distribution), the per capita transmission rate from adults to juveniles and the average duration of infection, i.e. \\(S_J^* \\times \\beta_{JA} \\times 1/ (\\gamma+\\mu)\\). This forms one element of our next generation matrix. The other elements look very similar, except there are extra terms when we consider an infected juvenile because there is a (very small) chance they may age during the infectious period and therefore cause new infections as an adult:\n\\[\n\\mathrm{NGM} = \\left(\n  \\begin{matrix}\n    \\frac{S_J^* \\beta_{JJ} }{(\\gamma+\\alpha)} +\\frac{\\alpha}{(\\gamma+\\mu)}\\frac{S_J^*\\beta_{JA}}{(\\gamma+\\mu)} &  \n    \\frac{S_J^* \\beta_{JA}}{(\\gamma+\\mu)} \\\\\n    \\frac{S_A^* \\beta_{AJ} }{(\\gamma+\\alpha)} +\\frac{\\alpha}{(\\gamma+\\mu)}\\frac{S_A^*\\beta_{AA}}{(\\gamma+\\mu)} &  \\frac{S_A^* \\beta_{AA}}{(\\gamma+\\mu)}\n  \\end{matrix}\n\\right)\n\\]\n\\(R_0\\) can then be computed as the dominant eigenvalue (i.e., the one with the largest real part) of this matrix. Let’s take an example from a model with 2 age classes, from above. First, let’s define the components of the next generation matrix:\n\nCodeda_ngm &lt;- c(20, 60) # this classifies the two age groups (0-20, 21-60) \nbeta1_ngm = 0.005\nbeta2_ngm = 0.006\nalpha_ngm &lt;- 1/da_ngm[1]\nmu_ngm &lt;- 1/da_ngm[2]\nn_ngm &lt;- demog_params[4] / c(alpha_ngm, mu_ngm)\n\nbeta_ngm &lt;- matrix(\n    c(beta1_ngm + beta2_ngm, beta1_ngm, beta1_ngm, beta1_ngm + beta2_ngm),\n    nrow = 2,\n    ncol = 2\n)\n\ngamma_ngm = 10\n\n\nThe Next Generation Matrix can be calculated in R as:\n\nCodengm &lt;- matrix(\n    c(\n        n_ngm[1] * beta_ngm[1,1] / (gamma_ngm+alpha_ngm) +\n            alpha_ngm / (gamma_ngm+mu_ngm) *\n            n[1] *\n            beta_ngm[1,2] / (gamma_ngm+mu_ngm),\n        n_ngm[2] * beta_ngm[2,1] / (gamma_ngm+alpha_ngm) +\n            alpha_ngm / (gamma_ngm+mu_ngm) *\n            n[2] *\n            beta_ngm[2,2] / (gamma_ngm+mu_ngm),\n        n_ngm[1] * beta_ngm[1,2] / (gamma_ngm+mu_ngm),\n        n_ngm[2] * beta_ngm[2,2] / (gamma_ngm+mu_ngm)\n        ),\n    nrow = 2,\n    ncol = 2\n)\n\neigen(ngm)\n\neigen() decomposition\n$values\n[1] 7.185592 1.592730\n\n$vectors\n           [,1]       [,2]\n[1,] -0.1959422 -0.8584125\n[2,] -0.9806154  0.5129600\n\nCodeeigen(ngm, only.values = TRUE)\n\n$values\n[1] 7.185592 1.592730\n\n$vectors\nNULL\n\nCodemax(\n    Re(\n        eigen(ngm, only.values = TRUE)$values\n    )\n)\n\n[1] 7.185592"
  },
  {
    "objectID": "r-session-03.html#estimating-r_0",
    "href": "r-session-03.html#estimating-r_0",
    "title": "\n9  R Session 03\n",
    "section": "\n9.1 Estimating \\(R_0\\)\n",
    "text": "9.1 Estimating \\(R_0\\)\n\nSo far in this class we have focused on the theory of infectious disease. Often, however, we will want to apply this theory to particular situations. One of the key applied problems in epidemic modeling is the estimation of \\(R_0\\) from outbreak data. In this session, we study two methods for estimating \\(R_0\\) from an epidemic curve. As a running example, we will use the data on influenza in a British boarding school.\n\nCodeload(here::here(\"data\", \"R-estimation-data.RData\"))\n\nplot(\n  flu,\n  type = 'b',\n  log = 'y',\n  main = 'Epidemic in a British boarding school',\n  cex.main=0.85,\n  xlab='Day',\n  ylab='Active influenza cases'\n)"
  },
  {
    "objectID": "r-session-03.html#estimating-r_0-from-the-final-outbreak-size",
    "href": "r-session-03.html#estimating-r_0-from-the-final-outbreak-size",
    "title": "\n9  R Session 03\n",
    "section": "\n9.2 Estimating \\(R_0\\) from the final outbreak size",
    "text": "9.2 Estimating \\(R_0\\) from the final outbreak size\nOur first approach is to estimate \\(R_0\\) from the final outbreak size. Although unhelpful at the early stages of an epidemic (before the final epidemic size is observed), this method is nonetheless a useful tool for \\({post hoc}\\) analysis. The method is general and can be motivated by the following argument (Keeling and Rohani 2007): First, we assume that the epidemic is started by a single infectious individual in a completely susceptible population. On average, this individual infects \\(R_0\\) others. The probability a particular individual escaped infection is therefore \\(e^{-R_0/N}\\). If \\(Z\\) individuals have been infected, the probability of an individual escaping infection from all potential sources is \\(e^{-ZR_0/N}\\). It follows that at the end of the epidemic a proportion \\(R(\\infty)=Z/N\\) have been infected and the fraction remaining susceptible is \\(S(\\infty)=e^{-R(\\infty)R_0}\\), which is equal to \\(1-R(\\infty)\\), giving\n\\[\n  \\label{R0-estimator}\n  1 - R(\\infty) - e^{-R(\\infty)R_0} = 0\n\\]\nRearranging, we have the estimator\n\\[\n  \\label{R0-estimator-2}\n  \\hat{R_0} = \\frac{log(1-Z/N)}{-Z/N},\n\\]\nwhich, in this case, evaluates to \\(\\frac{log(1-512/764)}{-512/764} = 1.655\\).\n\n9.2.1 Exercise 1\nThis equation shows the important one-to-one relationship between \\(R_0\\) and the final epidemic size. Plot the relationship between the total epidemic size and \\(R_0\\) for the complete range of values between 0 and 1."
  },
  {
    "objectID": "r-session-03.html#linear-approximation",
    "href": "r-session-03.html#linear-approximation",
    "title": "\n9  R Session 03\n",
    "section": "\n9.3 Linear Approximation",
    "text": "9.3 Linear Approximation\nThe next method we introduce takes advantage of the fact that during the early stages of an outbreak, the number of infected individuals is given approximately as \\(Y(t) \\approx Y_0 e^{((R_0-1)(\\gamma + \\mu)t)}\\). Taking logarithms of both sides, we have \\(log(Y(t)) \\approx log(Y_0) + (R_0-1)(\\gamma + \\mu)t\\), showing that the log of the number of infected individuals is approximately linear in time with a slope that reflects both \\(R_0\\) and the recovery rate.\nThis suggests that a simple linear regression fit to the first several data points on a log-scale, corrected to account for \\(\\gamma\\) and \\(\\mu\\), provides a rough and ready estimate of \\(R_0\\). For flu, we can assume \\(\\mu =0\\) because the epidemic occurred over a time period during which natural mortality is negligible. Further, assuming an infectious period of about 2.5 days, we use \\(\\gamma = (2.5)^{-1} = 0.4\\) for the correction. Fitting to the first four data points, we obtain the slope as follows.\n\nCodemodel &lt;- lm(log(flu[1:4]) ~ day[1:4], data = flu);  #fit a linear model\nsummary(model)         #summary statistics for fit model\n\n\nCall:\nlm(formula = log(flu[1:4]) ~ day[1:4], data = flu)\n\nResiduals:\n       1        2        3        4 \n 0.03073 -0.08335  0.07450 -0.02188 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)   \n(Intercept) -0.02703    0.10218  -0.265  0.81611   \nday[1:4]     1.09491    0.03731  29.346  0.00116 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.08343 on 2 degrees of freedom\nMultiple R-squared:  0.9977,    Adjusted R-squared:  0.9965 \nF-statistic: 861.2 on 1 and 2 DF,  p-value: 0.001159\n\nCodeslope &lt;- coef(model)[2]  #extract slope parameter\nslope                 #print to screen\n\nday[1:4] \n1.094913 \n\n\nRearranging the linear equation above and denoting the slope coefficient by \\(\\hat \\beta_1\\) we have the estimator \\(\\hat R_0 = \\hat \\beta_1 / \\gamma +1\\) giving \\(\\hat R_0=1.094913/0.4+1 \\approx 3.7\\).\n\n9.3.1 Exercise 2\nOur estimate assumes that boys remained infectious during the natural course of infection. The original report on this epidemic indicates that boys found to have symptoms were immediately confined to bed in the infirmary. The report also indicates that only 1 out of 130 adults at the school exhibited any symptoms. It is reasonable, then, to suppose that transmission in each case ceased once he had been admitted to the infirmary. Supposing admission happened within 24 hours of the onset of symptoms. How does this affect our estimate of \\(R_0\\)? Twelve hours?\n\n9.3.2 Exercise 3\nBiweekly data for outbreaks of measles in three communities in Niamey, Niger are provided in the dataframe \\(\\tt niamey\\). Use this method to obtain estimates of \\(R_0\\) for measles from the first community assuming that the infectious period is approximately two weeks or \\(14/365 \\approx 0.0384\\) years.\n\n9.3.3 Exercise 4\nA defect with this method is that it uses only a small fraction of the information that might be available, i.e., the first few data points. Indeed, there is nothing in the method that tells one how many data points to use–this is a matter of judgment. Further, there is a tradeoff in that as more and more data points are used the precision of the estimate increases, but this comes at a cost of additional bias. Plot the estimate of \\(R_0\\) obtained from \\(n=3, 4, 5, ...\\) data points against the standard error of the slope from the regression analysis to show this tradeoff."
  },
  {
    "objectID": "r-session-03.html#estimating-dynamical-parameters-with-least-squares",
    "href": "r-session-03.html#estimating-dynamical-parameters-with-least-squares",
    "title": "\n9  R Session 03\n",
    "section": "\n9.4 Estimating dynamical parameters with least squares",
    "text": "9.4 Estimating dynamical parameters with least squares\nThe objective of the previous exercise was to estimate \\(R_0\\). Knowing \\(R_0\\) is critical to understanding the dynamics of any epidemic system. It is, however, a composite quantity and is not sufficient to completely describe the epidemic trajectory. For this, we require estimates for all parameters of the model. In this exercise, we introduce a simple approach to model estimation called least squares fitting, sometimes called trajectory matching. The basic idea is that we find the values of the model parameters that minimize the squared differences between model predictions and the observed data. To demonstrate least squares fitting, we consider an outbreak of measles in Niamey, Niger, reported on by Grais et al. 2006 (Grais, R.F., et al. 2006. Estimating transmission intensity for a measles outbreak in Niamey, Niger: lessons for intervention. Transactions of the Royal Society of Tropical Medicine and Hygiene 100:867-873.).\n\nCodeniamey[5,3] &lt;- 0  #replace a \"NA\"\nniamey &lt;- data.frame(\n  biweek = rep(seq(1, 16), 3),\n  site = c(rep(1, 16), rep(2, 16), rep(3, 16)),\n  cases = c(niamey[, 1], niamey[, 2], niamey[, 3])\n) #define \"biweeks\"\n\n\n\nCodeplot(\n  niamey$biweek,\n  niamey$cases,\n  type='p',\n  col = niamey$site,\n  xlab = 'Biweek',\n  ylab = 'Cases'\n)\n\nlines(niamey$biweek[niamey$site == 1], niamey$cases[niamey$site == 1]) \nlines(niamey$biweek[niamey$site == 2], niamey$cases[niamey$site == 2],col = 2)\nlines(niamey$biweek[niamey$site == 3], niamey$cases[niamey$site == 3],col = 3)"
  },
  {
    "objectID": "r-session-03.html#dynamical-model",
    "href": "r-session-03.html#dynamical-model",
    "title": "\n9  R Session 03\n",
    "section": "\n9.5 Dynamical Model",
    "text": "9.5 Dynamical Model\nFirst, we write a specialized function for simulating the \\(SIR\\) model in a case where the removal rate is ``hard-wired’’ and with no demography.\n\nCodeclosed_sir_model &lt;- function (t, x, params) {  #SIR model equations\n  X &lt;- x[1]\n  Y &lt;- x[2]\n  beta &lt;- params\n  dX &lt;- - beta * X * Y\n  dY &lt;- beta * X * Y -(365 / 13) * Y\n  \n  list(c(dX, dY))\n}"
  },
  {
    "objectID": "r-session-03.html#objective-function",
    "href": "r-session-03.html#objective-function",
    "title": "\n9  R Session 03\n",
    "section": "\n9.6 Objective function",
    "text": "9.6 Objective function\nNow we set up a function that will calculate the sum of the squared differences between the observations and the model at any parameterization (more commonly known as “sum of squared errors”). In general, this is called the objective function because it is the quantity that optimization seeks to minimize.\n\nCodesse_sir &lt;- function(params0, data, site){  #function to calculate squared errors\n  data &lt;- data[data$site == site, ]    #working dataset, based on site\n  t &lt;- data[, 1] * 14 / 365            #time in biweeks\n  cases &lt;- data[, 3]               #number of cases\n  beta &lt;- exp(params0[1])            #parameter beta\n  X0 &lt;- exp(params0[2])           #initial susceptibles\n  Y0 &lt;- exp(params0[3])           #initial infected        \n  \n  out &lt;- as.data.frame(\n    deSolve::ode(\n      c(X = X0, Y = Y0),\n      times = t,\n      closed_sir_model,\n      beta,\n      hmax = 1/120\n    )\n  )\n\n  sum((out$Y - cases)^2)       #sum of squared errors that is returned to the optim function\n}\n\n\nNotice that the code for sse_sir makes use of the following modeling trick. We know that \\(\\beta\\), \\(X_0\\), and \\(Y_0\\) must be positive, but our search to optimize these parameters will be over the entire number line. We could constrain the search using a more sophisticated algorithm, but this might introduce other problems (i.e., stability at the boundaries). Instead, we parameterize our objective function (sse_sir) in terms of some alternative variables \\(log(\\beta)\\), \\(log(X_0)\\), and \\(log(Y_0)\\). While these numbers range from \\(-\\infty\\) to \\(\\infty\\) (the range of our search) they map to our model parameters on a range from \\(0\\) to \\(\\infty\\) (the range that is biologically meaningful)."
  },
  {
    "objectID": "r-session-03.html#optimization",
    "href": "r-session-03.html#optimization",
    "title": "\n9  R Session 03\n",
    "section": "\n9.7 Optimization",
    "text": "9.7 Optimization\nOur final step is to use the function optim to find the values of \\(\\beta\\), \\(X_0\\), and \\(Y_0\\) that minimize the sum of squared errors as calculated using our function.\n\nCodeparams0 &lt;- c(-3.2, 7.3, -2.6)  #initial guess\nfit1 &lt;- optim(params0, sse_sir, data = niamey, site = 1) #fit\nexp(fit1$par)  #back-transform parameters\n\n[1] 5.463181e-03 9.110385e+03 2.331841e+00\n\nCodefit2 &lt;- optim(params0, sse_sir, data = niamey, site = 2) #fit\nexp(fit2$par)  #back-transform parameters\n\n[1] 8.666138e-03 6.276503e+03 2.843753e-01\n\nCodefit3 &lt;- optim(params0, sse_sir, data = niamey, site = 3) #fit\n\n\nFinally, we plot these fits against the data.\n\nCodepar(mfrow=c(3,1))   #set up plotting area for multiple panels\nplot(\n  cases ~ biweek,\n  data = subset(niamey, site == 1),\n  type = 'b',\n  col = 'blue',\n  pch = 21\n) #plot site 1\n\nt &lt;- subset(niamey, site == 1)[, 1] * 14 / 365\n\nmod_pred &lt;-as.data.frame(\n  deSolve::ode(\n    c(X = exp(fit1$par[2]),\n    Y = exp(fit1$par[3])),\n    times = t,\n    closed_sir_model,\n    exp(fit1$par[1]),\n    hmax=1/120\n  )\n)\n                              #obtain model predictions\nlines(mod_pred$Y ~ subset(niamey, site == 1)[, 1]) #and plot as a line\n\nplot(\n  cases ~ biweek,\n  data = subset(niamey, site == 2),\n  type = 'b',\n  col = site\n) #site 2\n\nt &lt;- subset(niamey, site == 2)[, 1] * 14 / 365\n\nmod_pred &lt;- as.data.frame(\n  deSolve::ode(\n    c(X = exp(fit2$par[2]), Y = exp(fit2$par[3])),\n    times = t,\n    closed_sir_model,\n    exp(fit2$par[1]),\n    hmax = 1/120\n  )\n)\n\nlines(mod_pred$Y ~ subset(niamey, site == 2)[, 1])\n\nplot(\n  cases ~ biweek,\n  data = subset(niamey, site == 3),\n  type = 'b',\n  col = site\n) #site 3\n\nt &lt;- subset(niamey, site == 3)[, 1] * 14 / 365\n\nmod_pred &lt;-as.data.frame(\n  deSolve::ode(\n    c(X = exp(fit3$par[2]), Y = exp(fit3$par[3])),\n    times = t,\n    closed_sir_model,\n    exp(fit3$par[1]),\n    hmax = 1/120\n  )\n)\n\nlines(mod_pred$Y ~ subset(niamey, site == 3)[, 1])\n\n\n\n\n\n9.7.1 Exercise 5\nTo make things easier, we have assumed the infectious period is known to be 14 days. In terms of years, \\(\\gamma = (365/14)^{-1} \\approx 0.0384\\). Now, modify the code above to estimate \\(\\gamma\\) and \\(\\beta\\) simultaneously.\n\n9.7.2 Exercise 6\nWhat happens if one or both of the other unknowns (\\(X_0\\) and \\(Y_0\\)) is fixed instead of \\(\\gamma\\)?"
  }
]