---
format:
  html:
    page-layout: full
execute:
    echo: false
---

# R Session 01 
## Interactive Plot {#sec-interactive-plots}

```{ojs}
//| panel: input
viewof beta = Inputs.range(
  [0.0, 2.0],
  {value: 0.3, step: 0.01, label: "Transmission rate"}
)
viewof dur_inf = Inputs.range(
  [0.0, 20],
  {value: 6.0, step: 0.5, label: "Duration of Infection (days)"}
)

viewof I0 = Inputs.range(
  [0.0, 1.0],
  {value: 0.01, step: 0.01, label: "Initial fraction infected"}
)

viewof area = Inputs.toggle(
  {label: "Cumulative Area plot", value: false}
)
```

```{ojs}
function sir(dydt, y, t) {
  var gamma = 1 / dur_inf

  dydt[0] = -beta * y[0] * y[1]
  dydt[1] = beta * y[0] * y[1] - gamma * y[1]
  dydt[2] = gamma * y[1]
}
```

```{ojs}
import {odeRK4} from '@rreusser/integration@3064'
import { aq, op } from '@uwdata/arquero'
```

```{ojs}
function simulate(f, t0, y0, dt, tmax) {
  var t = t0
  var y = y0
  var i = 0

  var tsim = [t0]
  var ysim = [y0]

  for (t = t0 + dt; t <= tmax; t += dt) {
    ysim.push(odeRK4([], ysim[i], f, dt))
    tsim.push(t)
    i += 1
  }
  
  return aq.table({
    t: tsim,
    S: ysim.map(d => d[0]),
    I: ysim.map(d => d[1]),
    R: ysim.map(d => d[2])
    })
}
```

```{ojs}
sir_sol = simulate(sir, 0, [1.0-I0, I0, 0.0], 0.01, 200)
sir_sol_long = sir_sol.fold(aq.not('t'), {as: ['State', 'Fraction']})
```

```{ojs}
SIRcolors = ["#1f77b4", "#ff7f0e", "#FF3851"]
```

::: {.panel-tabset}

### Closed Population

```{ojs}
closed_R0 = beta * dur_inf
closed_R0_str = closed_R0.toLocaleString(undefined, {minimumFractionDigits: 2})

finalsize = sir_sol.get("R", sir_sol.numRows()-1)
finalsize_str = finalsize.toLocaleString(undefined, {minimumFractionDigits: 2})

md`${tex`R_0 = ${closed_R0_str}`}`
md`${tex`\text{Final size} = ${finalsize_str}`}`
```

```{ojs}
Plot.plot({
  color: {
    legend: true,
    domain: ["S", "I", "R"],
    range: SIRcolors
  },
  style: {fontSize: "20px"},
  marginLeft: 65,
  marginTop: 40,
  grid: true,
  width: 1000,
  height: 600,
  y: {domain: [0, 1]},
  marks: [
    area ?
      Plot.areaY(sir_sol_long, {x: "t", y: "Fraction", fill: "State"}) :
      Plot.lineY(sir_sol_long, {x: "t", y: "Fraction", stroke: "State", strokeWidth: 6})
  ]
})
```

### Demographics

```{ojs}
//| panel: input
viewof births = Inputs.range(
  [0.0, 0.5],
  {value: 0.05, step: 0.001, label: "Birth rate"}
)

viewof tmax = Inputs.range(
  [200.0, 500.0],
  {value: 200.0, step: 50.0, label: "Maximum simulation time"}
)
```

```{ojs}
demographic_R0 = beta / ((1/dur_inf) + births)
eq_S = 1 / demographic_R0
eq_I = births / beta * (demographic_R0 - 1)
eq_R = 1 - (eq_S + eq_I)

eq_vals = aq.table({
  State: ["S", "I", "R"],
  Fraction: [eq_S, eq_I, eq_R]
})

demographic_R0_str = demographic_R0.toLocaleString(undefined, {minimumFractionDigits: 2})

md`${tex`R_0 = ${demographic_R0_str}`}`
```

```{ojs}
function sir_demographic(dydt, y, t) {
  var gamma = 1 / dur_inf

  dydt[0] = - beta * y[0] * y[1] + births * (1 - y[0])
  dydt[1] = beta * y[0] * y[1] - gamma * y[1] - births * y[1]
  dydt[2] = gamma * y[1] - births * y[2]
}
```

```{ojs}
sir_demographic_sol = simulate(sir_demographic, 0, [1.0-I0, I0, 0.0], 0.01, tmax)
sir_demographic_sol_long = sir_demographic_sol.fold(aq.not('t'), {as: ['State', 'Fraction']})
```

```{ojs}
Plot.plot({
  color: {
    legend: true,
    domain: ["S", "I", "R"],
    range: SIRcolors
  },
  style: {fontSize: "20px"},
  marginLeft: 65,
  marginTop: 40,
  grid: true,
  width: 1000,
  height: 600,
  y: {domain: [0, 1]},
  marks: [
    area ?
      Plot.areaY(sir_demographic_sol_long, {x: "t", y: "Fraction", fill: "State"}) :
      [
        demographic_R0 >= 1.0 ?
          Plot.ruleY(
            eq_vals,
            {y: "Fraction", stroke: "State", strokeWidth: 2, strokeDasharray: [10]}
          ) :
          null,
        Plot.lineY(
          sir_demographic_sol_long,
          {x: "t", y: "Fraction", stroke: "State", strokeWidth: 6}
        )
      ]
  ]
})
```

:::

## Exercise 1
### Closed Population Model

::: {.callout-instructions}
**SET**

Transmission rate = 1

Duration of infection = 4.
:::

#### What is $R_0$? {#sec-whatisr0}
#### What is epidemic final size?
#### Does this make sense given our definition of $R_0$?

::: {.callout-instructions}
Toggle on the cumulative area button and see what the epidemic final size is (approximately)
:::

#### At approximately what time does the epidemic end?

::: {.callout-instructions}
**SET**

Duration of infection = 8 days

Transmission rate so you get the same $R_0$ in @sec-whatisr0
:::

#### How does the epidemic final size compare?
#### At what time (approx) does the epidemic end?

::: {.callout-note}
Size is determined by $R_0$, duration is determined by recovery rate $\left(\gamma = \frac{1}{\text{duration of infection}}\right)$
:::

Now, imagine that we have a drug (or vaccine) available to everyone that either reduced transmission OR shortened the duration of infection.

::: {.callout-instructions}
**SET**

Transmission rate = 1

Duration of infection = 8 days
:::

#### Note the epidemic final size and the time until the epidemic is over.

::: {.callout-instructions}
Now, imagine everyone has access to the drug (unrealistic) that reduces transmission by $P \%$
:::

#### What happens to the final size and outbreak duration?

Now, imagine everyone has access to a drug that reduces the duration of infection from 8 to 2 days (75% reduction).

#### What happens to the final size and outbreak duration?

::: {.callout-question}
Which would you prefer and why? (This is the only really open ended question, but should be pretty straightforward discussion)
:::

### Demographic Model

::: {.callout-instructions}
**SET:**
Transmission = 1

Duration = 8

Birth rate = .002
:::

#### What is $R_0$? {#sec-demog-whatisr0}
#### What is the equilibrium proportion that is susceptible?
#### If you were to test for antibodies against infection in the population, what proportion would you expect to be positive?

::: {.callout-note}
Assume a perfectly accurate serological test
:::

#### At what time (approximately) does the system reach equilibrium?

::: {.callout-instructions}
**SET**

Birth rate = 0.005
:::

#### What is the new $R_0$? {#sec-demog-updatedr0}
#### At what time (approximately) does the system reach equilibrium?

::: {.callout-instructions}
Transmission rate so you get the same $R_0$ in @sec-demog-whatisr0
:::

#### What is the new equilibrium proportion that is susceptible?
#### What is different about the prevalence of infection (equilibrium proportion that is infected) in the scenarios @sec-demog-whatisr0 and @sec-demog-updatedr0 i.e. higher birth rate with the same $R_0$?

## Exercise 2

Now we have some intuition behind how the different parameters affect the dynamics of the SIR system, let's look at how we can implement this in R.
Below is some R code that implements the basic closed-population SIR model.
The purpose of the questions in this exercise is to guide you through the code and help you understand how it works so you can modify it to answer your own questions.

::: {.callout-tip}
There are a number of useful features throughout this website to help you.

Firstly, clicking on the text `Click to toggle the code` does what it says on the tin - clicking the button will hide the code if open (the default), or show the code if hidden.

Secondly, in the top right corner of each code block, there is a button that looks like a clipboard.
Clicking this button will copy the code to your clipboard, so you can paste it into your own R session.

Finally, within the code blocks (and, in fact, in the regular text like this section), functions (e.g. `list()`, `pivot_longer()`) that come from a package (i.e., ones we didn't write) show up in a different color.
In most cases, you can hover your cursor over them (on the part next the the parentheses e.g., `ode()` from the line `deSolve::ode()`), and if they become underlined, you can click on them to go to the documentation for that function.
This is like searching for the documentation from your R console using `?ode`.
:::

```{r}
#| message: false
#| echo: true

library(tidyverse)
library(deSolve)

theme_set(theme_minimal())

sir_model <- function(time, state, params, ... ){
  transmission <- params["transmission"]
  recovery <- 1 / params["duration"]

  S <- state["S"]
  I <- state["I"]
  R <- state["R"]

  dSdt <- -transmission * S * I
  dIdt <- (transmission * S * I) - (recovery * I)
  dRdt <- (recovery * I)

  return(list(c(dSdt, dIdt, dRdt)))
}

sir_params <- c(transmission = 0.3, duration = 6)
sir_init_states <- c(S = 0.99, I = 0.01, R = 0)
sim_times <- seq(0, 200, by = 0.1)

sir_sol <- deSolve::ode(
  y = sir_init_states,
  times = sim_times,
  func = sir_model,
  parms = sir_params
)

sir_sol_df <- as_tibble(sir_sol) %>%
  mutate(
    across(
      everything(),
      as.numeric
    )
  ) %>%
  pivot_longer(
    cols = -time,
    names_to = "state",
    values_to = "proportion"
  ) %>%
  mutate(state = factor(state, levels = c("S", "I", "R")))

SIRcolors <- c(S = "#1f77b4", I = "#ff7f0e", R = "#FF3851")

ggplot(sir_sol_df, aes(x = time, y = proportion, color = state)) +
  geom_line(linewidth = 1.5) +
  scale_color_manual(values = SIRcolors) +
  labs(
    x = "Time",
    y = "Fraction",
    color = "State"
  ) +
  theme(legend.position = "top")
```

::: {.callout-instructions}
Copy the code above into a new R script.
This script should live in your SISMID directory, as described [previously]().
Run it to check you get the same figure output as above.
:::

### Commenting the code

### Adding in demographics

Now we have a better sense of how the code works, let's add in some demographic structure.
To recreate the demographic model from the interactive plot in @sec-interactive-plots, we just need to add births and deaths to the system.

Recall the equations for the demographic model:

$$
\begin{aligned}
\frac{dS}{dt} &= \mu N - \beta S I - \mu S \\
\frac{dI}{dt} &= \beta S I - \gamma I - \mu I \\
\frac{dR}{dt} &= \gamma I - \mu R
\end{aligned}
$$ {#eq-demographic-sir}

#### Create a new R script called `01_demographic-sir.R` and copy the code from `S01_basic-sir.R` into it.

#### Rename the function `sir_model()` to `demographic_sir_model()` in your new script (`S01_demographic-sir.R`). 

#### Adapt the function `demographic_sir_model()` to match the above equations (@eq-demographic-sir).

::: {.callout-instructions}
**SET** birth rate = 0.05
:::

#### Rename the variables to reflect that we are now working with a demographic model, not the basic SIR model.


#### Plot the results of your demographic model. Does it look like this?

```{r}
#| message: false
#| echo: false

sir_demog_model <- function(time, state, params, ... ){
  transmission <- params["transmission"]
  recovery <- 1 / params["duration"]
  birth_rate <- params["birth_rate"]

  S <- state["S"]
  I <- state["I"]
  R <- state["R"]

  dSdt <- -transmission * S * I + (birth_rate * (1 - S))
  dIdt <- (transmission * S * I) - (recovery * I) - (birth_rate * I)
  dRdt <- (recovery * I) - (birth_rate * R)

  return(list(c(dSdt, dIdt, dRdt)))
}

sir_demog_params <- c(sir_params, birth_rate = 0.05)

sir_demog_sol <- deSolve::ode(
  y = sir_init_states,
  times = sim_times,
  func = sir_demog_model,
  parms = sir_demog_params
)

sir_demog_sol_df <- as_tibble(sir_demog_sol) %>%
  mutate(
    across(
      everything(),
      as.numeric
    )
  ) %>%
  pivot_longer(
    cols = -time,
    names_to = "state",
    values_to = "proportion"
  ) %>%
  mutate(state = factor(state, levels = c("S", "I", "R")))

ggplot(sir_demog_sol_df, aes(x = time, y = proportion, color = state)) +
  geom_line(linewidth = 1.5) +
  scale_color_manual(values = SIRcolors) +
  labs(
    x = "Time",
    y = "Fraction",
    color = "State"
  ) +
  theme(legend.position = "top")
```