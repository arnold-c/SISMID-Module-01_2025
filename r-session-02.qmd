---
subtitle: "Heterogeneity and Age Structure in SIR Models"
abstract-title: ""
abstract: |
    *Materials adapted from Helen Wearing and Aaron King*
execute:
    warning: false
metadata-files: 
  - metadata/matthewferrari.yml
---

# R Session 02

```{r}
library(diagram)
library(deSolve)
library(tidyverse)
```

```{r}
theme_set(theme_minimal())
```

## A Model With 2 Classes

We'll start with the simplest mechanistic model of two classes we can think of, which has separate classes for two groups $a$ and $b$. These groups could represent different socioeconomic classes, for example.

```{r}
#| echo: false
elpos <- rbind(
    Sa = c(2, 3),
    Sb = c(3, 3),
    Ia = c(2, 2),
    Ib = c(3, 2),
    Ra = c(2, 1),
    Rb = c(3, 1)
)

elpos[, 1] <- (2 * elpos[, 1] - 1) / 8
elpos[, 2] <- (2 * elpos[, 2] - 1) / 6

fromto <- rbind(
    SaIa = c(1, 3),
    SbIb = c(2, 4),
    IaRa = c(3, 5),
    IbRb = c(4, 6)
)

op <- par(mar = c(1, 1, 1, 1))

diagram::openplotmat(asp = 0.9)

arrpos <- matrix(ncol = 2, nrow = nrow(fromto))

for (i in seq_len(nrow(fromto))){
    arrpos[i,] <- diagram::straightarrow(
        to = elpos[fromto[i, 2], ],
        from = elpos[fromto[i, 1], ],
        lwd = 2,
        arr.pos = 0.65,
        arr.length = 0.5
    )
}

purrr::walk(
    c("Sa", "Sb", "Ia", "Ib", "Ra", "Rb"),
    .f = function(.x) {
        diagram::textrect(
            elpos[.x, ],
            0.07,
            0.07,
            lab = .x,
            box.col = gray(0.7),
            shadow.col = gray(0.4),
            shadow.size = 0.01,
            cex = 2
        )
    }
)

purrr::pwalk(
    .l = list(
        state = 1:4,
        xadjust = rep(0.05, 4),
        yadjust = rep(-0.175, 4),
        label = rep(c("lambda", "gamma"), 2),
        label_subscript = rep(c("a", "b"), 2)
    ),
    .f = function(state, xadjust, yadjust, label, label_subscript) {
        text(
            elpos[state, 1] + xadjust,
            elpos[state, 2] + yadjust,
            bquote(.(ensym(label))[.(label_subscript)]),
            cex = 2
        )
    }
)

par(op)
```

Which can be written in equations as,
$$
\begin{aligned}
    \frac{dS_a}{dt} &= -\lambda_a\,S_a \phantom{-\gamma\,I_b}\\
    \frac{dS_b}{dt} &= -\lambda_b\,S_b \phantom{-\gamma\,I_b}\\
    \frac{dI_a}{dt} &= \phantom{-}\lambda_a\,S_a -\gamma\,I_a\\
    \frac{dI_b}{dt} &= \phantom{-}\lambda_b\,S_b-\gamma\,I_b\\
    \frac{dR_a}{dt} &= \phantom{-\lambda_a\,S_b}+\gamma\,I_a\\
    \frac{dR_b}{dt} &= \phantom{-\lambda_a\,S_b}+\gamma\,I_b\\
  \end{aligned}
$$

The $\lambda$s denote the group-specific force of infections:

$$
\begin{aligned}
        \lambda_a &= \beta_{aa}\,I_a+\beta_{ab}\,I_b\\
        \lambda_b &= \beta_{ba}\,I_a+\beta_{bb}\,I_b
\end{aligned}
$$

In this model, each population can infect each other but the infection moves through the populations separately.
Let's simulate such a model.
To make things concrete, we'll assume that the transmission rates $\beta$ are greater within groups than between them.

```{r}
ba_params <- c(
    beta_within = 0.025,
    beta_between = 0.005,
    recovery = 10
)
```

```{r}
# Here we set up the ODE model that matches the equations above
ba_model <- function (t, x, p, ...) {     
    s <- x[c("Sa", "Sb")]   # susceptibles
    i <- x[c("Ia", "Ib")]   # infecteds
    r <- x[c("Ra", "Rb")]   # recovereds
    
    beta_within <- p[1]
    beta_between <- p[2]
    recovery <- p[3]

    # group A force of infection
    lambda_a <- beta_within * i[1] + beta_between * i[2]

    # group B force of infection
    lambda_b <- beta_within * i[2] + beta_between * i[1]
    
    list(c(
        # dSa/dt
        - lambda_a * s[1],
        # dSb/dt
        - lambda_b * s[2],
        # dIa/dt
        lambda_a * s[1] - recovery * i[1],
        # dIb/dt
        lambda_b * s[2] - recovery * i[2],
        # dRa/dt
        recovery * i[1],
        # dRb/dt
        recovery * i[2]
    ))
}
```

```{r}
# initial conditions
ba_yinit <- c(Sa = 1000, Sb = 2000, Ia = 1, Ib = 1, Ra = 0, Rb = 0) # set starting conditions

# Run the ODE solver from the deSolve package
sol_ba <- deSolve::ode(
    y = ba_yinit,
    times = seq(0, 2, by = 0.001),
    func = ba_model,
    parms = ba_params,
)
```

```{r}
sol_ba_long <- sol_ba %>%
    as_tibble() %>%
    mutate(Na = Sa + Ia + Ra, Nb = Sb + Ib + Rb) %>%
    pivot_longer(
        cols = -time,
        names_to = c("state", "group"),
        names_sep = 1,
        values_to = "value"
    ) %>%
    mutate(
        state = factor(state, levels = c("S", "I", "R", "N")),
        group = paste("Group", str_to_upper(group))
        )
```

```{r}
SIRcolors <- c("#1f77b4", "#ff7f0e", "#FF3851", "#591099")

ggplot(sol_ba_long, aes(x = time, y = value, color = state)) +
    geom_line(linewidth = 1.5) +
    facet_wrap(~group, scales = "free_y") +
    scale_color_manual(
        values = SIRcolors,
        labels = c("Susceptible", "Infected", "Recovered", "Total")
    ) +
    labs(
        x = "Time",
        y = "Number of individuals",
        color = "State"
    ) +
    theme(legend.position = "bottom")
```

::: {.callout-question}
Despite using the same transmission rates, the epidemic in group B is much larger than in group A.
Why do you think this is?
:::

Now let's plot the proportion of individuals in each state for the two groups.

```{r}
sol_ba_long_props <- sol_ba_long %>%
    filter(state != "N") %>%
    mutate(
        state_group = paste0(state, str_extract_all(group, "[^Group ]")),
        state_group = factor(state_group, levels = c("RA", "RB", "IA", "IB", "SA", "SB"))
    ) %>%
    group_by(time, state_group) %>%
    mutate(
        prop = value / sum(ba_yinit)
    ) %>%
    ungroup()
```

```{r}
Scolors <- RColorBrewer::brewer.pal(3, "Blues")[c(2, 3)]
Icolors <- RColorBrewer::brewer.pal(3, "Oranges")[c(2, 3)]
Rcolors <- RColorBrewer::brewer.pal(3, "Greens")[c(2, 3)]

ggplot(sol_ba_long_props, aes(x = time, y = prop, fill = state_group)) +
    geom_area() +
    scale_fill_manual(
        values = c(Scolors, Icolors, Rcolors),
        limits = c("SA", "SB", "IA", "IB", "RA", "RB"),
    ) +
    labs(
        x = "Time",
        y = "Proportion of individuals",
        fill = "State"
    ) +
    theme(legend.position = "bottom")
```

## A Model With 2 Age Classes

Note that age is a special kind of heterogeneity in an epidemic model because individuals necessarily move from one class (younger) to another class (older) in a directional fashion that is independent of the infection and recovery process.

<!-- Today's first lecture showed how force of infection can vary with age. -->

<!-- What sort of mechanisms might give rise to these effects? -->

<!-- Here we'll see to what extent we can infer these mechanisms on the basis of age-specific incidence and seroprevalence data. -->

We'll start by introducing age into the model above.
So now $a$ becomes juveniles and $b$ becomes adults.
And, independent of the disease process, juveniles (of any category) age into adults.
Additionally, new juveniles are added through births (always first susceptible) and old individuals are lost to death.

```{r, echo=FALSE}
elpos <- rbind(
    B = c(1, 3),
    Sj = c(2, 3),
    Sa = c(3, 3),
    Ij = c(2, 2),
    Ia = c(3, 2),
    Rj = c(2, 1),
    Ra = c(3, 1),
    Ds = c(4, 3),
    Di = c(4, 2),
    Dr = c(4, 1)
)

elpos[, 2] <- (2 * elpos[, 2] - 1) / 6
elpos[, 1] <- (2 * elpos[, 1] - 1) / 8

fromto <- rbind(
    BSj = c(1, 2),
    RaD = c(7, 10),
    SjSa = c(2, 3),
    IjIa = c(4, 5),
    RjRa = c(6, 7),
    SjIj = c(2, 4),
    SaIa = c(3, 5),
    IjRj = c(4, 6),
    IaRa = c(5, 7),
    SaD = c(3, 8),
    IaD = c(5, 9)  
)

op <- par(mar = c(1, 1, 1, 1))

diagram::openplotmat(asp = 1.0)

arrpos <- matrix(ncol = 2, nrow = nrow(fromto))

for (i in seq_len(nrow(fromto)))
    arrpos[i,] <- diagram::straightarrow(
        to = elpos[fromto[i, 2], ],
        from = elpos[fromto[i, 1], ],
        lwd = 2,
        arr.pos = 0.65,
        arr.length = 0.5
    )

purrr::walk(
    c("B", "Sj", "Sa", "Ij", "Ia", "Rj", "Ra", "Ds", "Di", "Dr"),
    .f = function(.x) {
        diagram::textrect(
            elpos[.x, ],
            0.07,
            0.07,
            lab = .x,
            box.col = gray(0.7),
            shadow.col = gray(0.4),
            shadow.size = 0.01,
            cex = 2
        )
    }
)

purrr::pwalk(
    .l = list(
        state = c(seq(2, 7, by = 1), 2, 3, 4, 5),
        xadjust = c(rep(0.125, 6), rep(0.05, 4)),
        yadjust = c(rep(0.05, 6), rep(-0.175, 4)),
        label = c(rep(c("alpha", "mu"), 3), rep("lambda", 2), rep("gamma", 2)),
        label_subscript = c(rep("", 6), "J", "A", rep("", 2))
    ),
    .f = function(state, xadjust, yadjust, label, label_subscript) {
        text(
            elpos[state, 1] + xadjust,
            elpos[state, 2] + yadjust,
            bquote(.(ensym(label))[.(label_subscript)]),
            cex = 2
        )
    }
)

par(op)
```

We can do this very simply using the same ingredients that go into the basic SIR model.
In that model, the waiting times in the S and I classes are exponential.
Let's assume the same thing about the aging process.
We'll also add in births into the juvenile susceptible class and deaths from the adult classes.

$$
  \begin{aligned}
    \frac{dS_J}{dt} &= B -\lambda_J\,S_J \phantom{- \gamma\,I_A} -\alpha\,S_J \phantom{-\mu\,S_A}\\
    \frac{dS_A}{dt} &= \phantom{B} - \lambda_A\,S_A \phantom{- \gamma\,I_A} +\alpha\,S_J -\mu\,S_A\\
    \frac{dI_J}{dt} &= \phantom{B} +\lambda_J\,S_J - \gamma\,I_J -\alpha\,I_J \phantom{-\mu\,S_A}\\
    \frac{dI_A}{dt} &= \phantom{B} +\lambda_A\,S_A - \gamma\,I_A + \alpha\,I_J - \mu\,I_A\\
    \frac{dR_J}{dt} &= \phantom{B - \lambda_J\,S_A} + \gamma\,I_J - \alpha\,R_J \phantom{- \mu\,S_A}\\
    \frac{dR_A}{dt} &= \phantom{B - \lambda_J\,S_A} + \gamma\,I_A + \alpha\,R_J -\mu\,R_A\\
  \end{aligned}
$$

Now, let's simulate this model, under the same assumptions about transmission rates as above.

```{r}
# define the parameters
demog_params <- c(
    beta_within = 0.004,
    beta_between = 0.002,
    recovery = 10,
    births = 100,
    age_bands = c(20, 60)
)
```

```{r}
ja_demog_model <- function (t, x, p, ...) {
    s <- x[c("Sj", "Sa")]    # susceptibles
    i <- x[c("Ij", "Ia")]    # infecteds
    r <- x[c("Rj", "Ra")]    # recovereds
    n <- s + i + r           # total pop

    beta_within <- p[1]
    beta_between <- p[2]
    recovery <- p[3]
    births <- p[4]
    aging_j <- 1 / p[5]
    aging_a <- 1 / p[6]

    # juv. force of infection 
    lambda_j <- beta_within * i[1] + beta_between * i[2]
    
    # adult. force of infection
    lambda_a <- beta_within * i[2] + beta_between * i[1]
    
    list(c(
        # dSj/dt    Note: only adults contribute to births
        (births) - (lambda_j * s[1]) - (aging_j * s[1]),
        # dSa/dt
        -(lambda_a * s[2]) + (aging_j * s[1]) - (aging_a * s[2]),
        # dIj/dt
        (lambda_j * s[1]) - (recovery * i[1]) - (aging_j * i[1]),
        # dIa/dt
        (lambda_a * s[2]) - (recovery * i[2]) + (aging_j * i[1]) - (aging_a * i[2]),
        # dRj/dt
        (recovery* i[1]) - (aging_j * r[1]),
        # dRa/dt
        (recovery * i[2]) + (aging_j * r[1]) - (aging_a * r[2])
    ))
}
```

Note that in this function, $\mu=$ `1 / p[6]`, i.e., death, is just like another age class.

```{r}
## initial conditions
demog_yinit <- c(Sj = 2000, Sa = 3000, Ij = 0, Ia = 1, Rj = 0, Ra = 1000)

sol_demog <- deSolve::ode(
    y = demog_yinit,
    times = seq(0, 200, by = 0.1),
    func = ja_demog_model,
    parms = demog_params
)

sol_demog_long <- sol_demog %>%
    as_tibble() %>%
    mutate(Nj = Sj + Ij + Rj, Na = Sa + Ia + Ra, N = Nj + Na) %>%
    pivot_longer(
        cols = -c(time, N),
        names_to = c("state", "group"),
        names_sep = 1,
        values_to = "value"
    ) %>%
    mutate(
        state = factor(state, levels = c("S", "I", "R", "N")),
        group = paste("Group", str_to_upper(group))
    )
```

### Exercise 1: Use this code to plot the number of susceptible, infected, and recovered individuals over time.

```{r}
ggplot(sol_demog_long, aes(x = time, y = value, color = state)) +
    geom_line(linewidth = 1.5) +
    facet_wrap(~group, nrow = 2, scales = "free_y") +
    scale_color_manual(
        values = SIRcolors,
        labels = c("Susceptible", "Infected", "Recovered", "Total")
    ) +
    labs(
        x = "Time",
        y = "Number of individuals",
        color = "State"
    ) +
    theme(legend.position = "bottom")
```

Note that now that births are replenishing susceptibles, infection persists. The results of the above are plotted here:

Now let's plot the proportion of individuals in each state for the two groups.

```{r}
sol_demog_long_props <- sol_demog_long %>%
    filter(state != "N") %>%
    mutate(
        state_group = paste0(state, str_extract_all(group, "[^Group ]")),
        state_group = factor(state_group, levels = c("RA", "RJ", "IA", "IJ", "SA", "SJ"))
    ) %>%
    group_by(time, state_group) %>%
    mutate(
        prop = value / N
    ) %>%
    ungroup()
```

```{r}
ggplot(sol_demog_long_props, aes(x = time, y = prop, fill = state_group)) +
    geom_area() +
    scale_fill_manual(
        values = c(Scolors, Icolors, Rcolors),
        limits = c("SA", "SJ", "IA", "IJ", "RA", "RJ")
    ) +
    labs(
        x = "Time",
        y = "Proportion of individuals",
        fill = "State"
    ) +
    theme(legend.position = "bottom")
```

Now let's plot the equilibrium seroprevalence for each age group.

```{r}
demog_equil_seroprev <- tail(sol_demog_long) %>%
    mutate(
        prop = value / sum(value),
        group = case_when(group == "Group J" ~ "Juveniles", TRUE ~ "Adults"),
        group = factor(group, levels = c("Juveniles", "Adults")),
        .by = group
    ) %>%
    filter(state == "R")
```

```{r}
age_group_colors <- c("#2980B9", "#154360")

ggplot(demog_equil_seroprev, aes(x = group, y = prop, fill = group)) +
    geom_col(position = "identity") +
    scale_fill_manual(
        values = age_group_colors
    ) +
    labs(
        x = "Age group",
        y = "Equilibrium seroprevalence",
        fill = "Age group"
    ) +
    theme(legend.position = "none")
```

To compute $R_0$, we need to know the stable age distribution (the relative proportion in the juvenile and adult age classes) of the population, which we can find by solving for the disease-free equilibrium: $S_J^*=B/\alpha$ and $S_A^*=B/\mu$.

With the stable age distribution, we can calculate $R_0$ by constructing the next generation matrix. Details on this method are described in the last section of this worksheet (@eq-ngm) and are not required for completing the exercises in the worksheet. The code below outlines how the next generation matrix is constructed using the $\alpha$ (aging from juvenile to adult), $\mu$ (death), $n$ (total births), $\gamma$ (recovery), $da$ (width of age groups in years), and $\beta$ (transmission) parameters. 


```{r}
# this code can be re-run to set parameter values
alpha <- 1 / demog_params["age_bands1"]
mu <- 1 / demog_params["age_bands2"]
n <- demog_params["births"] / c(alpha, mu)

beta_demog <- matrix(c(
    demog_params["beta_within"],
    demog_params["beta_between"],
    demog_params["beta_between"],
    demog_params["beta_within"]
    ),
    nrow = 2,
    ncol = 2
)

# this command creates the next generation matrix
ngm <- matrix(
    c(
        n[1] * (beta_demog[1, 1] / (demog_params["recovery"] + alpha)) +
            alpha / (demog_params["recovery"] + mu) *
            n[1] * beta_demog[1, 2] / (demog_params["recovery"] + mu),
        
        n[2] * beta_demog[2, 1] / (demog_params["recovery"] + alpha) +
            alpha / (demog_params["recovery"] + mu) *
            n[2] * (beta_demog[2, 2] / (demog_params["recovery"] + mu)),

        n[1] * beta_demog[1, 2] / (demog_params["recovery"] + mu),

        n[2] * beta_demog[2, 2] / (demog_params["recovery"] + mu)
    ),
    nrow = 2,
    ncol = 2
)

# this command outputs the R0 value
max(Re(eigen(ngm, only.values = TRUE)$values))
```

## Getting more realistic: adding more age classes

In the models above, the aging process follows an exponential distribution, which means that whether an individual is 1\~year old or 10 years old, the chance of them becoming an adult is the same!
To improve on this, we can assume that the time a juvenile must wait before becoming an adult follows a gamma distribution.
This is equivalent to saying that the waiting time is a sum of some number of exponential distributions.
This suggests that we can achieve such a distribution by adding age classes to the model, so that becoming an adult means passing through some number of stages.
We'll use 30 age classes, and since they don't have to be of equal duration, we'll assume that they're not.
Specifically, we'll have 20 1-yr age classes to take us up to adulthood and break adults into 10 age classes of 5\~yr duration each. The last age class covers age 66-80.

Now, when we had just two age classes, we could write out each of the equations easily enough, but now that we're going to have 30, we'll need to be more systematic.
In particular, we'll need to think of $\beta$ as a matrix of transmission rates.
Let's see how to define such a matrix in **R**.
So that we don't change too many things all at once, let's keep the same contact structure as in the juvenile-adult model.

```{r}
ages_params <- c(
    beta_j = 0.02,
    beta_a = 0.01,
    beta_aj = 0.01 / 2,
    recovery = 10,
    births = 100
)

ages <- c(seq(1, 20, by = 1), seq(25, 65, by = 5), 80) # upper end of age classes

da_ages <- diff(c(0, ages))                  # widths of age classes

# set up a matrix of contact rates between classes -- more contact within juveniles and adults than between
ages_beta_mat <- matrix(nrow = 30, ncol = 30)

# transmission rate for juveniles
ages_beta_mat[1:20, 1:20] <- ages_params["beta_j"]

# transmission rate for adults
ages_beta_mat[21:30, 21:30] <- ages_params["beta_a"]

# lower transmission rate between juveniles and adults
ages_beta_mat[1:20, 21:30] <- ages_params["beta_aj"]

# lower transmission rate between juveniles and adults
ages_beta_mat[21:30, 1:20] <- ages_params["beta_aj"]
```

<a id="fig-beta-mat"></a>

```{r}
ages_beta_mat %>%
    # Turn into a data.frame so we can use ggplot()
    as.data.frame.table() %>%
    mutate(
        Age_J = rep(ages, 30),
        Age_A = unlist(purrr::map(.x = ages, ~rep(.x, 30))),
    ) %>%
    ggplot(aes(x = Age_J, y = Age_A, z = Freq)) +
    geom_contour_filled(bins = 8) +
    scale_fill_brewer(
        palette = "Reds",
        drop = FALSE
    )
```

We'll assume that, at the time of introduction, all children are susceptible, as are adults over 45, but that individuals aged 20--45 have seen the pathogen before and are immune.
The vector `yinit` expresses these initial conditions.

```{r}
demog_yinit_ages <- c(
    S = c(rep(100, 20), rep(0, 5), rep(200, 5)),
    I = c(rep(0, 25), 1, rep(0, 4)),
    R = c(rep(0, 20), rep(1000, 5), rep(0, 5))
)
```

Note that we're starting out with 1 infected individual in the 26th age class.

The codes that follow will be a bit easier to follow if we introduce some indexes that will allow us to pick out certain bits of the `yinit` vector.

```{r}
sindex <- 1:30
iindex <- 31:60
rindex <- 61:90
juvies <- 1:20
adults <- 21:30
```

Now, to capture the aging process, it's convenient to define another matrix to hold the rates of movement between age classes.

```{r}
# Create a diagonal matrix that holds the rates of aging out of each age class
# The rows represent the age class you're in, the columns represent the age class
# you're moving to
aging_mat <- diag(-1 / da_ages)

# Fill in the rates of aging into each age class
aging_mat[row(aging_mat) - col(aging_mat) == 1] <- 1 / head(da_ages, -1)
```

Have a look at the aging matrix, for example by doing:

```{r}
# move fast through the 1-year age classes - negatives are moves out, positives are moves in
aging_mat[1:5,1:5]
```

```{r}
# don't age between these classes -- e.g. can't age from 1 to 6
aging_mat[1:10,1:10]
```

```{r}
# move slowly between the wider age classes
aging_mat[25:30,25:30]
```

```{r}
aging_mat %>%
    as.data.frame.table() %>%
    mutate(
        Age_J = rep(ages, 30),
        Age_A = unlist(purrr::map(.x = ages, ~rep(.x, 30)))
    ) %>%
    ggplot(aes(x = Age_J, y = Age_A, z = Freq)) +
    geom_contour_filled() +
    scale_fill_brewer(
        palette = "RdBu",
        drop = FALSE
    )
```

### Exercise 2: What can you say about its structure? How are the different age groups in contact with each other?

Now we can put the pieces together to write a simulator for the age-structured SIR dynamics.

```{r}
# Using a list instead of a vector to hold the parameters, as ages_beta_mat and aging 
# are both matrices, so we want to keep them as matrices, rather than flattening
multistage_params <- list(
    beta_mat = ages_beta_mat,
    gamma = ages_params[4],
    births = ages_params[5],
    aging_mat = aging_mat
)

ja_multistage_model <- function (t, x, p, ...) {
    s <- x[sindex]                  # susceptibles
    i <- x[iindex]                  # infecteds
    r <- x[rindex]                  # recovereds
    
    beta_mat <- p[["beta_mat"]]    # transmission rate

    gamma <- p[["gamma"]]   # recovery rate
    births <- p[["births"]] # birth rate
    aging_mat <- p[["aging_mat"]]

    lambda <- beta_mat %*% i        # force of infection
    
    dsdt <- -lambda * s + aging_mat %*% s
    didt <- lambda * s + aging_mat %*% i - gamma * i
    drdt <- aging_mat %*% r + gamma * i 
    dsdt[1] <- dsdt[1] + births
    
    list(c(dsdt, didt, drdt))

}
```

We can plug this into `ode` just as we did the simpler models to simulate an epidemic.
We'll then plot the epidemic curve.

```{r}
sol_ms <- deSolve::ode(
    y = demog_yinit_ages,
    times = seq(0, 100, by = 0.1),
    func = ja_multistage_model,
    parms = multistage_params
)

infects_ms <- sol_ms[, 1 + iindex]
```

```{r}
sol_ms_tibble <- tibble(
        time = sol_ms[, 1],
        Juveniles = apply(infects_ms[, juvies], 1, sum),
        Adults = apply(infects_ms[, adults], 1, sum)
    ) %>%
    pivot_longer(
        cols = c(Juveniles, Adults),
        names_to = "age_group",
        values_to = "infections"
    ) %>%
    mutate(
        age_group = factor(age_group, levels = c("Juveniles", "Adults"))
    )
```

```{r}
ggplot(sol_ms_tibble, aes(x = time, y = infections, color = age_group)) +
    geom_line(linewidth = 1.5) +
    scale_color_manual(
        values = age_group_colors
    ) +
    labs(
        x = "Time",
        y = "Number of infections",
        color = "Age group"
    )
```

Let's mimic a situation where we have cross-sectional seroprevalence data (e.g. measures of antibodies that tell you someone is in the R class).
In using such data, we'd typically assume that the system was at equilibrium.

### Exercise 3: What does the equilibrium age-specific seroprevalence look like in this example?
Use the code below to display the age-specific seroprevalence (i.e., the seroprevalence for each age group at equilibrium)

```{r}
equil_ms <- drop(tail(sol_ms, 1))[-1]
equil_n_ms <- equil_ms[sindex] + equil_ms[iindex] + equil_ms[rindex]
seroprev_ms <- equil_ms[rindex] / equil_n_ms

seroprev_ms_tibble <- tibble(
    age = ages,
    seroprev = seroprev_ms,
    width = da_ages
)
```

```{r}
ggplot(seroprev_ms_tibble, aes(x = age, y = seroprev, fill = age)) +
    geom_col(width = seroprev_ms_tibble$width, just = 1.0, color = "black") +
    labs(
        x = "Age",
        y = "Seroprevalence"
    ) +
    scale_x_continuous(breaks = seq(0, 80, 10)) +
    scale_fill_continuous(low = age_group_colors[1], high = age_group_colors[2])
```

Let's also compute $R_0$.
To do so, we'll need the stable age distribution.
We can get that by simulating an infection-free population, which we get by setting the initial I to all 0s:

```{r}
yinit_sonly <- c(
    S = c(rep(250, 30)),
    I = c(rep(0, 30)),
    R = c(rep(0, 30))
)

sol_sonly <- deSolve::ode(
    y = yinit_sonly,
    times = seq(0, 300, by = 1),
    func = ja_multistage_model,
    parms = list(
        beta_mat = ages_beta_mat,
        gamma = ages_params[3],
        births = demog_params["recovery"],
        aging_mat = aging_mat
    )
)

ms_sonly_pop <- tibble(
    time = sol_sonly[, 1],
    pop = apply(sol_sonly[, -1], 1 , sum)
)
```

```{r}
ggplot(ms_sonly_pop, aes(x = time, y = pop)) +
    geom_area(fill = SIRcolors[4], alpha = 0.6) +
    scale_y_continuous(
        breaks = seq(0, 8000, 2000),
        limits = c(0, 8000)
    ) +
    labs(
        x = "Time",
        y = "Population size"
    )
```

Alternatively, we can get the stable age distribution by finding the population structure that balances the birth, aging, and death processes.
At equilibrium, we have the matrix equation

$$
\begin{pmatrix}
    -\alpha_1 & 0 & 0 & \cdots & 0\\
    \alpha_1 & -\alpha_2 & 0 & \cdots & 0\\
    0 & \alpha_2 & -\alpha_3 & \cdots & 0\\
    \vdots &  & \ddots & \ddots & \vdots \\
    0 & \cdots & & \alpha_{29} & -\alpha_{30}\\
\end{pmatrix} .
\begin{pmatrix}
    n_1 \\ n_2 \\ n_3 \\ \vdots \\ n_{30}
\end{pmatrix} +
\begin{pmatrix}
    B \\ 0 \\ 0 \\ \vdots \\ 0
\end{pmatrix} =
\begin{pmatrix}
    0 \\ 0 \\ 0 \\ \vdots \\ 0
\end{pmatrix}
$$

To solve this equation in **R**, we can do

```{r}
# solve(a, b) solves the equation a %*% x = b for x, so rearrange equation above so b is on the RHS of the equation
ms_stable_n <- solve(
    aging_mat,
    c(-1 * multistage_params[["births"]], rep(0, 29))
)
```

The following lines then compute $R_0$ using the next generation matrix method. More details are available in the "Bonus" section at the end of the document.
This calculation comes from a recipe described in detail previously [@diekmann2000mathematical; @heesterbeekBriefHistoryR02002; @bjornstadAdvancedNextGenerationMatrix2018; @heffernanPerspectivesBasicReproductive2005; @hurfordNextgenerationToolsEvolutionary2009] (we would recommend starting with [@bjornstadAdvancedNextGenerationMatrix2018; and @heffernanPerspectivesBasicReproductive2005]).

```{r}
F <- diag(ms_stable_n) %*% multistage_params[["beta_mat"]] +
    multistage_params[["aging_mat"]] -
    diag(diag(multistage_params[["aging_mat"]]))

V <- diag(multistage_params[["gamma"]] - diag(multistage_params[["aging_mat"]]))

max(
    Re(
        eigen(solve(V, F), only.values = TRUE)$values
    )
)
```

The steps below are copied from [@bjornstadAdvancedNextGenerationMatrix2018]

1. Identify all n infected compartments
2. Construct a n × 1 matrix, $\mathbf{F}$, that contains expressions for all completely new infections entering each infected compartment
3. Construct a n × 1 matrix, $\mathbf{V^−}$, that contains expressions for all losses out of each infected compartment
4. Construct a n × 1 matrix, $\mathbf{V^+}$, that contains expressions for all gains into each infected compartment that does not represent new infections but transfers among infectious classes
5. Construct a n × 1 matrix, $\mathbf{V} = \mathbf{V^−} − \mathbf{V^+}$
6. Generate two n × n Jacobian matrices $f$ and $v$ that are the partial derivatives of $\mathbf{F}$ and $\mathbf{V}$ with respect to the $n$ infectious state variables
7. Evaluate the matrices at the disease free equilibrium (dfe), and finally
8. $R_0$ is the greatest eigenvalue of $\mathbf{fv}^{−1}|_{dfe}$.

```{r}
f <- diag(ms_stable_n) %*% multistage_params[["beta_mat"]]

# Losses occur due to recovery and aging
v_minus <- rep(multistage_params[["gamma"]], 30) +
    diag(multistage_params[["aging_mat"]])

# Non-infection gains occur due to aging
v_plus <- -diag(multistage_params[["aging_mat"]])

# Convert to matrix as required for solve() function
v <- diag(v_minus - v_plus)

max(
    Re(
        # Equivalent to fv^{-1} in the above recipe as solve effectively inverts
        # V
        eigen(solve(v, f), only.values = TRUE)$values
    )
)
```

### Exercise 4: 
#### a. Change the juvenile and adult contact rates (ages_params[1] and ages_params[2]) to reflect different transmission within groups. Make the juvenile contact rate 0.02 to reflect higher contact among kids (e.g. in schools).

```{r}
update_age_beta_mat <- matrix(data = 0.007, nrow = 30, ncol = 30)
update_age_beta_mat[1:20,1:20] <- 0.02
update_age_beta_mat[6:16,6:16] <- 0.03

update_age_params <- list(
    beta_mat = update_age_beta_mat,
    gamma = ages_params[4],
    births = ages_params[5],
    aging_mat = aging_mat
)
```

#### b. Edit the `ggplot` code from [Section 7.3](#fig-beta-mat) to plot the new beta matrix.

```{r}
update_age_beta_mat %>%
    # Turn into a data.frame so we can use ggplot()
    as.data.frame.table() %>%
    mutate(
        Age_J = rep(ages, 30),
        Age_A = unlist(purrr::map(.x = ages, ~rep(.x, 30))),
    ) %>%
    ggplot(aes(x = Age_J, y = Age_A, z = Freq)) +
    geom_contour_filled(bins = 8) +
    scale_fill_brewer(
        palette = "Reds",
        drop = FALSE
    )
```

::: {.callout-note}
You could also use the `fill.contour()` base-R function to plot the beta matrix without needing to do any dataframe modifications, but it doesn't look as nice ...
:::


#### c. Simulate and plot the age-structured SIR dynamics under your assumptions and record how the age-specific seroprevalence has changed.

```{r}
update_age_sol <- deSolve::ode(
    y = demog_yinit_ages,
    times = seq(0, 400, by = 0.1),
    func = ja_multistage_model,
    parms = update_age_params
)

# Get the time series for each infectious age group
update_age_infects <- update_age_sol[, 1 + iindex]
```

```{r}
update_age_sol_tibble <- tibble(
        time = update_age_sol[, 1],
        Juveniles = apply(update_age_infects[, juvies], 1, sum),
        Adults = apply(update_age_infects[, adults], 1, sum)
    ) %>%
    pivot_longer(
        cols = c(Juveniles, Adults),
        names_to = "age_group",
        values_to = "infections"
    ) %>%
    mutate(
        age_group = factor(age_group, levels = c("Juveniles", "Adults"))
    )
```

```{r}
ggplot(update_age_sol_tibble, aes(x = time, y = infections, color = age_group)) +
    geom_line(linewidth = 1.5) +
    scale_color_manual(
        values = age_group_colors
    ) +
    labs(
        x = "Time",
        y = "Number of infections",
        color = "Age group"
    )
```

```{r}
update_age_equil <- drop(tail(update_age_sol, 1))[-1]

update_age_equil_n <- update_age_equil[sindex] +
    update_age_equil[iindex] +
    update_age_equil[rindex]

update_age_seroprev <- update_age_equil[rindex] / update_age_equil_n

update_age_seroprev_tibble <- tibble(
    age = ages,
    seroprev = update_age_seroprev,
    width = da_ages
)
```

```{r}
ggplot(update_age_seroprev_tibble, aes(x = age, y = seroprev, fill = age)) +
    geom_col(width = update_age_seroprev_tibble$width, just = 1.0, color = "black") +
    labs(
        x = "Age",
        y = "Seroprevalence"
    ) +
    scale_x_continuous(breaks = seq(0, 80, 10)) +
    scale_fill_continuous(low = age_group_colors[1], high = age_group_colors[2])
```

#### d. Compute $R_0$ for your assumptions.

```{r}
F <- diag(update_age_equil_n) %*% update_age_beta_mat +
    update_age_params[["aging_mat"]] -
    diag(diag(update_age_params[["aging_mat"]]))

V <- diag(update_age_params[["gamma_ages"]] - diag(update_age_params[["aging_mat"]]))

max(Re(eigen(solve(V, F), only.values = TRUE)$values))
# R0 = 6.53

# Find the equilibrium values for each infected age group
update_age_infects_equil <- update_age_infects[dim(update_age_infects)[1], ]

# Estimate R0 using the equilibrium values and how long people stay in each age group
sum(ages * update_age_infects_equil / sum(update_age_infects_equil))

sum(update_age_infects_equil[15:23])
```

```{r}
update_age_sol_tibble <- as_tibble(update_age_sol) %>%
    mutate(across(everything(), as.numeric)) %>%
    pivot_longer(
        cols = -time,
        names_to = c("state", "age_index"),
        names_pattern = "(.)(.*)",
        values_to = "number"
    ) %>%
    mutate(
        age = ages[as.integer(age_index)],
        state = factor(state, labels = c("S", "I", "R")),
    )
```

```{r}
ggplot(update_age_sol_tibble, aes(x = time, y = number, color = age, group = age)) +
    geom_line(linewidth = 1.5) +
    facet_wrap(~state, ncol = 1, scale = "free_y") +
    labs(
        x = "Time",
        y = "Number of individuals",
        color = "Age"
    )
```

## R0 and the mean age of infection

For simplicity, let's return to the earlier models with a simple age-class mixing matrix.
But this time, we'll calculate $R_0$, the mean age of infection, and the number of cases between 15-35 years as we increase the rate of contact. Recall from the rubella and CRS example that the risk of severe disease outcomes depends on the risk of infection in reproductive age women. Recall also that increasing vaccination reduces $R_E$ -- so here we'll evalate at several values of $R_0$ as a proxy for the impact of vaccination. We'll then calculate how the mean age of infection changes, and specifically how the absolute number of cases among individuals between the ages of 15-35 (as a proxy for reproductive age women) changes. 
To do so, we'll make a loop and evaluate the code for each of 10 increasing levels of mixing (which whill change R0)

```{r}
# a vector of scaling factors, we'll reduce the contact rate 
# from the original code by each of the values in this vector
scale <- seq(0.2, 1, length = 10) 
R0 <- numeric() # somewhere to store results for the mean age
mean_age <- numeric() # somewhere to store results for the mean age
sum_cases <- numeric() # somewhere to store results for the mean age

# this loop will run for as many different levels of contact that we specify 
# for the scale variable 
# this is the same code as above, but now we've included a multiplier for the 
# contact matrix
for(ii in 1:length(scale)){ 
    beta1 <- 0.007
    beta2 <- 0.02
    b3 <- 0.03
    beta <- matrix(data = beta1, nrow = 30, ncol = 30)
    beta[1:20,1:20] <- beta2
    beta[6:16,6:16] <- b3
    beta_mat <- beta * scale[ii]
    #filled.contour(beta)

    params <- list(
        beta_mat = beta_mat,
        gamma = ages_params[3],
        aging_mat = aging_mat,
        births = demog_params[4]
    )

    sol_R0 <- deSolve::ode(
        y = demog_yinit_ages,
        times = seq(0, 400, by = 0.1),
        func = ja_multistage_model,
        parms = params
    )

    equil_R0 <- drop(tail(sol_R0, 1))[-1]
    n_R0 <- equil_R0[sindex] + equil_R0[iindex] + equil_R0[rindex]
    seroprev_R0 <- equil_R0[rindex] / n_R0
    names(seroprev_R0) <- ages
    # barplot(height=seroprev,width=da)

    ## get stable age distribution
    n_R0 <- solve(
        params[["aging_mat"]],
        -c(params[["births"]], rep(0, 29))
    )
    ## get R0
    F_R0 <- diag(n_R0) %*% params[["beta_mat"]] +
        params[["aging_mat"]] -
        diag(diag(params[["aging_mat"]]))

    V_R0 <- diag(params[["gamma"]] -
        diag(params[["aging_mat"]]))

    R0[ii] <- max(
        Re(
            eigen(solve(V_R0, F_R0), only.values = TRUE)$values
        )
    )
    # R0 = 6.53
    infects_R0 <- sol_R0[dim(sol_R0)[1],1+iindex]
    mean_age[ii] <- sum(ages * infects_R0 / sum(infects_R0))
    sum_cases[ii] <- sum(infects_R0[15:23])
}
```

Now we can make a table of the results and plot mean age and the sum of cases between 15-35 years of age as a function of $R_0$.

```{r}
df <- data.frame(R0 = R0, "mean age" = mean_age, "cases (15-35y)" = sum_cases)

knitr::kable(df)

par(mfrow=c(1,2))
plot(R0, mean_age, xlab = "R0", ylab = "mean age of infection")
plot(R0, sum_cases, xlab = "R0", ylab = "total cases between 15-35y")
```
```{r}
par(mfrow=c(1, 1))
```

### Exercise 5: Try the same as you fix $R_0$ but change the birth rate (as if new infants were vaccinated), instead of changing the contact rate. 

For example, if the birth rate was 100 before, try using a sequence of birth rates ranging from 100 (i.e. no new infants are vaccinated) to 75 (i.e., 25% of new infants are vaccinated). You can use the technique we used above, where we ran the simulation in a loop multiple times, for varying levels of contact, modifying it to run on varying levels of births (e.g., between 75 and 100). 

```{r}
births_seq <- seq(75, 100, length = 10)  # a vector of scaling factors, we'll reduce the contact rate from the original code by each of the values in this vector
R0_b <- numeric() # somewhere to store results for the mean age
mean_age_b <- numeric() # somewhere to store results for the mean age
sum_cases_b <- numeric() # somewhere to store results for the mean age

for(ii in 1:10){
    #this is the same code as above, but now we're modifying births
    beta1 <- 0.007
    beta2 <- 0.02
    b3 <- 0.03
    beta <- matrix(data = beta1, nrow = 30, ncol = 30)
    beta[1:20,1:20] <- beta2
    beta[6:16,6:16] <- b3
    beta_mat <- beta
    births_ages <- births_seq[ii]
    #filled.contour(beta)

    params <- list(
        beta_mat = beta_mat,
        gamma = ages_params[3],
        aging_mat = aging_mat,
        births = births_ages
    )

    sol_b <- deSolve::ode(
        y = demog_yinit_ages,
        times = seq(0, 400, by = 0.1),
        func = ja_multistage_model,
        parms = params
    )

    equil_b <- drop(tail(sol_b, 1))[-1]
    n_b <- equil_b[sindex] + equil_b[iindex] + equil_b[rindex]
    seroprev_b <- equil_b[rindex] / n_b
    names(seroprev_b) <- ages
    # barplot(height=seroprev,width=da)

    ## get stable age distribution
    n_b <- solve(
        params[["aging_mat"]],
        -c(params[["births"]], rep(0, 29))
    )
    ## get R0
    F_R0 <- diag(n_R0) %*% params[["beta_mat"]] +
        params[["aging_mat"]] -
        diag(diag(params[["aging_mat"]]))

    V_R0 <- diag(params[["gamma"]] -
        diag(params[["aging_mat"]]))

    R0_b[ii] <- max(
        Re(
            eigen(solve(V_R0, F_R0), only.values = TRUE)$values
        )
    )
    # R0 = 6.53
    infects_b <- sol_b[dim(sol_b)[1],1+iindex]
    mean_age_b[ii] <- sum(ages * infects_b/sum(infects_b))
    sum_cases_b[ii] <- sum(infects_b[15:23])
}

```

```{r}
df <- data.frame(
    births = births_seq,
    R0 = R0_b,
    "mean age" = mean_age_b,
    "cases (15-35y)" = sum_cases_b
)

knitr::kable(df)

par(mfrow = c(1, 2))
plot(births_seq, mean_age_b, xlab = "births", ylab = "mean age of infection")
plot(births_seq, sum_cases_b, xlab = "births", ylab = "total cases between 15-35y")
#plot(births_seq,R0_b,xlab="births",ylab="R0")
```



## What do real contact networks look like?

The POLYMOD study **Mossong, 2008** was a journal-based look into the contact network in contemporary European society.
Let's have a look what these data tell us about the contact structure.

```{r}
moss <- read.csv(
    url("http://www.math.mcmaster.ca/~bolker/eeid/data/mossong.csv"),
    as.is = TRUE
)

age_categories <- moss$contactor[1:30]
moss$contactor <- ordered(moss$contactor, levels = age_categories)
moss$contactee <- ordered(moss$contactee, levels = age_categories)
```

Since contacts are symmetric, we'll need to estimate the symmetric contact matrix.

```{r}
x1 <- with(
    moss,
    tapply(contact.rate, list(contactor, contactee), unique)
)

xsym <- (x1 + t(x1)) / 2
```

```{r}
filled.contour(ages, ages, log10(xsym))
filled.contour(
    ages, ages, log10(xsym),
    plot.title = title(
        main = quote(log[10](contact ~ rate)),
        xlab = "age", ylab = "age"
    )
)

barplot(height=apply(x1,1,sum))
barplot(height=apply(x1,2,sum))
```

While this matrix tells us how many contacts are made per year by an individual of each age, it doesn't tell us anything about the probability that a contact results in communication of infection.
Let's assume that each contact has a constant probability $q$ of resulting in a transmission event.

```{r}
q <- 3e-5
ages_beta_mat <- q * xsym

filled.contour(
    ages,ages,log10(ages_beta_mat),
    plot.title = title(
        main="WAIFW matrix based on POLYMOD data",
        xlab="age", ylab="age"
    )
)

```

Now let's simulate the introduction of such a pathogen into a population characterized by this contact structure.

```{r}
sol_p <- deSolve::ode(
    y = demog_yinit_ages,
    times = seq(0, 200, by = 0.5),
    func = ja_multistage_model,
    parms = multistage_params
)

time <- sol_p[, 1]
infects_p <- sol_p[, 1+iindex]
plot(time, apply(infects_p, 1, sum), type = 'l')
lines(time, apply(infects_p[, juvies], 1, sum), col = 'red')
lines(time, apply(infects_p[, adults], 1, sum), col = 'blue')
```

As before, we can also look at the equilibrium seroprevalence

```{r}
equil_p <- drop(tail(sol_p, 1))[-1]

n_p <- equil_p[sindex] + equil_p[iindex] + equil_p[rindex]

seroprev_p <- equil_p[rindex] / n_p

names(seroprev_p) <- ages

barplot(height = seroprev_p, width = c(demog_params[5:6]))
```

and compute the $R_0$ for this infection.

```{r}
n_p <- solve(
    multistage_params[["aging_mat"]],
    -c(multistage_params[["births"]], rep(0, 29))
)

F_p <- diag(n_p) %*% multistage_params[["beta_mat"]] +
    multistage_params[["aging_mat"]] -
    diag(diag(multistage_params[["aging_mat"]]))

V_p <- diag(
    multistage_params[["gamma"]] -
        diag(multistage_params[["aging_mat"]])
    )

max(
    Re(
        eigen(solve(V_p,F_p),only.values=T)$values
    )
)
```

How does this R0 value compare to the R0 value obtained from Exercise 4?

```{r}
par(mfrow=c(1,1))
```

## Bonus: Calculating R0 Using a Next Generation Matrix

The next generation matrix is a matrix that specifies how many new age-specific infections are generated by a typical infected individual of each age class (in a fully susceptible population).
For example, let's consider an infected adult and ask how many new juvenile infections it generates: this is the product of the number of susceptible juveniles (from the stable age distribution), the per capita transmission rate from adults to juveniles and the average duration of infection, i.e. $S_J^* \times \beta_{JA} \times 1/ (\gamma+\mu)$.
This forms one element of our next generation matrix.
The other elements look very similar, except there are extra terms when we consider an infected juvenile because there is a (very small) chance they may age during the infectious period and therefore cause new infections as an adult:

$$
\mathrm{NGM} = \begin{pmatrix}
        \frac{S_J^* \beta_{JJ}}{(\gamma + \alpha)} +
        \frac{\alpha}{(\gamma+\mu)} \frac{S_J^* \beta_{JA}}{(\gamma + \mu)} &
        \frac{S_J^* \beta_{JA}}{(\gamma + \mu)} \\
        \frac{S_A^* \beta_{AJ}}{(\gamma + \alpha)} + 
            \frac{\alpha}{(\gamma + \mu)} \frac{S_A^*\beta_{AA}}{(\gamma+\mu)} &
            \frac{S_A^* \beta_{AA}}{(\gamma + \mu)} 
    \end{pmatrix}
$$ {#eq-ngm}

$R_0$ can then be computed as the dominant eigenvalue (i.e., the one with the largest real part) of this matrix. Let's take an example from a model with 2 age classes, from above. First, let's define the components of the next generation matrix:

```{r}
da_ngm <- c(20, 60) # this classifies the two age groups (0-20, 21-60) 
beta1_ngm = 0.005
beta2_ngm = 0.006
alpha_ngm <- 1/da_ngm[1]
mu_ngm <- 1/da_ngm[2]
n_ngm <- demog_params[4] / c(alpha_ngm, mu_ngm)

beta_ngm <- matrix(
    c(beta1_ngm + beta2_ngm, beta1_ngm, beta1_ngm, beta1_ngm + beta2_ngm),
    nrow = 2,
    ncol = 2
)

gamma_ngm = 10
```



The Next Generation Matrix can be calculated in **R** as:

```{r}
ngm <- matrix(
    c(
        n_ngm[1] * beta_ngm[1,1] / (gamma_ngm+alpha_ngm) +
            alpha_ngm / (gamma_ngm+mu_ngm) *
            n[1] *
            beta_ngm[1,2] / (gamma_ngm+mu_ngm),
        n_ngm[2] * beta_ngm[2,1] / (gamma_ngm+alpha_ngm) +
            alpha_ngm / (gamma_ngm+mu_ngm) *
            n[2] *
            beta_ngm[2,2] / (gamma_ngm+mu_ngm),
        n_ngm[1] * beta_ngm[1,2] / (gamma_ngm+mu_ngm),
        n_ngm[2] * beta_ngm[2,2] / (gamma_ngm+mu_ngm)
        ),
    nrow = 2,
    ncol = 2
)

eigen(ngm)
eigen(ngm, only.values = TRUE)

max(
    Re(
        eigen(ngm, only.values = TRUE)$values
    )
)
```
